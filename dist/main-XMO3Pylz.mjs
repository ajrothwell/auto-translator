var Lt = Object.defineProperty;
var Ft = (w, M, x) => M in w ? Lt(w, M, { enumerable: !0, configurable: !0, writable: !0, value: x }) : w[M] = x;
var ct = (w, M, x) => Ft(w, typeof M != "symbol" ? M + "" : M, x);
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs$1(w) {
  return w && w.__esModule && Object.prototype.hasOwnProperty.call(w, "default") ? w.default : w;
}
function getDefaultExportFromCjs(w) {
  return w && w.__esModule && Object.prototype.hasOwnProperty.call(w, "default") ? w.default : w;
}
var browser$d = { exports: {} }, process = browser$d.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout;
  } catch {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout;
  } catch {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(w) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(w, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(w, 0);
  try {
    return cachedSetTimeout(w, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, w, 0);
    } catch {
      return cachedSetTimeout.call(this, w, 0);
    }
  }
}
function runClearTimeout(w) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(w);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(w);
  try {
    return cachedClearTimeout(w);
  } catch {
    try {
      return cachedClearTimeout.call(null, w);
    } catch {
      return cachedClearTimeout.call(this, w);
    }
  }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var w = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var M = queue.length; M; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < M; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, M = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(w);
  }
}
process.nextTick = function(w) {
  var M = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var x = 1; x < arguments.length; x++)
      M[x - 1] = arguments[x];
  queue.push(new Item(w, M)), queue.length === 1 && !draining && runTimeout(drainQueue);
};
function Item(w, M) {
  this.fun = w, this.array = M;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(w) {
  return [];
};
process.binding = function(w) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(w) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports$1 = browser$d.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports$1);
var assert$k = { exports: {} }, errors = {}, util$3 = {}, types = {}, shams$1 = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var M = {}, x = Symbol("test"), $ = Object(x);
  if (typeof x == "string" || Object.prototype.toString.call(x) !== "[object Symbol]" || Object.prototype.toString.call($) !== "[object Symbol]")
    return !1;
  var T = 42;
  M[x] = T;
  for (var S in M)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(M).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(M).length !== 0)
    return !1;
  var D = Object.getOwnPropertySymbols(M);
  if (D.length !== 1 || D[0] !== x || !Object.prototype.propertyIsEnumerable.call(M, x))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var F = (
      /** @type {PropertyDescriptor} */
      Object.getOwnPropertyDescriptor(M, x)
    );
    if (F.value !== T || F.enumerable !== !0)
      return !1;
  }
  return !0;
}, hasSymbols$3 = shams$1, shams = function() {
  return hasSymbols$3() && !!Symbol.toStringTag;
}, esObjectAtoms = Object, esErrors = Error, _eval = EvalError, range = RangeError, ref = ReferenceError, syntax = SyntaxError, type = TypeError, uri = URIError, abs$1 = Math.abs, floor$1 = Math.floor, max$2 = Math.max, min$1 = Math.min, pow$1 = Math.pow, round$1 = Math.round, _isNaN = Number.isNaN || function(M) {
  return M !== M;
}, $isNaN = _isNaN, sign$2 = function(M) {
  return $isNaN(M) || M === 0 ? M : M < 0 ? -1 : 1;
}, gOPD$3 = Object.getOwnPropertyDescriptor, $gOPD$1 = gOPD$3;
if ($gOPD$1)
  try {
    $gOPD$1([], "length");
  } catch {
    $gOPD$1 = null;
  }
var gopd$1 = $gOPD$1, $defineProperty$3 = Object.defineProperty || !1;
if ($defineProperty$3)
  try {
    $defineProperty$3({}, "a", { value: 1 });
  } catch {
    $defineProperty$3 = !1;
  }
var esDefineProperty = $defineProperty$3, hasSymbols$2, hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols$2;
  hasRequiredHasSymbols = 1;
  var w = typeof Symbol < "u" && Symbol, M = shams$1;
  return hasSymbols$2 = function() {
    return typeof w != "function" || typeof Symbol != "function" || typeof w("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : M();
  }, hasSymbols$2;
}
var Reflect_getPrototypeOf, hasRequiredReflect_getPrototypeOf;
function requireReflect_getPrototypeOf() {
  return hasRequiredReflect_getPrototypeOf || (hasRequiredReflect_getPrototypeOf = 1, Reflect_getPrototypeOf = typeof Reflect < "u" && Reflect.getPrototypeOf || null), Reflect_getPrototypeOf;
}
var Object_getPrototypeOf, hasRequiredObject_getPrototypeOf;
function requireObject_getPrototypeOf() {
  if (hasRequiredObject_getPrototypeOf) return Object_getPrototypeOf;
  hasRequiredObject_getPrototypeOf = 1;
  var w = esObjectAtoms;
  return Object_getPrototypeOf = w.getPrototypeOf || null, Object_getPrototypeOf;
}
var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ", toStr$4 = Object.prototype.toString, max$1 = Math.max, funcType = "[object Function]", concatty = function(M, x) {
  for (var $ = [], T = 0; T < M.length; T += 1)
    $[T] = M[T];
  for (var S = 0; S < x.length; S += 1)
    $[S + M.length] = x[S];
  return $;
}, slicy = function(M, x) {
  for (var $ = [], T = x, S = 0; T < M.length; T += 1, S += 1)
    $[S] = M[T];
  return $;
}, joiny = function(w, M) {
  for (var x = "", $ = 0; $ < w.length; $ += 1)
    x += w[$], $ + 1 < w.length && (x += M);
  return x;
}, implementation$8 = function(M) {
  var x = this;
  if (typeof x != "function" || toStr$4.apply(x) !== funcType)
    throw new TypeError(ERROR_MESSAGE + x);
  for (var $ = slicy(arguments, 1), T, S = function() {
    if (this instanceof T) {
      var H = x.apply(
        this,
        concatty($, arguments)
      );
      return Object(H) === H ? H : this;
    }
    return x.apply(
      M,
      concatty($, arguments)
    );
  }, D = max$1(0, x.length - $.length), F = [], z = 0; z < D; z++)
    F[z] = "$" + z;
  if (T = Function("binder", "return function (" + joiny(F, ",") + "){ return binder.apply(this,arguments); }")(S), x.prototype) {
    var Z = function() {
    };
    Z.prototype = x.prototype, T.prototype = new Z(), Z.prototype = null;
  }
  return T;
}, implementation$7 = implementation$8, functionBind = Function.prototype.bind || implementation$7, functionCall, hasRequiredFunctionCall;
function requireFunctionCall() {
  return hasRequiredFunctionCall || (hasRequiredFunctionCall = 1, functionCall = Function.prototype.call), functionCall;
}
var functionApply, hasRequiredFunctionApply;
function requireFunctionApply() {
  return hasRequiredFunctionApply || (hasRequiredFunctionApply = 1, functionApply = Function.prototype.apply), functionApply;
}
var reflectApply$1 = typeof Reflect < "u" && Reflect && Reflect.apply, bind$3 = functionBind, $apply$2 = requireFunctionApply(), $call$2 = requireFunctionCall(), $reflectApply = reflectApply$1, actualApply$1 = $reflectApply || bind$3.call($call$2, $apply$2), bind$2 = functionBind, $TypeError$5 = type, $call$1 = requireFunctionCall(), $actualApply = actualApply$1, callBindApplyHelpers = function(M) {
  if (M.length < 1 || typeof M[0] != "function")
    throw new $TypeError$5("a function is required");
  return $actualApply(bind$2, $call$1, M);
}, get, hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get;
  hasRequiredGet = 1;
  var w = callBindApplyHelpers, M = gopd$1, x;
  try {
    x = /** @type {{ __proto__?: typeof Array.prototype }} */
    [].__proto__ === Array.prototype;
  } catch (D) {
    if (!D || typeof D != "object" || !("code" in D) || D.code !== "ERR_PROTO_ACCESS")
      throw D;
  }
  var $ = !!x && M && M(
    Object.prototype,
    /** @type {keyof typeof Object.prototype} */
    "__proto__"
  ), T = Object, S = T.getPrototypeOf;
  return get = $ && typeof $.get == "function" ? w([$.get]) : typeof S == "function" ? (
    /** @type {import('./get')} */
    function(F) {
      return S(F == null ? F : T(F));
    }
  ) : !1, get;
}
var getProto$3, hasRequiredGetProto;
function requireGetProto() {
  if (hasRequiredGetProto) return getProto$3;
  hasRequiredGetProto = 1;
  var w = requireReflect_getPrototypeOf(), M = requireObject_getPrototypeOf(), x = requireGet();
  return getProto$3 = w ? function(T) {
    return w(T);
  } : M ? function(T) {
    if (!T || typeof T != "object" && typeof T != "function")
      throw new TypeError("getProto: not an object");
    return M(T);
  } : x ? function(T) {
    return x(T);
  } : null, getProto$3;
}
var hasown, hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var w = Function.prototype.call, M = Object.prototype.hasOwnProperty, x = functionBind;
  return hasown = x.call(w, M), hasown;
}
var undefined$1, $Object$1 = esObjectAtoms, $Error = esErrors, $EvalError = _eval, $RangeError = range, $ReferenceError = ref, $SyntaxError$1 = syntax, $TypeError$4 = type, $URIError = uri, abs = abs$1, floor = floor$1, max = max$2, min = min$1, pow = pow$1, round = round$1, sign$1 = sign$2, $Function = Function, getEvalledConstructor = function(w) {
  try {
    return $Function('"use strict"; return (' + w + ").constructor;")();
  } catch {
  }
}, $gOPD = gopd$1, $defineProperty$2 = esDefineProperty, throwTypeError = function() {
  throw new $TypeError$4();
}, ThrowTypeError = $gOPD ? function() {
  try {
    return arguments.callee, throwTypeError;
  } catch {
    try {
      return $gOPD(arguments, "callee").get;
    } catch {
      return throwTypeError;
    }
  }
}() : throwTypeError, hasSymbols$1 = requireHasSymbols()(), getProto$2 = requireGetProto(), $ObjectGPO = requireObject_getPrototypeOf(), $ReflectGPO = requireReflect_getPrototypeOf(), $apply$1 = requireFunctionApply(), $call = requireFunctionCall(), needsEval = {}, TypedArray = typeof Uint8Array > "u" || !getProto$2 ? undefined$1 : getProto$2(Uint8Array), INTRINSICS = {
  __proto__: null,
  "%AggregateError%": typeof AggregateError > "u" ? undefined$1 : AggregateError,
  "%Array%": Array,
  "%ArrayBuffer%": typeof ArrayBuffer > "u" ? undefined$1 : ArrayBuffer,
  "%ArrayIteratorPrototype%": hasSymbols$1 && getProto$2 ? getProto$2([][Symbol.iterator]()) : undefined$1,
  "%AsyncFromSyncIteratorPrototype%": undefined$1,
  "%AsyncFunction%": needsEval,
  "%AsyncGenerator%": needsEval,
  "%AsyncGeneratorFunction%": needsEval,
  "%AsyncIteratorPrototype%": needsEval,
  "%Atomics%": typeof Atomics > "u" ? undefined$1 : Atomics,
  "%BigInt%": typeof BigInt > "u" ? undefined$1 : BigInt,
  "%BigInt64Array%": typeof BigInt64Array > "u" ? undefined$1 : BigInt64Array,
  "%BigUint64Array%": typeof BigUint64Array > "u" ? undefined$1 : BigUint64Array,
  "%Boolean%": Boolean,
  "%DataView%": typeof DataView > "u" ? undefined$1 : DataView,
  "%Date%": Date,
  "%decodeURI%": decodeURI,
  "%decodeURIComponent%": decodeURIComponent,
  "%encodeURI%": encodeURI,
  "%encodeURIComponent%": encodeURIComponent,
  "%Error%": $Error,
  "%eval%": eval,
  // eslint-disable-line no-eval
  "%EvalError%": $EvalError,
  "%Float16Array%": typeof Float16Array > "u" ? undefined$1 : Float16Array,
  "%Float32Array%": typeof Float32Array > "u" ? undefined$1 : Float32Array,
  "%Float64Array%": typeof Float64Array > "u" ? undefined$1 : Float64Array,
  "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? undefined$1 : FinalizationRegistry,
  "%Function%": $Function,
  "%GeneratorFunction%": needsEval,
  "%Int8Array%": typeof Int8Array > "u" ? undefined$1 : Int8Array,
  "%Int16Array%": typeof Int16Array > "u" ? undefined$1 : Int16Array,
  "%Int32Array%": typeof Int32Array > "u" ? undefined$1 : Int32Array,
  "%isFinite%": isFinite,
  "%isNaN%": isNaN,
  "%IteratorPrototype%": hasSymbols$1 && getProto$2 ? getProto$2(getProto$2([][Symbol.iterator]())) : undefined$1,
  "%JSON%": typeof JSON == "object" ? JSON : undefined$1,
  "%Map%": typeof Map > "u" ? undefined$1 : Map,
  "%MapIteratorPrototype%": typeof Map > "u" || !hasSymbols$1 || !getProto$2 ? undefined$1 : getProto$2((/* @__PURE__ */ new Map())[Symbol.iterator]()),
  "%Math%": Math,
  "%Number%": Number,
  "%Object%": $Object$1,
  "%Object.getOwnPropertyDescriptor%": $gOPD,
  "%parseFloat%": parseFloat,
  "%parseInt%": parseInt,
  "%Promise%": typeof Promise > "u" ? undefined$1 : Promise,
  "%Proxy%": typeof Proxy > "u" ? undefined$1 : Proxy,
  "%RangeError%": $RangeError,
  "%ReferenceError%": $ReferenceError,
  "%Reflect%": typeof Reflect > "u" ? undefined$1 : Reflect,
  "%RegExp%": RegExp,
  "%Set%": typeof Set > "u" ? undefined$1 : Set,
  "%SetIteratorPrototype%": typeof Set > "u" || !hasSymbols$1 || !getProto$2 ? undefined$1 : getProto$2((/* @__PURE__ */ new Set())[Symbol.iterator]()),
  "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? undefined$1 : SharedArrayBuffer,
  "%String%": String,
  "%StringIteratorPrototype%": hasSymbols$1 && getProto$2 ? getProto$2(""[Symbol.iterator]()) : undefined$1,
  "%Symbol%": hasSymbols$1 ? Symbol : undefined$1,
  "%SyntaxError%": $SyntaxError$1,
  "%ThrowTypeError%": ThrowTypeError,
  "%TypedArray%": TypedArray,
  "%TypeError%": $TypeError$4,
  "%Uint8Array%": typeof Uint8Array > "u" ? undefined$1 : Uint8Array,
  "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? undefined$1 : Uint8ClampedArray,
  "%Uint16Array%": typeof Uint16Array > "u" ? undefined$1 : Uint16Array,
  "%Uint32Array%": typeof Uint32Array > "u" ? undefined$1 : Uint32Array,
  "%URIError%": $URIError,
  "%WeakMap%": typeof WeakMap > "u" ? undefined$1 : WeakMap,
  "%WeakRef%": typeof WeakRef > "u" ? undefined$1 : WeakRef,
  "%WeakSet%": typeof WeakSet > "u" ? undefined$1 : WeakSet,
  "%Function.prototype.call%": $call,
  "%Function.prototype.apply%": $apply$1,
  "%Object.defineProperty%": $defineProperty$2,
  "%Object.getPrototypeOf%": $ObjectGPO,
  "%Math.abs%": abs,
  "%Math.floor%": floor,
  "%Math.max%": max,
  "%Math.min%": min,
  "%Math.pow%": pow,
  "%Math.round%": round,
  "%Math.sign%": sign$1,
  "%Reflect.getPrototypeOf%": $ReflectGPO
};
if (getProto$2)
  try {
    null.error;
  } catch (w) {
    var errorProto = getProto$2(getProto$2(w));
    INTRINSICS["%Error.prototype%"] = errorProto;
  }
var doEval = function w(M) {
  var x;
  if (M === "%AsyncFunction%")
    x = getEvalledConstructor("async function () {}");
  else if (M === "%GeneratorFunction%")
    x = getEvalledConstructor("function* () {}");
  else if (M === "%AsyncGeneratorFunction%")
    x = getEvalledConstructor("async function* () {}");
  else if (M === "%AsyncGenerator%") {
    var $ = w("%AsyncGeneratorFunction%");
    $ && (x = $.prototype);
  } else if (M === "%AsyncIteratorPrototype%") {
    var T = w("%AsyncGenerator%");
    T && getProto$2 && (x = getProto$2(T.prototype));
  }
  return INTRINSICS[M] = x, x;
}, LEGACY_ALIASES = {
  __proto__: null,
  "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
  "%ArrayPrototype%": ["Array", "prototype"],
  "%ArrayProto_entries%": ["Array", "prototype", "entries"],
  "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
  "%ArrayProto_keys%": ["Array", "prototype", "keys"],
  "%ArrayProto_values%": ["Array", "prototype", "values"],
  "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
  "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
  "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
  "%BooleanPrototype%": ["Boolean", "prototype"],
  "%DataViewPrototype%": ["DataView", "prototype"],
  "%DatePrototype%": ["Date", "prototype"],
  "%ErrorPrototype%": ["Error", "prototype"],
  "%EvalErrorPrototype%": ["EvalError", "prototype"],
  "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
  "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
  "%FunctionPrototype%": ["Function", "prototype"],
  "%Generator%": ["GeneratorFunction", "prototype"],
  "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
  "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
  "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
  "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
  "%JSONParse%": ["JSON", "parse"],
  "%JSONStringify%": ["JSON", "stringify"],
  "%MapPrototype%": ["Map", "prototype"],
  "%NumberPrototype%": ["Number", "prototype"],
  "%ObjectPrototype%": ["Object", "prototype"],
  "%ObjProto_toString%": ["Object", "prototype", "toString"],
  "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
  "%PromisePrototype%": ["Promise", "prototype"],
  "%PromiseProto_then%": ["Promise", "prototype", "then"],
  "%Promise_all%": ["Promise", "all"],
  "%Promise_reject%": ["Promise", "reject"],
  "%Promise_resolve%": ["Promise", "resolve"],
  "%RangeErrorPrototype%": ["RangeError", "prototype"],
  "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
  "%RegExpPrototype%": ["RegExp", "prototype"],
  "%SetPrototype%": ["Set", "prototype"],
  "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
  "%StringPrototype%": ["String", "prototype"],
  "%SymbolPrototype%": ["Symbol", "prototype"],
  "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
  "%TypedArrayPrototype%": ["TypedArray", "prototype"],
  "%TypeErrorPrototype%": ["TypeError", "prototype"],
  "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
  "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
  "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
  "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
  "%URIErrorPrototype%": ["URIError", "prototype"],
  "%WeakMapPrototype%": ["WeakMap", "prototype"],
  "%WeakSetPrototype%": ["WeakSet", "prototype"]
}, bind$1 = functionBind, hasOwn$1 = requireHasown(), $concat = bind$1.call($call, Array.prototype.concat), $spliceApply = bind$1.call($apply$1, Array.prototype.splice), $replace = bind$1.call($call, String.prototype.replace), $strSlice = bind$1.call($call, String.prototype.slice), $exec$2 = bind$1.call($call, RegExp.prototype.exec), rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, reEscapeChar = /\\(\\)?/g, stringToPath = function(M) {
  var x = $strSlice(M, 0, 1), $ = $strSlice(M, -1);
  if (x === "%" && $ !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected closing `%`");
  if ($ === "%" && x !== "%")
    throw new $SyntaxError$1("invalid intrinsic syntax, expected opening `%`");
  var T = [];
  return $replace(M, rePropName, function(S, D, F, z) {
    T[T.length] = F ? $replace(z, reEscapeChar, "$1") : D || S;
  }), T;
}, getBaseIntrinsic = function(M, x) {
  var $ = M, T;
  if (hasOwn$1(LEGACY_ALIASES, $) && (T = LEGACY_ALIASES[$], $ = "%" + T[0] + "%"), hasOwn$1(INTRINSICS, $)) {
    var S = INTRINSICS[$];
    if (S === needsEval && (S = doEval($)), typeof S > "u" && !x)
      throw new $TypeError$4("intrinsic " + M + " exists, but is not available. Please file an issue!");
    return {
      alias: T,
      name: $,
      value: S
    };
  }
  throw new $SyntaxError$1("intrinsic " + M + " does not exist!");
}, getIntrinsic = function(M, x) {
  if (typeof M != "string" || M.length === 0)
    throw new $TypeError$4("intrinsic name must be a non-empty string");
  if (arguments.length > 1 && typeof x != "boolean")
    throw new $TypeError$4('"allowMissing" argument must be a boolean');
  if ($exec$2(/^%?[^%]*%?$/, M) === null)
    throw new $SyntaxError$1("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
  var $ = stringToPath(M), T = $.length > 0 ? $[0] : "", S = getBaseIntrinsic("%" + T + "%", x), D = S.name, F = S.value, z = !1, Z = S.alias;
  Z && (T = Z[0], $spliceApply($, $concat([0, 1], Z)));
  for (var H = 1, V = !0; H < $.length; H += 1) {
    var X = $[H], Q = $strSlice(X, 0, 1), fe = $strSlice(X, -1);
    if ((Q === '"' || Q === "'" || Q === "`" || fe === '"' || fe === "'" || fe === "`") && Q !== fe)
      throw new $SyntaxError$1("property names with quotes must have matching quotes");
    if ((X === "constructor" || !V) && (z = !0), T += "." + X, D = "%" + T + "%", hasOwn$1(INTRINSICS, D))
      F = INTRINSICS[D];
    else if (F != null) {
      if (!(X in F)) {
        if (!x)
          throw new $TypeError$4("base intrinsic for " + M + " exists, but the property is not available.");
        return;
      }
      if ($gOPD && H + 1 >= $.length) {
        var ce = $gOPD(F, X);
        V = !!ce, V && "get" in ce && !("originalValue" in ce.get) ? F = ce.get : F = F[X];
      } else
        V = hasOwn$1(F, X), F = F[X];
      V && !z && (INTRINSICS[D] = F);
    }
  }
  return F;
}, GetIntrinsic$2 = getIntrinsic, callBindBasic = callBindApplyHelpers, $indexOf$2 = callBindBasic([GetIntrinsic$2("%String.prototype.indexOf%")]), callBound$8 = function(M, x) {
  var $ = (
    /** @type {(this: unknown, ...args: unknown[]) => unknown} */
    GetIntrinsic$2(M, !!x)
  );
  return typeof $ == "function" && $indexOf$2(M, ".prototype.") > -1 ? callBindBasic(
    /** @type {const} */
    [$]
  ) : $;
}, hasToStringTag$4 = shams(), callBound$7 = callBound$8, $toString$2 = callBound$7("Object.prototype.toString"), isStandardArguments = function(M) {
  return hasToStringTag$4 && M && typeof M == "object" && Symbol.toStringTag in M ? !1 : $toString$2(M) === "[object Arguments]";
}, isLegacyArguments = function(M) {
  return isStandardArguments(M) ? !0 : M !== null && typeof M == "object" && "length" in M && typeof M.length == "number" && M.length >= 0 && $toString$2(M) !== "[object Array]" && "callee" in M && $toString$2(M.callee) === "[object Function]";
}, supportsStandardArguments = function() {
  return isStandardArguments(arguments);
}();
isStandardArguments.isLegacyArguments = isLegacyArguments;
var isArguments$2 = supportsStandardArguments ? isStandardArguments : isLegacyArguments, callBound$6 = callBound$8, hasToStringTag$3 = shams(), hasOwn = requireHasown(), gOPD$2 = gopd$1, fn;
if (hasToStringTag$3) {
  var $exec$1 = callBound$6("RegExp.prototype.exec"), isRegexMarker = {}, throwRegexMarker = function() {
    throw isRegexMarker;
  }, badStringifier = {
    toString: throwRegexMarker,
    valueOf: throwRegexMarker
  };
  typeof Symbol.toPrimitive == "symbol" && (badStringifier[Symbol.toPrimitive] = throwRegexMarker), fn = function(M) {
    if (!M || typeof M != "object")
      return !1;
    var x = (
      /** @type {NonNullable<typeof gOPD>} */
      gOPD$2(
        /** @type {{ lastIndex?: unknown }} */
        M,
        "lastIndex"
      )
    ), $ = x && hasOwn(x, "value");
    if (!$)
      return !1;
    try {
      $exec$1(
        M,
        /** @type {string} */
        /** @type {unknown} */
        badStringifier
      );
    } catch (T) {
      return T === isRegexMarker;
    }
  };
} else {
  var $toString$1 = callBound$6("Object.prototype.toString"), regexClass = "[object RegExp]";
  fn = function(M) {
    return !M || typeof M != "object" && typeof M != "function" ? !1 : $toString$1(M) === regexClass;
  };
}
var isRegex$1 = fn, callBound$5 = callBound$8, isRegex = isRegex$1, $exec = callBound$5("RegExp.prototype.exec"), $TypeError$3 = type, safeRegexTest$1 = function(M) {
  if (!isRegex(M))
    throw new $TypeError$3("`regex` must be a RegExp");
  return function($) {
    return $exec(M, $) !== null;
  };
}, callBound$4 = callBound$8, safeRegexTest = safeRegexTest$1, isFnRegex = safeRegexTest(/^\s*(?:function)?\*/), hasToStringTag$2 = shams(), getProto$1 = requireGetProto(), toStr$3 = callBound$4("Object.prototype.toString"), fnToStr$1 = callBound$4("Function.prototype.toString"), getGeneratorFunc = function() {
  if (!hasToStringTag$2)
    return !1;
  try {
    return Function("return function*() {}")();
  } catch {
  }
}, GeneratorFunction, isGeneratorFunction = function(M) {
  if (typeof M != "function")
    return !1;
  if (isFnRegex(fnToStr$1(M)))
    return !0;
  if (!hasToStringTag$2) {
    var x = toStr$3(M);
    return x === "[object GeneratorFunction]";
  }
  if (!getProto$1)
    return !1;
  if (typeof GeneratorFunction > "u") {
    var $ = getGeneratorFunc();
    GeneratorFunction = $ ? (
      /** @type {GeneratorFunctionConstructor} */
      getProto$1($)
    ) : !1;
  }
  return getProto$1(M) === GeneratorFunction;
}, fnToStr = Function.prototype.toString, reflectApply = typeof Reflect == "object" && Reflect !== null && Reflect.apply, badArrayLike, isCallableMarker;
if (typeof reflectApply == "function" && typeof Object.defineProperty == "function")
  try {
    badArrayLike = Object.defineProperty({}, "length", {
      get: function() {
        throw isCallableMarker;
      }
    }), isCallableMarker = {}, reflectApply(function() {
      throw 42;
    }, null, badArrayLike);
  } catch (w) {
    w !== isCallableMarker && (reflectApply = null);
  }
else
  reflectApply = null;
var constructorRegex = /^\s*class\b/, isES6ClassFn = function(M) {
  try {
    var x = fnToStr.call(M);
    return constructorRegex.test(x);
  } catch {
    return !1;
  }
}, tryFunctionObject = function(M) {
  try {
    return isES6ClassFn(M) ? !1 : (fnToStr.call(M), !0);
  } catch {
    return !1;
  }
}, toStr$2 = Object.prototype.toString, objectClass = "[object Object]", fnClass = "[object Function]", genClass = "[object GeneratorFunction]", ddaClass = "[object HTMLAllCollection]", ddaClass2 = "[object HTML document.all class]", ddaClass3 = "[object HTMLCollection]", hasToStringTag$1 = typeof Symbol == "function" && !!Symbol.toStringTag, isIE68 = !(0 in [,]), isDDA = function() {
  return !1;
};
if (typeof document == "object") {
  var all = document.all;
  toStr$2.call(all) === toStr$2.call(document.all) && (isDDA = function(M) {
    if ((isIE68 || !M) && (typeof M > "u" || typeof M == "object"))
      try {
        var x = toStr$2.call(M);
        return (x === ddaClass || x === ddaClass2 || x === ddaClass3 || x === objectClass) && M("") == null;
      } catch {
      }
    return !1;
  });
}
var isCallable$1 = reflectApply ? function(M) {
  if (isDDA(M))
    return !0;
  if (!M || typeof M != "function" && typeof M != "object")
    return !1;
  try {
    reflectApply(M, null, badArrayLike);
  } catch (x) {
    if (x !== isCallableMarker)
      return !1;
  }
  return !isES6ClassFn(M) && tryFunctionObject(M);
} : function(M) {
  if (isDDA(M))
    return !0;
  if (!M || typeof M != "function" && typeof M != "object")
    return !1;
  if (hasToStringTag$1)
    return tryFunctionObject(M);
  if (isES6ClassFn(M))
    return !1;
  var x = toStr$2.call(M);
  return x !== fnClass && x !== genClass && !/^\[object HTML/.test(x) ? !1 : tryFunctionObject(M);
}, isCallable = isCallable$1, toStr$1 = Object.prototype.toString, hasOwnProperty = Object.prototype.hasOwnProperty, forEachArray = function(M, x, $) {
  for (var T = 0, S = M.length; T < S; T++)
    hasOwnProperty.call(M, T) && ($ == null ? x(M[T], T, M) : x.call($, M[T], T, M));
}, forEachString = function(M, x, $) {
  for (var T = 0, S = M.length; T < S; T++)
    $ == null ? x(M.charAt(T), T, M) : x.call($, M.charAt(T), T, M);
}, forEachObject = function(M, x, $) {
  for (var T in M)
    hasOwnProperty.call(M, T) && ($ == null ? x(M[T], T, M) : x.call($, M[T], T, M));
};
function isArray$2(w) {
  return toStr$1.call(w) === "[object Array]";
}
var forEach$1 = function(M, x, $) {
  if (!isCallable(x))
    throw new TypeError("iterator must be a function");
  var T;
  arguments.length >= 3 && (T = $), isArray$2(M) ? forEachArray(M, x, T) : typeof M == "string" ? forEachString(M, x, T) : forEachObject(M, x, T);
}, possibleTypedArrayNames = [
  "Float16Array",
  "Float32Array",
  "Float64Array",
  "Int8Array",
  "Int16Array",
  "Int32Array",
  "Uint8Array",
  "Uint8ClampedArray",
  "Uint16Array",
  "Uint32Array",
  "BigInt64Array",
  "BigUint64Array"
], possibleNames = possibleTypedArrayNames, g$2 = typeof globalThis > "u" ? commonjsGlobal : globalThis, availableTypedArrays$1 = function() {
  for (var M = [], x = 0; x < possibleNames.length; x++)
    typeof g$2[possibleNames[x]] == "function" && (M[M.length] = possibleNames[x]);
  return M;
}, callBind$2 = { exports: {} }, $defineProperty$1 = esDefineProperty, $SyntaxError = syntax, $TypeError$2 = type, gopd = gopd$1, defineDataProperty = function(M, x, $) {
  if (!M || typeof M != "object" && typeof M != "function")
    throw new $TypeError$2("`obj` must be an object or a function`");
  if (typeof x != "string" && typeof x != "symbol")
    throw new $TypeError$2("`property` must be a string or a symbol`");
  if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
    throw new $TypeError$2("`nonEnumerable`, if provided, must be a boolean or null");
  if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
    throw new $TypeError$2("`nonWritable`, if provided, must be a boolean or null");
  if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
    throw new $TypeError$2("`nonConfigurable`, if provided, must be a boolean or null");
  if (arguments.length > 6 && typeof arguments[6] != "boolean")
    throw new $TypeError$2("`loose`, if provided, must be a boolean");
  var T = arguments.length > 3 ? arguments[3] : null, S = arguments.length > 4 ? arguments[4] : null, D = arguments.length > 5 ? arguments[5] : null, F = arguments.length > 6 ? arguments[6] : !1, z = !!gopd && gopd(M, x);
  if ($defineProperty$1)
    $defineProperty$1(M, x, {
      configurable: D === null && z ? z.configurable : !D,
      enumerable: T === null && z ? z.enumerable : !T,
      value: $,
      writable: S === null && z ? z.writable : !S
    });
  else if (F || !T && !S && !D)
    M[x] = $;
  else
    throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
}, $defineProperty = esDefineProperty, hasPropertyDescriptors = function() {
  return !!$defineProperty;
};
hasPropertyDescriptors.hasArrayLengthDefineBug = function() {
  if (!$defineProperty)
    return null;
  try {
    return $defineProperty([], "length", { value: 1 }).length !== 1;
  } catch {
    return !0;
  }
};
var hasPropertyDescriptors_1 = hasPropertyDescriptors, GetIntrinsic$1 = getIntrinsic, define = defineDataProperty, hasDescriptors = hasPropertyDescriptors_1(), gOPD$1 = gopd$1, $TypeError$1 = type, $floor = GetIntrinsic$1("%Math.floor%"), setFunctionLength = function(M, x) {
  if (typeof M != "function")
    throw new $TypeError$1("`fn` is not a function");
  if (typeof x != "number" || x < 0 || x > 4294967295 || $floor(x) !== x)
    throw new $TypeError$1("`length` must be a positive 32-bit integer");
  var $ = arguments.length > 2 && !!arguments[2], T = !0, S = !0;
  if ("length" in M && gOPD$1) {
    var D = gOPD$1(M, "length");
    D && !D.configurable && (T = !1), D && !D.writable && (S = !1);
  }
  return (T || S || !$) && (hasDescriptors ? define(
    /** @type {Parameters<define>[0]} */
    M,
    "length",
    x,
    !0,
    !0
  ) : define(
    /** @type {Parameters<define>[0]} */
    M,
    "length",
    x
  )), M;
}, bind = functionBind, $apply = requireFunctionApply(), actualApply = actualApply$1, applyBind = function() {
  return actualApply(bind, $apply, arguments);
};
(function(w) {
  var M = setFunctionLength, x = esDefineProperty, $ = callBindApplyHelpers, T = applyBind;
  w.exports = function(D) {
    var F = $(arguments), z = D.length - (arguments.length - 1);
    return M(
      F,
      1 + (z > 0 ? z : 0),
      !0
    );
  }, x ? x(w.exports, "apply", { value: T }) : w.exports.apply = T;
})(callBind$2);
var callBindExports = callBind$2.exports, forEach = forEach$1, availableTypedArrays = availableTypedArrays$1, callBind$1 = callBindExports, callBound$3 = callBound$8, gOPD = gopd$1, getProto = requireGetProto(), $toString = callBound$3("Object.prototype.toString"), hasToStringTag = shams(), g$1 = typeof globalThis > "u" ? commonjsGlobal : globalThis, typedArrays = availableTypedArrays(), $slice = callBound$3("String.prototype.slice"), $indexOf$1 = callBound$3("Array.prototype.indexOf", !0) || function(M, x) {
  for (var $ = 0; $ < M.length; $ += 1)
    if (M[$] === x)
      return $;
  return -1;
}, cache$1 = { __proto__: null };
hasToStringTag && gOPD && getProto ? forEach(typedArrays, function(w) {
  var M = new g$1[w]();
  if (Symbol.toStringTag in M && getProto) {
    var x = getProto(M), $ = gOPD(x, Symbol.toStringTag);
    if (!$ && x) {
      var T = getProto(x);
      $ = gOPD(T, Symbol.toStringTag);
    }
    cache$1["$" + w] = callBind$1($.get);
  }
}) : forEach(typedArrays, function(w) {
  var M = new g$1[w](), x = M.slice || M.set;
  x && (cache$1[
    /** @type {`$${import('.').TypedArrayName}`} */
    "$" + w
  ] = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
  // @ts-expect-error TODO FIXME
  callBind$1(x));
});
var tryTypedArrays = function(M) {
  var x = !1;
  return forEach(
    /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
    cache$1,
    /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
    function($, T) {
      if (!x)
        try {
          "$" + $(M) === T && (x = /** @type {import('.').TypedArrayName} */
          $slice(T, 1));
        } catch {
        }
    }
  ), x;
}, trySlices = function(M) {
  var x = !1;
  return forEach(
    /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
    cache$1,
    /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
    function($, T) {
      if (!x)
        try {
          $(M), x = /** @type {import('.').TypedArrayName} */
          $slice(T, 1);
        } catch {
        }
    }
  ), x;
}, whichTypedArray$1 = function(M) {
  if (!M || typeof M != "object")
    return !1;
  if (!hasToStringTag) {
    var x = $slice($toString(M), 8, -1);
    return $indexOf$1(typedArrays, x) > -1 ? x : x !== "Object" ? !1 : trySlices(M);
  }
  return gOPD ? tryTypedArrays(M) : null;
}, whichTypedArray = whichTypedArray$1, isTypedArray$1 = function(M) {
  return !!whichTypedArray(M);
};
(function(w) {
  var M = isArguments$2, x = isGeneratorFunction, $ = whichTypedArray$1, T = isTypedArray$1;
  function S(Se) {
    return Se.call.bind(Se);
  }
  var D = typeof BigInt < "u", F = typeof Symbol < "u", z = S(Object.prototype.toString), Z = S(Number.prototype.valueOf), H = S(String.prototype.valueOf), V = S(Boolean.prototype.valueOf);
  if (D)
    var X = S(BigInt.prototype.valueOf);
  if (F)
    var Q = S(Symbol.prototype.valueOf);
  function fe(Se, lt) {
    if (typeof Se != "object")
      return !1;
    try {
      return lt(Se), !0;
    } catch {
      return !1;
    }
  }
  w.isArgumentsObject = M, w.isGeneratorFunction = x, w.isTypedArray = T;
  function ce(Se) {
    return typeof Promise < "u" && Se instanceof Promise || Se !== null && typeof Se == "object" && typeof Se.then == "function" && typeof Se.catch == "function";
  }
  w.isPromise = ce;
  function me(Se) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(Se) : T(Se) || Y(Se);
  }
  w.isArrayBufferView = me;
  function de(Se) {
    return $(Se) === "Uint8Array";
  }
  w.isUint8Array = de;
  function ne(Se) {
    return $(Se) === "Uint8ClampedArray";
  }
  w.isUint8ClampedArray = ne;
  function ge(Se) {
    return $(Se) === "Uint16Array";
  }
  w.isUint16Array = ge;
  function pe(Se) {
    return $(Se) === "Uint32Array";
  }
  w.isUint32Array = pe;
  function $e(Se) {
    return $(Se) === "Int8Array";
  }
  w.isInt8Array = $e;
  function Re(Se) {
    return $(Se) === "Int16Array";
  }
  w.isInt16Array = Re;
  function Pe(Se) {
    return $(Se) === "Int32Array";
  }
  w.isInt32Array = Pe;
  function Oe(Se) {
    return $(Se) === "Float32Array";
  }
  w.isFloat32Array = Oe;
  function xe(Se) {
    return $(Se) === "Float64Array";
  }
  w.isFloat64Array = xe;
  function rt(Se) {
    return $(Se) === "BigInt64Array";
  }
  w.isBigInt64Array = rt;
  function N(Se) {
    return $(Se) === "BigUint64Array";
  }
  w.isBigUint64Array = N;
  function y(Se) {
    return z(Se) === "[object Map]";
  }
  y.working = typeof Map < "u" && y(/* @__PURE__ */ new Map());
  function E(Se) {
    return typeof Map > "u" ? !1 : y.working ? y(Se) : Se instanceof Map;
  }
  w.isMap = E;
  function A(Se) {
    return z(Se) === "[object Set]";
  }
  A.working = typeof Set < "u" && A(/* @__PURE__ */ new Set());
  function B(Se) {
    return typeof Set > "u" ? !1 : A.working ? A(Se) : Se instanceof Set;
  }
  w.isSet = B;
  function O(Se) {
    return z(Se) === "[object WeakMap]";
  }
  O.working = typeof WeakMap < "u" && O(/* @__PURE__ */ new WeakMap());
  function C(Se) {
    return typeof WeakMap > "u" ? !1 : O.working ? O(Se) : Se instanceof WeakMap;
  }
  w.isWeakMap = C;
  function L(Se) {
    return z(Se) === "[object WeakSet]";
  }
  L.working = typeof WeakSet < "u" && L(/* @__PURE__ */ new WeakSet());
  function P(Se) {
    return L(Se);
  }
  w.isWeakSet = P;
  function _(Se) {
    return z(Se) === "[object ArrayBuffer]";
  }
  _.working = typeof ArrayBuffer < "u" && _(new ArrayBuffer());
  function I(Se) {
    return typeof ArrayBuffer > "u" ? !1 : _.working ? _(Se) : Se instanceof ArrayBuffer;
  }
  w.isArrayBuffer = I;
  function U(Se) {
    return z(Se) === "[object DataView]";
  }
  U.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && U(new DataView(new ArrayBuffer(1), 0, 1));
  function Y(Se) {
    return typeof DataView > "u" ? !1 : U.working ? U(Se) : Se instanceof DataView;
  }
  w.isDataView = Y;
  var te = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function oe(Se) {
    return z(Se) === "[object SharedArrayBuffer]";
  }
  function re(Se) {
    return typeof te > "u" ? !1 : (typeof oe.working > "u" && (oe.working = oe(new te())), oe.working ? oe(Se) : Se instanceof te);
  }
  w.isSharedArrayBuffer = re;
  function ee(Se) {
    return z(Se) === "[object AsyncFunction]";
  }
  w.isAsyncFunction = ee;
  function ae(Se) {
    return z(Se) === "[object Map Iterator]";
  }
  w.isMapIterator = ae;
  function ue(Se) {
    return z(Se) === "[object Set Iterator]";
  }
  w.isSetIterator = ue;
  function ye(Se) {
    return z(Se) === "[object Generator]";
  }
  w.isGeneratorObject = ye;
  function ve(Se) {
    return z(Se) === "[object WebAssembly.Module]";
  }
  w.isWebAssemblyCompiledModule = ve;
  function he(Se) {
    return fe(Se, Z);
  }
  w.isNumberObject = he;
  function Me(Se) {
    return fe(Se, H);
  }
  w.isStringObject = Me;
  function Qe(Se) {
    return fe(Se, V);
  }
  w.isBooleanObject = Qe;
  function Ie(Se) {
    return D && fe(Se, X);
  }
  w.isBigIntObject = Ie;
  function De(Se) {
    return F && fe(Se, Q);
  }
  w.isSymbolObject = De;
  function at(Se) {
    return he(Se) || Me(Se) || Qe(Se) || Ie(Se) || De(Se);
  }
  w.isBoxedPrimitive = at;
  function ke(Se) {
    return typeof Uint8Array < "u" && (I(Se) || re(Se));
  }
  w.isAnyArrayBuffer = ke, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(Se) {
    Object.defineProperty(w, Se, {
      enumerable: !1,
      value: function() {
        throw new Error(Se + " is not supported in userland");
      }
    });
  });
})(types);
var isBufferBrowser = function(M) {
  return M && typeof M == "object" && typeof M.copy == "function" && typeof M.fill == "function" && typeof M.readUInt8 == "function";
}, inherits_browser = { exports: {} };
typeof Object.create == "function" ? inherits_browser.exports = function(M, x) {
  x && (M.super_ = x, M.prototype = Object.create(x.prototype, {
    constructor: {
      value: M,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : inherits_browser.exports = function(M, x) {
  if (x) {
    M.super_ = x;
    var $ = function() {
    };
    $.prototype = x.prototype, M.prototype = new $(), M.prototype.constructor = M;
  }
};
var inherits_browserExports = inherits_browser.exports;
(function(w) {
  var M = Object.getOwnPropertyDescriptors || function(Y) {
    for (var te = Object.keys(Y), oe = {}, re = 0; re < te.length; re++)
      oe[te[re]] = Object.getOwnPropertyDescriptor(Y, te[re]);
    return oe;
  }, x = /%[sdj%]/g;
  w.format = function(U) {
    if (!$e(U)) {
      for (var Y = [], te = 0; te < arguments.length; te++)
        Y.push(D(arguments[te]));
      return Y.join(" ");
    }
    for (var te = 1, oe = arguments, re = oe.length, ee = String(U).replace(x, function(ue) {
      if (ue === "%%") return "%";
      if (te >= re) return ue;
      switch (ue) {
        case "%s":
          return String(oe[te++]);
        case "%d":
          return Number(oe[te++]);
        case "%j":
          try {
            return JSON.stringify(oe[te++]);
          } catch {
            return "[Circular]";
          }
        default:
          return ue;
      }
    }), ae = oe[te]; te < re; ae = oe[++te])
      ne(ae) || !xe(ae) ? ee += " " + ae : ee += " " + D(ae);
    return ee;
  }, w.deprecate = function(U, Y) {
    if (typeof process$1 < "u" && process$1.noDeprecation === !0)
      return U;
    if (typeof process$1 > "u")
      return function() {
        return w.deprecate(U, Y).apply(this, arguments);
      };
    var te = !1;
    function oe() {
      if (!te) {
        if (process$1.throwDeprecation)
          throw new Error(Y);
        process$1.traceDeprecation ? console.trace(Y) : console.error(Y), te = !0;
      }
      return U.apply(this, arguments);
    }
    return oe;
  };
  var $ = {}, T = /^$/;
  if (process$1.env.NODE_DEBUG) {
    var S = process$1.env.NODE_DEBUG;
    S = S.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), T = new RegExp("^" + S + "$", "i");
  }
  w.debuglog = function(U) {
    if (U = U.toUpperCase(), !$[U])
      if (T.test(U)) {
        var Y = process$1.pid;
        $[U] = function() {
          var te = w.format.apply(w, arguments);
          console.error("%s %d: %s", U, Y, te);
        };
      } else
        $[U] = function() {
        };
    return $[U];
  };
  function D(U, Y) {
    var te = {
      seen: [],
      stylize: z
    };
    return arguments.length >= 3 && (te.depth = arguments[2]), arguments.length >= 4 && (te.colors = arguments[3]), de(Y) ? te.showHidden = Y : Y && w._extend(te, Y), Pe(te.showHidden) && (te.showHidden = !1), Pe(te.depth) && (te.depth = 2), Pe(te.colors) && (te.colors = !1), Pe(te.customInspect) && (te.customInspect = !0), te.colors && (te.stylize = F), H(te, U, te.depth);
  }
  w.inspect = D, D.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, D.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function F(U, Y) {
    var te = D.styles[Y];
    return te ? "\x1B[" + D.colors[te][0] + "m" + U + "\x1B[" + D.colors[te][1] + "m" : U;
  }
  function z(U, Y) {
    return U;
  }
  function Z(U) {
    var Y = {};
    return U.forEach(function(te, oe) {
      Y[te] = !0;
    }), Y;
  }
  function H(U, Y, te) {
    if (U.customInspect && Y && y(Y.inspect) && // Filter out the util module, it's inspect function is special
    Y.inspect !== w.inspect && // Also filter out any prototype objects using the circular check.
    !(Y.constructor && Y.constructor.prototype === Y)) {
      var oe = Y.inspect(te, U);
      return $e(oe) || (oe = H(U, oe, te)), oe;
    }
    var re = V(U, Y);
    if (re)
      return re;
    var ee = Object.keys(Y), ae = Z(ee);
    if (U.showHidden && (ee = Object.getOwnPropertyNames(Y)), N(Y) && (ee.indexOf("message") >= 0 || ee.indexOf("description") >= 0))
      return X(Y);
    if (ee.length === 0) {
      if (y(Y)) {
        var ue = Y.name ? ": " + Y.name : "";
        return U.stylize("[Function" + ue + "]", "special");
      }
      if (Oe(Y))
        return U.stylize(RegExp.prototype.toString.call(Y), "regexp");
      if (rt(Y))
        return U.stylize(Date.prototype.toString.call(Y), "date");
      if (N(Y))
        return X(Y);
    }
    var ye = "", ve = !1, he = ["{", "}"];
    if (me(Y) && (ve = !0, he = ["[", "]"]), y(Y)) {
      var Me = Y.name ? ": " + Y.name : "";
      ye = " [Function" + Me + "]";
    }
    if (Oe(Y) && (ye = " " + RegExp.prototype.toString.call(Y)), rt(Y) && (ye = " " + Date.prototype.toUTCString.call(Y)), N(Y) && (ye = " " + X(Y)), ee.length === 0 && (!ve || Y.length == 0))
      return he[0] + ye + he[1];
    if (te < 0)
      return Oe(Y) ? U.stylize(RegExp.prototype.toString.call(Y), "regexp") : U.stylize("[Object]", "special");
    U.seen.push(Y);
    var Qe;
    return ve ? Qe = Q(U, Y, te, ae, ee) : Qe = ee.map(function(Ie) {
      return fe(U, Y, te, ae, Ie, ve);
    }), U.seen.pop(), ce(Qe, ye, he);
  }
  function V(U, Y) {
    if (Pe(Y))
      return U.stylize("undefined", "undefined");
    if ($e(Y)) {
      var te = "'" + JSON.stringify(Y).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return U.stylize(te, "string");
    }
    if (pe(Y))
      return U.stylize("" + Y, "number");
    if (de(Y))
      return U.stylize("" + Y, "boolean");
    if (ne(Y))
      return U.stylize("null", "null");
  }
  function X(U) {
    return "[" + Error.prototype.toString.call(U) + "]";
  }
  function Q(U, Y, te, oe, re) {
    for (var ee = [], ae = 0, ue = Y.length; ae < ue; ++ae)
      L(Y, String(ae)) ? ee.push(fe(
        U,
        Y,
        te,
        oe,
        String(ae),
        !0
      )) : ee.push("");
    return re.forEach(function(ye) {
      ye.match(/^\d+$/) || ee.push(fe(
        U,
        Y,
        te,
        oe,
        ye,
        !0
      ));
    }), ee;
  }
  function fe(U, Y, te, oe, re, ee) {
    var ae, ue, ye;
    if (ye = Object.getOwnPropertyDescriptor(Y, re) || { value: Y[re] }, ye.get ? ye.set ? ue = U.stylize("[Getter/Setter]", "special") : ue = U.stylize("[Getter]", "special") : ye.set && (ue = U.stylize("[Setter]", "special")), L(oe, re) || (ae = "[" + re + "]"), ue || (U.seen.indexOf(ye.value) < 0 ? (ne(te) ? ue = H(U, ye.value, null) : ue = H(U, ye.value, te - 1), ue.indexOf(`
`) > -1 && (ee ? ue = ue.split(`
`).map(function(ve) {
      return "  " + ve;
    }).join(`
`).slice(2) : ue = `
` + ue.split(`
`).map(function(ve) {
      return "   " + ve;
    }).join(`
`))) : ue = U.stylize("[Circular]", "special")), Pe(ae)) {
      if (ee && re.match(/^\d+$/))
        return ue;
      ae = JSON.stringify("" + re), ae.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (ae = ae.slice(1, -1), ae = U.stylize(ae, "name")) : (ae = ae.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), ae = U.stylize(ae, "string"));
    }
    return ae + ": " + ue;
  }
  function ce(U, Y, te) {
    var oe = U.reduce(function(re, ee) {
      return ee.indexOf(`
`) >= 0, re + ee.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return oe > 60 ? te[0] + (Y === "" ? "" : Y + `
 `) + " " + U.join(`,
  `) + " " + te[1] : te[0] + Y + " " + U.join(", ") + " " + te[1];
  }
  w.types = types;
  function me(U) {
    return Array.isArray(U);
  }
  w.isArray = me;
  function de(U) {
    return typeof U == "boolean";
  }
  w.isBoolean = de;
  function ne(U) {
    return U === null;
  }
  w.isNull = ne;
  function ge(U) {
    return U == null;
  }
  w.isNullOrUndefined = ge;
  function pe(U) {
    return typeof U == "number";
  }
  w.isNumber = pe;
  function $e(U) {
    return typeof U == "string";
  }
  w.isString = $e;
  function Re(U) {
    return typeof U == "symbol";
  }
  w.isSymbol = Re;
  function Pe(U) {
    return U === void 0;
  }
  w.isUndefined = Pe;
  function Oe(U) {
    return xe(U) && A(U) === "[object RegExp]";
  }
  w.isRegExp = Oe, w.types.isRegExp = Oe;
  function xe(U) {
    return typeof U == "object" && U !== null;
  }
  w.isObject = xe;
  function rt(U) {
    return xe(U) && A(U) === "[object Date]";
  }
  w.isDate = rt, w.types.isDate = rt;
  function N(U) {
    return xe(U) && (A(U) === "[object Error]" || U instanceof Error);
  }
  w.isError = N, w.types.isNativeError = N;
  function y(U) {
    return typeof U == "function";
  }
  w.isFunction = y;
  function E(U) {
    return U === null || typeof U == "boolean" || typeof U == "number" || typeof U == "string" || typeof U == "symbol" || // ES6 symbol
    typeof U > "u";
  }
  w.isPrimitive = E, w.isBuffer = isBufferBrowser;
  function A(U) {
    return Object.prototype.toString.call(U);
  }
  function B(U) {
    return U < 10 ? "0" + U.toString(10) : U.toString(10);
  }
  var O = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function C() {
    var U = /* @__PURE__ */ new Date(), Y = [
      B(U.getHours()),
      B(U.getMinutes()),
      B(U.getSeconds())
    ].join(":");
    return [U.getDate(), O[U.getMonth()], Y].join(" ");
  }
  w.log = function() {
    console.log("%s - %s", C(), w.format.apply(w, arguments));
  }, w.inherits = inherits_browserExports, w._extend = function(U, Y) {
    if (!Y || !xe(Y)) return U;
    for (var te = Object.keys(Y), oe = te.length; oe--; )
      U[te[oe]] = Y[te[oe]];
    return U;
  };
  function L(U, Y) {
    return Object.prototype.hasOwnProperty.call(U, Y);
  }
  var P = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  w.promisify = function(Y) {
    if (typeof Y != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (P && Y[P]) {
      var te = Y[P];
      if (typeof te != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(te, P, {
        value: te,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), te;
    }
    function te() {
      for (var oe, re, ee = new Promise(function(ye, ve) {
        oe = ye, re = ve;
      }), ae = [], ue = 0; ue < arguments.length; ue++)
        ae.push(arguments[ue]);
      ae.push(function(ye, ve) {
        ye ? re(ye) : oe(ve);
      });
      try {
        Y.apply(this, ae);
      } catch (ye) {
        re(ye);
      }
      return ee;
    }
    return Object.setPrototypeOf(te, Object.getPrototypeOf(Y)), P && Object.defineProperty(te, P, {
      value: te,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), Object.defineProperties(
      te,
      M(Y)
    );
  }, w.promisify.custom = P;
  function _(U, Y) {
    if (!U) {
      var te = new Error("Promise was rejected with a falsy value");
      te.reason = U, U = te;
    }
    return Y(U);
  }
  function I(U) {
    if (typeof U != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function Y() {
      for (var te = [], oe = 0; oe < arguments.length; oe++)
        te.push(arguments[oe]);
      var re = te.pop();
      if (typeof re != "function")
        throw new TypeError("The last argument must be of type Function");
      var ee = this, ae = function() {
        return re.apply(ee, arguments);
      };
      U.apply(this, te).then(
        function(ue) {
          process$1.nextTick(ae.bind(null, null, ue));
        },
        function(ue) {
          process$1.nextTick(_.bind(null, ue, ae));
        }
      );
    }
    return Object.setPrototypeOf(Y, Object.getPrototypeOf(U)), Object.defineProperties(
      Y,
      M(U)
    ), Y;
  }
  w.callbackify = I;
})(util$3);
var hasRequiredErrors;
function requireErrors() {
  if (hasRequiredErrors) return errors;
  hasRequiredErrors = 1;
  function w(ne) {
    "@babel/helpers - typeof";
    return w = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(ge) {
      return typeof ge;
    } : function(ge) {
      return ge && typeof Symbol == "function" && ge.constructor === Symbol && ge !== Symbol.prototype ? "symbol" : typeof ge;
    }, w(ne);
  }
  function M(ne, ge, pe) {
    return Object.defineProperty(ne, "prototype", { writable: !1 }), ne;
  }
  function x(ne, ge) {
    if (!(ne instanceof ge))
      throw new TypeError("Cannot call a class as a function");
  }
  function $(ne, ge) {
    if (typeof ge != "function" && ge !== null)
      throw new TypeError("Super expression must either be null or a function");
    ne.prototype = Object.create(ge && ge.prototype, { constructor: { value: ne, writable: !0, configurable: !0 } }), Object.defineProperty(ne, "prototype", { writable: !1 }), ge && T(ne, ge);
  }
  function T(ne, ge) {
    return T = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function($e, Re) {
      return $e.__proto__ = Re, $e;
    }, T(ne, ge);
  }
  function S(ne) {
    var ge = z();
    return function() {
      var $e = Z(ne), Re;
      if (ge) {
        var Pe = Z(this).constructor;
        Re = Reflect.construct($e, arguments, Pe);
      } else
        Re = $e.apply(this, arguments);
      return D(this, Re);
    };
  }
  function D(ne, ge) {
    if (ge && (w(ge) === "object" || typeof ge == "function"))
      return ge;
    if (ge !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return F(ne);
  }
  function F(ne) {
    if (ne === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return ne;
  }
  function z() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function Z(ne) {
    return Z = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(pe) {
      return pe.__proto__ || Object.getPrototypeOf(pe);
    }, Z(ne);
  }
  var H = {}, V, X;
  function Q(ne, ge, pe) {
    pe || (pe = Error);
    function $e(Pe, Oe, xe) {
      return typeof ge == "string" ? ge : ge(Pe, Oe, xe);
    }
    var Re = /* @__PURE__ */ function(Pe) {
      $(xe, Pe);
      var Oe = S(xe);
      function xe(rt, N, y) {
        var E;
        return x(this, xe), E = Oe.call(this, $e(rt, N, y)), E.code = ne, E;
      }
      return M(xe);
    }(pe);
    H[ne] = Re;
  }
  function fe(ne, ge) {
    if (Array.isArray(ne)) {
      var pe = ne.length;
      return ne = ne.map(function($e) {
        return String($e);
      }), pe > 2 ? "one of ".concat(ge, " ").concat(ne.slice(0, pe - 1).join(", "), ", or ") + ne[pe - 1] : pe === 2 ? "one of ".concat(ge, " ").concat(ne[0], " or ").concat(ne[1]) : "of ".concat(ge, " ").concat(ne[0]);
    } else
      return "of ".concat(ge, " ").concat(String(ne));
  }
  function ce(ne, ge, pe) {
    return ne.substr(0, ge.length) === ge;
  }
  function me(ne, ge, pe) {
    return (pe === void 0 || pe > ne.length) && (pe = ne.length), ne.substring(pe - ge.length, pe) === ge;
  }
  function de(ne, ge, pe) {
    return typeof pe != "number" && (pe = 0), pe + ge.length > ne.length ? !1 : ne.indexOf(ge, pe) !== -1;
  }
  return Q("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), Q("ERR_INVALID_ARG_TYPE", function(ne, ge, pe) {
    V === void 0 && (V = requireAssert()), V(typeof ne == "string", "'name' must be a string");
    var $e;
    typeof ge == "string" && ce(ge, "not ") ? ($e = "must not be", ge = ge.replace(/^not /, "")) : $e = "must be";
    var Re;
    if (me(ne, " argument"))
      Re = "The ".concat(ne, " ").concat($e, " ").concat(fe(ge, "type"));
    else {
      var Pe = de(ne, ".") ? "property" : "argument";
      Re = 'The "'.concat(ne, '" ').concat(Pe, " ").concat($e, " ").concat(fe(ge, "type"));
    }
    return Re += ". Received type ".concat(w(pe)), Re;
  }, TypeError), Q("ERR_INVALID_ARG_VALUE", function(ne, ge) {
    var pe = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
    X === void 0 && (X = util$3);
    var $e = X.inspect(ge);
    return $e.length > 128 && ($e = "".concat($e.slice(0, 128), "...")), "The argument '".concat(ne, "' ").concat(pe, ". Received ").concat($e);
  }, TypeError), Q("ERR_INVALID_RETURN_VALUE", function(ne, ge, pe) {
    var $e;
    return pe && pe.constructor && pe.constructor.name ? $e = "instance of ".concat(pe.constructor.name) : $e = "type ".concat(w(pe)), "Expected ".concat(ne, ' to be returned from the "').concat(ge, '"') + " function but got ".concat($e, ".");
  }, TypeError), Q("ERR_MISSING_ARGS", function() {
    for (var ne = arguments.length, ge = new Array(ne), pe = 0; pe < ne; pe++)
      ge[pe] = arguments[pe];
    V === void 0 && (V = requireAssert()), V(ge.length > 0, "At least one arg needs to be specified");
    var $e = "The ", Re = ge.length;
    switch (ge = ge.map(function(Pe) {
      return '"'.concat(Pe, '"');
    }), Re) {
      case 1:
        $e += "".concat(ge[0], " argument");
        break;
      case 2:
        $e += "".concat(ge[0], " and ").concat(ge[1], " arguments");
        break;
      default:
        $e += ge.slice(0, Re - 1).join(", "), $e += ", and ".concat(ge[Re - 1], " arguments");
        break;
    }
    return "".concat($e, " must be specified");
  }, TypeError), errors.codes = H, errors;
}
var assertion_error, hasRequiredAssertion_error;
function requireAssertion_error() {
  if (hasRequiredAssertion_error) return assertion_error;
  hasRequiredAssertion_error = 1;
  function w(P, _) {
    var I = Object.keys(P);
    if (Object.getOwnPropertySymbols) {
      var U = Object.getOwnPropertySymbols(P);
      _ && (U = U.filter(function(Y) {
        return Object.getOwnPropertyDescriptor(P, Y).enumerable;
      })), I.push.apply(I, U);
    }
    return I;
  }
  function M(P) {
    for (var _ = 1; _ < arguments.length; _++) {
      var I = arguments[_] != null ? arguments[_] : {};
      _ % 2 ? w(Object(I), !0).forEach(function(U) {
        x(P, U, I[U]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(P, Object.getOwnPropertyDescriptors(I)) : w(Object(I)).forEach(function(U) {
        Object.defineProperty(P, U, Object.getOwnPropertyDescriptor(I, U));
      });
    }
    return P;
  }
  function x(P, _, I) {
    return _ = D(_), _ in P ? Object.defineProperty(P, _, { value: I, enumerable: !0, configurable: !0, writable: !0 }) : P[_] = I, P;
  }
  function $(P, _) {
    if (!(P instanceof _))
      throw new TypeError("Cannot call a class as a function");
  }
  function T(P, _) {
    for (var I = 0; I < _.length; I++) {
      var U = _[I];
      U.enumerable = U.enumerable || !1, U.configurable = !0, "value" in U && (U.writable = !0), Object.defineProperty(P, D(U.key), U);
    }
  }
  function S(P, _, I) {
    return _ && T(P.prototype, _), Object.defineProperty(P, "prototype", { writable: !1 }), P;
  }
  function D(P) {
    var _ = F(P, "string");
    return ne(_) === "symbol" ? _ : String(_);
  }
  function F(P, _) {
    if (ne(P) !== "object" || P === null) return P;
    var I = P[Symbol.toPrimitive];
    if (I !== void 0) {
      var U = I.call(P, _);
      if (ne(U) !== "object") return U;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(P);
  }
  function z(P, _) {
    if (typeof _ != "function" && _ !== null)
      throw new TypeError("Super expression must either be null or a function");
    P.prototype = Object.create(_ && _.prototype, { constructor: { value: P, writable: !0, configurable: !0 } }), Object.defineProperty(P, "prototype", { writable: !1 }), _ && me(P, _);
  }
  function Z(P) {
    var _ = fe();
    return function() {
      var U = de(P), Y;
      if (_) {
        var te = de(this).constructor;
        Y = Reflect.construct(U, arguments, te);
      } else
        Y = U.apply(this, arguments);
      return H(this, Y);
    };
  }
  function H(P, _) {
    if (_ && (ne(_) === "object" || typeof _ == "function"))
      return _;
    if (_ !== void 0)
      throw new TypeError("Derived constructors may only return object or undefined");
    return V(P);
  }
  function V(P) {
    if (P === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return P;
  }
  function X(P) {
    var _ = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
    return X = function(U) {
      if (U === null || !ce(U)) return U;
      if (typeof U != "function")
        throw new TypeError("Super expression must either be null or a function");
      if (typeof _ < "u") {
        if (_.has(U)) return _.get(U);
        _.set(U, Y);
      }
      function Y() {
        return Q(U, arguments, de(this).constructor);
      }
      return Y.prototype = Object.create(U.prototype, { constructor: { value: Y, enumerable: !1, writable: !0, configurable: !0 } }), me(Y, U);
    }, X(P);
  }
  function Q(P, _, I) {
    return fe() ? Q = Reflect.construct.bind() : Q = function(Y, te, oe) {
      var re = [null];
      re.push.apply(re, te);
      var ee = Function.bind.apply(Y, re), ae = new ee();
      return oe && me(ae, oe.prototype), ae;
    }, Q.apply(null, arguments);
  }
  function fe() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
    if (typeof Proxy == "function") return !0;
    try {
      return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function ce(P) {
    return Function.toString.call(P).indexOf("[native code]") !== -1;
  }
  function me(P, _) {
    return me = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(U, Y) {
      return U.__proto__ = Y, U;
    }, me(P, _);
  }
  function de(P) {
    return de = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(I) {
      return I.__proto__ || Object.getPrototypeOf(I);
    }, de(P);
  }
  function ne(P) {
    "@babel/helpers - typeof";
    return ne = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(_) {
      return typeof _;
    } : function(_) {
      return _ && typeof Symbol == "function" && _.constructor === Symbol && _ !== Symbol.prototype ? "symbol" : typeof _;
    }, ne(P);
  }
  var ge = util$3, pe = ge.inspect, $e = requireErrors(), Re = $e.codes.ERR_INVALID_ARG_TYPE;
  function Pe(P, _, I) {
    return (I === void 0 || I > P.length) && (I = P.length), P.substring(I - _.length, I) === _;
  }
  function Oe(P, _) {
    if (_ = Math.floor(_), P.length == 0 || _ == 0) return "";
    var I = P.length * _;
    for (_ = Math.floor(Math.log(_) / Math.log(2)); _; )
      P += P, _--;
    return P += P.substring(0, I - P.length), P;
  }
  var xe = "", rt = "", N = "", y = "", E = {
    deepStrictEqual: "Expected values to be strictly deep-equal:",
    strictEqual: "Expected values to be strictly equal:",
    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
    deepEqual: "Expected values to be loosely deep-equal:",
    equal: "Expected values to be loosely equal:",
    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
    notEqual: 'Expected "actual" to be loosely unequal to:',
    notIdentical: "Values identical but not reference-equal:"
  }, A = 10;
  function B(P) {
    var _ = Object.keys(P), I = Object.create(Object.getPrototypeOf(P));
    return _.forEach(function(U) {
      I[U] = P[U];
    }), Object.defineProperty(I, "message", {
      value: P.message
    }), I;
  }
  function O(P) {
    return pe(P, {
      compact: !1,
      customInspect: !1,
      depth: 1e3,
      maxArrayLength: 1 / 0,
      // Assert compares only enumerable properties (with a few exceptions).
      showHidden: !1,
      // Having a long line as error is better than wrapping the line for
      // comparison for now.
      // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
      // have meta information about the inspected properties (i.e., know where
      // in what line the property starts and ends).
      breakLength: 1 / 0,
      // Assert does not detect proxies currently.
      showProxy: !1,
      sorted: !0,
      // Inspect getters as we also check them when comparing entries.
      getters: !0
    });
  }
  function C(P, _, I) {
    var U = "", Y = "", te = 0, oe = "", re = !1, ee = O(P), ae = ee.split(`
`), ue = O(_).split(`
`), ye = 0, ve = "";
    if (I === "strictEqual" && ne(P) === "object" && ne(_) === "object" && P !== null && _ !== null && (I = "strictEqualObject"), ae.length === 1 && ue.length === 1 && ae[0] !== ue[0]) {
      var he = ae[0].length + ue[0].length;
      if (he <= A) {
        if ((ne(P) !== "object" || P === null) && (ne(_) !== "object" || _ === null) && (P !== 0 || _ !== 0))
          return "".concat(E[I], `

`) + "".concat(ae[0], " !== ").concat(ue[0], `
`);
      } else if (I !== "strictEqualObject") {
        var Me = process$1.stderr && process$1.stderr.isTTY ? process$1.stderr.columns : 80;
        if (he < Me) {
          for (; ae[0][ye] === ue[0][ye]; )
            ye++;
          ye > 2 && (ve = `
  `.concat(Oe(" ", ye), "^"), ye = 0);
        }
      }
    }
    for (var Qe = ae[ae.length - 1], Ie = ue[ue.length - 1]; Qe === Ie && (ye++ < 2 ? oe = `
  `.concat(Qe).concat(oe) : U = Qe, ae.pop(), ue.pop(), !(ae.length === 0 || ue.length === 0)); )
      Qe = ae[ae.length - 1], Ie = ue[ue.length - 1];
    var De = Math.max(ae.length, ue.length);
    if (De === 0) {
      var at = ee.split(`
`);
      if (at.length > 30)
        for (at[26] = "".concat(xe, "...").concat(y); at.length > 27; )
          at.pop();
      return "".concat(E.notIdentical, `

`).concat(at.join(`
`), `
`);
    }
    ye > 3 && (oe = `
`.concat(xe, "...").concat(y).concat(oe), re = !0), U !== "" && (oe = `
  `.concat(U).concat(oe), U = "");
    var ke = 0, Se = E[I] + `
`.concat(rt, "+ actual").concat(y, " ").concat(N, "- expected").concat(y), lt = " ".concat(xe, "...").concat(y, " Lines skipped");
    for (ye = 0; ye < De; ye++) {
      var qe = ye - te;
      if (ae.length < ye + 1)
        qe > 1 && ye > 2 && (qe > 4 ? (Y += `
`.concat(xe, "...").concat(y), re = !0) : qe > 3 && (Y += `
  `.concat(ue[ye - 2]), ke++), Y += `
  `.concat(ue[ye - 1]), ke++), te = ye, U += `
`.concat(N, "-").concat(y, " ").concat(ue[ye]), ke++;
      else if (ue.length < ye + 1)
        qe > 1 && ye > 2 && (qe > 4 ? (Y += `
`.concat(xe, "...").concat(y), re = !0) : qe > 3 && (Y += `
  `.concat(ae[ye - 2]), ke++), Y += `
  `.concat(ae[ye - 1]), ke++), te = ye, Y += `
`.concat(rt, "+").concat(y, " ").concat(ae[ye]), ke++;
      else {
        var He = ue[ye], ot = ae[ye], be = ot !== He && (!Pe(ot, ",") || ot.slice(0, -1) !== He);
        be && Pe(He, ",") && He.slice(0, -1) === ot && (be = !1, ot += ","), be ? (qe > 1 && ye > 2 && (qe > 4 ? (Y += `
`.concat(xe, "...").concat(y), re = !0) : qe > 3 && (Y += `
  `.concat(ae[ye - 2]), ke++), Y += `
  `.concat(ae[ye - 1]), ke++), te = ye, Y += `
`.concat(rt, "+").concat(y, " ").concat(ot), U += `
`.concat(N, "-").concat(y, " ").concat(He), ke += 2) : (Y += U, U = "", (qe === 1 || ye === 0) && (Y += `
  `.concat(ot), ke++));
      }
      if (ke > 20 && ye < De - 2)
        return "".concat(Se).concat(lt, `
`).concat(Y, `
`).concat(xe, "...").concat(y).concat(U, `
`) + "".concat(xe, "...").concat(y);
    }
    return "".concat(Se).concat(re ? lt : "", `
`).concat(Y).concat(U).concat(oe).concat(ve);
  }
  var L = /* @__PURE__ */ function(P, _) {
    z(U, P);
    var I = Z(U);
    function U(Y) {
      var te;
      if ($(this, U), ne(Y) !== "object" || Y === null)
        throw new Re("options", "Object", Y);
      var oe = Y.message, re = Y.operator, ee = Y.stackStartFn, ae = Y.actual, ue = Y.expected, ye = Error.stackTraceLimit;
      if (Error.stackTraceLimit = 0, oe != null)
        te = I.call(this, String(oe));
      else if (process$1.stderr && process$1.stderr.isTTY && (process$1.stderr && process$1.stderr.getColorDepth && process$1.stderr.getColorDepth() !== 1 ? (xe = "\x1B[34m", rt = "\x1B[32m", y = "\x1B[39m", N = "\x1B[31m") : (xe = "", rt = "", y = "", N = "")), ne(ae) === "object" && ae !== null && ne(ue) === "object" && ue !== null && "stack" in ae && ae instanceof Error && "stack" in ue && ue instanceof Error && (ae = B(ae), ue = B(ue)), re === "deepStrictEqual" || re === "strictEqual")
        te = I.call(this, C(ae, ue, re));
      else if (re === "notDeepStrictEqual" || re === "notStrictEqual") {
        var ve = E[re], he = O(ae).split(`
`);
        if (re === "notStrictEqual" && ne(ae) === "object" && ae !== null && (ve = E.notStrictEqualObject), he.length > 30)
          for (he[26] = "".concat(xe, "...").concat(y); he.length > 27; )
            he.pop();
        he.length === 1 ? te = I.call(this, "".concat(ve, " ").concat(he[0])) : te = I.call(this, "".concat(ve, `

`).concat(he.join(`
`), `
`));
      } else {
        var Me = O(ae), Qe = "", Ie = E[re];
        re === "notDeepEqual" || re === "notEqual" ? (Me = "".concat(E[re], `

`).concat(Me), Me.length > 1024 && (Me = "".concat(Me.slice(0, 1021), "..."))) : (Qe = "".concat(O(ue)), Me.length > 512 && (Me = "".concat(Me.slice(0, 509), "...")), Qe.length > 512 && (Qe = "".concat(Qe.slice(0, 509), "...")), re === "deepEqual" || re === "equal" ? Me = "".concat(Ie, `

`).concat(Me, `

should equal

`) : Qe = " ".concat(re, " ").concat(Qe)), te = I.call(this, "".concat(Me).concat(Qe));
      }
      return Error.stackTraceLimit = ye, te.generatedMessage = !oe, Object.defineProperty(V(te), "name", {
        value: "AssertionError [ERR_ASSERTION]",
        enumerable: !1,
        writable: !0,
        configurable: !0
      }), te.code = "ERR_ASSERTION", te.actual = ae, te.expected = ue, te.operator = re, Error.captureStackTrace && Error.captureStackTrace(V(te), ee), te.stack, te.name = "AssertionError", H(te);
    }
    return S(U, [{
      key: "toString",
      value: function() {
        return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
      }
    }, {
      key: _,
      value: function(te, oe) {
        return pe(this, M(M({}, oe), {}, {
          customInspect: !1,
          depth: 0
        }));
      }
    }]), U;
  }(/* @__PURE__ */ X(Error), pe.custom);
  return assertion_error = L, assertion_error;
}
var toStr = Object.prototype.toString, isArguments$1 = function(M) {
  var x = toStr.call(M), $ = x === "[object Arguments]";
  return $ || ($ = x !== "[object Array]" && M !== null && typeof M == "object" && typeof M.length == "number" && M.length >= 0 && toStr.call(M.callee) === "[object Function]"), $;
}, implementation$6, hasRequiredImplementation$2;
function requireImplementation$2() {
  if (hasRequiredImplementation$2) return implementation$6;
  hasRequiredImplementation$2 = 1;
  var w;
  if (!Object.keys) {
    var M = Object.prototype.hasOwnProperty, x = Object.prototype.toString, $ = isArguments$1, T = Object.prototype.propertyIsEnumerable, S = !T.call({ toString: null }, "toString"), D = T.call(function() {
    }, "prototype"), F = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ], z = function(X) {
      var Q = X.constructor;
      return Q && Q.prototype === X;
    }, Z = {
      $applicationCache: !0,
      $console: !0,
      $external: !0,
      $frame: !0,
      $frameElement: !0,
      $frames: !0,
      $innerHeight: !0,
      $innerWidth: !0,
      $onmozfullscreenchange: !0,
      $onmozfullscreenerror: !0,
      $outerHeight: !0,
      $outerWidth: !0,
      $pageXOffset: !0,
      $pageYOffset: !0,
      $parent: !0,
      $scrollLeft: !0,
      $scrollTop: !0,
      $scrollX: !0,
      $scrollY: !0,
      $self: !0,
      $webkitIndexedDB: !0,
      $webkitStorageInfo: !0,
      $window: !0
    }, H = function() {
      if (typeof window > "u")
        return !1;
      for (var X in window)
        try {
          if (!Z["$" + X] && M.call(window, X) && window[X] !== null && typeof window[X] == "object")
            try {
              z(window[X]);
            } catch {
              return !0;
            }
        } catch {
          return !0;
        }
      return !1;
    }(), V = function(X) {
      if (typeof window > "u" || !H)
        return z(X);
      try {
        return z(X);
      } catch {
        return !1;
      }
    };
    w = function(Q) {
      var fe = Q !== null && typeof Q == "object", ce = x.call(Q) === "[object Function]", me = $(Q), de = fe && x.call(Q) === "[object String]", ne = [];
      if (!fe && !ce && !me)
        throw new TypeError("Object.keys called on a non-object");
      var ge = D && ce;
      if (de && Q.length > 0 && !M.call(Q, 0))
        for (var pe = 0; pe < Q.length; ++pe)
          ne.push(String(pe));
      if (me && Q.length > 0)
        for (var $e = 0; $e < Q.length; ++$e)
          ne.push(String($e));
      else
        for (var Re in Q)
          !(ge && Re === "prototype") && M.call(Q, Re) && ne.push(String(Re));
      if (S)
        for (var Pe = V(Q), Oe = 0; Oe < F.length; ++Oe)
          !(Pe && F[Oe] === "constructor") && M.call(Q, F[Oe]) && ne.push(F[Oe]);
      return ne;
    };
  }
  return implementation$6 = w, implementation$6;
}
var slice = Array.prototype.slice, isArgs = isArguments$1, origKeys = Object.keys, keysShim = origKeys ? function(M) {
  return origKeys(M);
} : requireImplementation$2(), originalKeys = Object.keys;
keysShim.shim = function() {
  if (Object.keys) {
    var M = function() {
      var x = Object.keys(arguments);
      return x && x.length === arguments.length;
    }(1, 2);
    M || (Object.keys = function($) {
      return isArgs($) ? originalKeys(slice.call($)) : originalKeys($);
    });
  } else
    Object.keys = keysShim;
  return Object.keys || keysShim;
};
var objectKeys$2 = keysShim, objectKeys$1 = objectKeys$2, hasSymbols = shams$1(), callBound$2 = callBound$8, $Object = esObjectAtoms, $push = callBound$2("Array.prototype.push"), $propIsEnumerable = callBound$2("Object.prototype.propertyIsEnumerable"), originalGetSymbols = hasSymbols ? $Object.getOwnPropertySymbols : null, implementation$5 = function(M, x) {
  if (M == null)
    throw new TypeError("target must be an object");
  var $ = $Object(M);
  if (arguments.length === 1)
    return $;
  for (var T = 1; T < arguments.length; ++T) {
    var S = $Object(arguments[T]), D = objectKeys$1(S), F = hasSymbols && ($Object.getOwnPropertySymbols || originalGetSymbols);
    if (F)
      for (var z = F(S), Z = 0; Z < z.length; ++Z) {
        var H = z[Z];
        $propIsEnumerable(S, H) && $push(D, H);
      }
    for (var V = 0; V < D.length; ++V) {
      var X = D[V];
      if ($propIsEnumerable(S, X)) {
        var Q = S[X];
        $[X] = Q;
      }
    }
  }
  return $;
}, implementation$4 = implementation$5, lacksProperEnumerationOrder = function() {
  if (!Object.assign)
    return !1;
  for (var w = "abcdefghijklmnopqrst", M = w.split(""), x = {}, $ = 0; $ < M.length; ++$)
    x[M[$]] = M[$];
  var T = Object.assign({}, x), S = "";
  for (var D in T)
    S += D;
  return w !== S;
}, assignHasPendingExceptions = function() {
  if (!Object.assign || !Object.preventExtensions)
    return !1;
  var w = Object.preventExtensions({ 1: 2 });
  try {
    Object.assign(w, "xy");
  } catch {
    return w[1] === "y";
  }
  return !1;
}, polyfill$2 = function() {
  return !Object.assign || lacksProperEnumerationOrder() || assignHasPendingExceptions() ? implementation$4 : Object.assign;
}, numberIsNaN = function(w) {
  return w !== w;
}, implementation$3 = function(M, x) {
  return M === 0 && x === 0 ? 1 / M === 1 / x : !!(M === x || numberIsNaN(M) && numberIsNaN(x));
}, implementation$2 = implementation$3, polyfill$1 = function() {
  return typeof Object.is == "function" ? Object.is : implementation$2;
}, GetIntrinsic = getIntrinsic, callBind = callBindExports, $indexOf = callBind(GetIntrinsic("String.prototype.indexOf")), callBound$1 = function(M, x) {
  var $ = GetIntrinsic(M, !!x);
  return typeof $ == "function" && $indexOf(M, ".prototype.") > -1 ? callBind($) : $;
}, isArguments, hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments) return isArguments;
  hasRequiredIsArguments = 1;
  var w = Object.prototype.toString;
  return isArguments = function(x) {
    var $ = w.call(x), T = $ === "[object Arguments]";
    return T || (T = $ !== "[object Array]" && x !== null && typeof x == "object" && typeof x.length == "number" && x.length >= 0 && w.call(x.callee) === "[object Function]"), T;
  }, isArguments;
}
var implementation$1, hasRequiredImplementation$1;
function requireImplementation$1() {
  if (hasRequiredImplementation$1) return implementation$1;
  hasRequiredImplementation$1 = 1;
  var w;
  if (!Object.keys) {
    var M = Object.prototype.hasOwnProperty, x = Object.prototype.toString, $ = requireIsArguments(), T = Object.prototype.propertyIsEnumerable, S = !T.call({ toString: null }, "toString"), D = T.call(function() {
    }, "prototype"), F = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ], z = function(X) {
      var Q = X.constructor;
      return Q && Q.prototype === X;
    }, Z = {
      $applicationCache: !0,
      $console: !0,
      $external: !0,
      $frame: !0,
      $frameElement: !0,
      $frames: !0,
      $innerHeight: !0,
      $innerWidth: !0,
      $onmozfullscreenchange: !0,
      $onmozfullscreenerror: !0,
      $outerHeight: !0,
      $outerWidth: !0,
      $pageXOffset: !0,
      $pageYOffset: !0,
      $parent: !0,
      $scrollLeft: !0,
      $scrollTop: !0,
      $scrollX: !0,
      $scrollY: !0,
      $self: !0,
      $webkitIndexedDB: !0,
      $webkitStorageInfo: !0,
      $window: !0
    }, H = function() {
      if (typeof window > "u")
        return !1;
      for (var X in window)
        try {
          if (!Z["$" + X] && M.call(window, X) && window[X] !== null && typeof window[X] == "object")
            try {
              z(window[X]);
            } catch {
              return !0;
            }
        } catch {
          return !0;
        }
      return !1;
    }(), V = function(X) {
      if (typeof window > "u" || !H)
        return z(X);
      try {
        return z(X);
      } catch {
        return !1;
      }
    };
    w = function(Q) {
      var fe = Q !== null && typeof Q == "object", ce = x.call(Q) === "[object Function]", me = $(Q), de = fe && x.call(Q) === "[object String]", ne = [];
      if (!fe && !ce && !me)
        throw new TypeError("Object.keys called on a non-object");
      var ge = D && ce;
      if (de && Q.length > 0 && !M.call(Q, 0))
        for (var pe = 0; pe < Q.length; ++pe)
          ne.push(String(pe));
      if (me && Q.length > 0)
        for (var $e = 0; $e < Q.length; ++$e)
          ne.push(String($e));
      else
        for (var Re in Q)
          !(ge && Re === "prototype") && M.call(Q, Re) && ne.push(String(Re));
      if (S)
        for (var Pe = V(Q), Oe = 0; Oe < F.length; ++Oe)
          !(Pe && F[Oe] === "constructor") && M.call(Q, F[Oe]) && ne.push(F[Oe]);
      return ne;
    };
  }
  return implementation$1 = w, implementation$1;
}
var objectKeys, hasRequiredObjectKeys;
function requireObjectKeys() {
  if (hasRequiredObjectKeys) return objectKeys;
  hasRequiredObjectKeys = 1;
  var w = Array.prototype.slice, M = requireIsArguments(), x = Object.keys, $ = x ? function(D) {
    return x(D);
  } : requireImplementation$1(), T = Object.keys;
  return $.shim = function() {
    if (Object.keys) {
      var D = function() {
        var F = Object.keys(arguments);
        return F && F.length === arguments.length;
      }(1, 2);
      D || (Object.keys = function(z) {
        return M(z) ? T(w.call(z)) : T(z);
      });
    } else
      Object.keys = $;
    return Object.keys || $;
  }, objectKeys = $, objectKeys;
}
var defineProperties_1, hasRequiredDefineProperties;
function requireDefineProperties() {
  if (hasRequiredDefineProperties) return defineProperties_1;
  hasRequiredDefineProperties = 1;
  var w = requireObjectKeys(), M = typeof Symbol == "function" && typeof Symbol("foo") == "symbol", x = Object.prototype.toString, $ = Array.prototype.concat, T = defineDataProperty, S = function(Z) {
    return typeof Z == "function" && x.call(Z) === "[object Function]";
  }, D = hasPropertyDescriptors_1(), F = function(Z, H, V, X) {
    if (H in Z) {
      if (X === !0) {
        if (Z[H] === V)
          return;
      } else if (!S(X) || !X())
        return;
    }
    D ? T(Z, H, V, !0) : T(Z, H, V);
  }, z = function(Z, H) {
    var V = arguments.length > 2 ? arguments[2] : {}, X = w(H);
    M && (X = $.call(X, Object.getOwnPropertySymbols(H)));
    for (var Q = 0; Q < X.length; Q += 1)
      F(Z, X[Q], H[X[Q]], V[X[Q]]);
  };
  return z.supportsDescriptors = !!D, defineProperties_1 = z, defineProperties_1;
}
var shim$1, hasRequiredShim$1;
function requireShim$1() {
  if (hasRequiredShim$1) return shim$1;
  hasRequiredShim$1 = 1;
  var w = polyfill$1, M = requireDefineProperties();
  return shim$1 = function() {
    var $ = w();
    return M(Object, { is: $ }, {
      is: function() {
        return Object.is !== $;
      }
    }), $;
  }, shim$1;
}
var objectIs, hasRequiredObjectIs;
function requireObjectIs() {
  if (hasRequiredObjectIs) return objectIs;
  hasRequiredObjectIs = 1;
  var w = requireDefineProperties(), M = callBindExports, x = implementation$3, $ = polyfill$1, T = requireShim$1(), S = M($(), Object);
  return w(S, {
    getPolyfill: $,
    implementation: x,
    shim: T
  }), objectIs = S, objectIs;
}
var implementation, hasRequiredImplementation;
function requireImplementation() {
  return hasRequiredImplementation || (hasRequiredImplementation = 1, implementation = function(M) {
    return M !== M;
  }), implementation;
}
var polyfill, hasRequiredPolyfill;
function requirePolyfill() {
  if (hasRequiredPolyfill) return polyfill;
  hasRequiredPolyfill = 1;
  var w = requireImplementation();
  return polyfill = function() {
    return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : w;
  }, polyfill;
}
var shim, hasRequiredShim;
function requireShim() {
  if (hasRequiredShim) return shim;
  hasRequiredShim = 1;
  var w = requireDefineProperties(), M = requirePolyfill();
  return shim = function() {
    var $ = M();
    return w(Number, { isNaN: $ }, {
      isNaN: function() {
        return Number.isNaN !== $;
      }
    }), $;
  }, shim;
}
var isNan, hasRequiredIsNan;
function requireIsNan() {
  if (hasRequiredIsNan) return isNan;
  hasRequiredIsNan = 1;
  var w = callBindExports, M = requireDefineProperties(), x = requireImplementation(), $ = requirePolyfill(), T = requireShim(), S = w($(), Number);
  return M(S, {
    getPolyfill: $,
    implementation: x,
    shim: T
  }), isNan = S, isNan;
}
var comparisons, hasRequiredComparisons;
function requireComparisons() {
  if (hasRequiredComparisons) return comparisons;
  hasRequiredComparisons = 1;
  function w(be, _e) {
    return S(be) || T(be, _e) || x(be, _e) || M();
  }
  function M() {
    throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  function x(be, _e) {
    if (be) {
      if (typeof be == "string") return $(be, _e);
      var it = Object.prototype.toString.call(be).slice(8, -1);
      if (it === "Object" && be.constructor && (it = be.constructor.name), it === "Map" || it === "Set") return Array.from(be);
      if (it === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(it)) return $(be, _e);
    }
  }
  function $(be, _e) {
    (_e == null || _e > be.length) && (_e = be.length);
    for (var it = 0, Ae = new Array(_e); it < _e; it++) Ae[it] = be[it];
    return Ae;
  }
  function T(be, _e) {
    var it = be == null ? null : typeof Symbol < "u" && be[Symbol.iterator] || be["@@iterator"];
    if (it != null) {
      var Ae, Be, nt, Te, Ue = [], st = !0, Le = !1;
      try {
        if (nt = (it = it.call(be)).next, _e !== 0) for (; !(st = (Ae = nt.call(it)).done) && (Ue.push(Ae.value), Ue.length !== _e); st = !0) ;
      } catch (Ge) {
        Le = !0, Be = Ge;
      } finally {
        try {
          if (!st && it.return != null && (Te = it.return(), Object(Te) !== Te)) return;
        } finally {
          if (Le) throw Be;
        }
      }
      return Ue;
    }
  }
  function S(be) {
    if (Array.isArray(be)) return be;
  }
  function D(be) {
    "@babel/helpers - typeof";
    return D = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(_e) {
      return typeof _e;
    } : function(_e) {
      return _e && typeof Symbol == "function" && _e.constructor === Symbol && _e !== Symbol.prototype ? "symbol" : typeof _e;
    }, D(be);
  }
  var F = /a/g.flags !== void 0, z = function(_e) {
    var it = [];
    return _e.forEach(function(Ae) {
      return it.push(Ae);
    }), it;
  }, Z = function(_e) {
    var it = [];
    return _e.forEach(function(Ae, Be) {
      return it.push([Be, Ae]);
    }), it;
  }, H = Object.is ? Object.is : requireObjectIs(), V = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
    return [];
  }, X = Number.isNaN ? Number.isNaN : requireIsNan();
  function Q(be) {
    return be.call.bind(be);
  }
  var fe = Q(Object.prototype.hasOwnProperty), ce = Q(Object.prototype.propertyIsEnumerable), me = Q(Object.prototype.toString), de = util$3.types, ne = de.isAnyArrayBuffer, ge = de.isArrayBufferView, pe = de.isDate, $e = de.isMap, Re = de.isRegExp, Pe = de.isSet, Oe = de.isNativeError, xe = de.isBoxedPrimitive, rt = de.isNumberObject, N = de.isStringObject, y = de.isBooleanObject, E = de.isBigIntObject, A = de.isSymbolObject, B = de.isFloat32Array, O = de.isFloat64Array;
  function C(be) {
    if (be.length === 0 || be.length > 10) return !0;
    for (var _e = 0; _e < be.length; _e++) {
      var it = be.charCodeAt(_e);
      if (it < 48 || it > 57) return !0;
    }
    return be.length === 10 && be >= Math.pow(2, 32);
  }
  function L(be) {
    return Object.keys(be).filter(C).concat(V(be).filter(Object.prototype.propertyIsEnumerable.bind(be)));
  }
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */
  function P(be, _e) {
    if (be === _e)
      return 0;
    for (var it = be.length, Ae = _e.length, Be = 0, nt = Math.min(it, Ae); Be < nt; ++Be)
      if (be[Be] !== _e[Be]) {
        it = be[Be], Ae = _e[Be];
        break;
      }
    return it < Ae ? -1 : Ae < it ? 1 : 0;
  }
  var _ = !0, I = !1, U = 0, Y = 1, te = 2, oe = 3;
  function re(be, _e) {
    return F ? be.source === _e.source && be.flags === _e.flags : RegExp.prototype.toString.call(be) === RegExp.prototype.toString.call(_e);
  }
  function ee(be, _e) {
    if (be.byteLength !== _e.byteLength)
      return !1;
    for (var it = 0; it < be.byteLength; it++)
      if (be[it] !== _e[it])
        return !1;
    return !0;
  }
  function ae(be, _e) {
    return be.byteLength !== _e.byteLength ? !1 : P(new Uint8Array(be.buffer, be.byteOffset, be.byteLength), new Uint8Array(_e.buffer, _e.byteOffset, _e.byteLength)) === 0;
  }
  function ue(be, _e) {
    return be.byteLength === _e.byteLength && P(new Uint8Array(be), new Uint8Array(_e)) === 0;
  }
  function ye(be, _e) {
    return rt(be) ? rt(_e) && H(Number.prototype.valueOf.call(be), Number.prototype.valueOf.call(_e)) : N(be) ? N(_e) && String.prototype.valueOf.call(be) === String.prototype.valueOf.call(_e) : y(be) ? y(_e) && Boolean.prototype.valueOf.call(be) === Boolean.prototype.valueOf.call(_e) : E(be) ? E(_e) && BigInt.prototype.valueOf.call(be) === BigInt.prototype.valueOf.call(_e) : A(_e) && Symbol.prototype.valueOf.call(be) === Symbol.prototype.valueOf.call(_e);
  }
  function ve(be, _e, it, Ae) {
    if (be === _e)
      return be !== 0 ? !0 : it ? H(be, _e) : !0;
    if (it) {
      if (D(be) !== "object")
        return typeof be == "number" && X(be) && X(_e);
      if (D(_e) !== "object" || be === null || _e === null || Object.getPrototypeOf(be) !== Object.getPrototypeOf(_e))
        return !1;
    } else {
      if (be === null || D(be) !== "object")
        return _e === null || D(_e) !== "object" ? be == _e : !1;
      if (_e === null || D(_e) !== "object")
        return !1;
    }
    var Be = me(be), nt = me(_e);
    if (Be !== nt)
      return !1;
    if (Array.isArray(be)) {
      if (be.length !== _e.length)
        return !1;
      var Te = L(be), Ue = L(_e);
      return Te.length !== Ue.length ? !1 : Me(be, _e, it, Ae, Y, Te);
    }
    if (Be === "[object Object]" && (!$e(be) && $e(_e) || !Pe(be) && Pe(_e)))
      return !1;
    if (pe(be)) {
      if (!pe(_e) || Date.prototype.getTime.call(be) !== Date.prototype.getTime.call(_e))
        return !1;
    } else if (Re(be)) {
      if (!Re(_e) || !re(be, _e))
        return !1;
    } else if (Oe(be) || be instanceof Error) {
      if (be.message !== _e.message || be.name !== _e.name)
        return !1;
    } else if (ge(be)) {
      if (!it && (B(be) || O(be))) {
        if (!ee(be, _e))
          return !1;
      } else if (!ae(be, _e))
        return !1;
      var st = L(be), Le = L(_e);
      return st.length !== Le.length ? !1 : Me(be, _e, it, Ae, U, st);
    } else {
      if (Pe(be))
        return !Pe(_e) || be.size !== _e.size ? !1 : Me(be, _e, it, Ae, te);
      if ($e(be))
        return !$e(_e) || be.size !== _e.size ? !1 : Me(be, _e, it, Ae, oe);
      if (ne(be)) {
        if (!ue(be, _e))
          return !1;
      } else if (xe(be) && !ye(be, _e))
        return !1;
    }
    return Me(be, _e, it, Ae, U);
  }
  function he(be, _e) {
    return _e.filter(function(it) {
      return ce(be, it);
    });
  }
  function Me(be, _e, it, Ae, Be, nt) {
    if (arguments.length === 5) {
      nt = Object.keys(be);
      var Te = Object.keys(_e);
      if (nt.length !== Te.length)
        return !1;
    }
    for (var Ue = 0; Ue < nt.length; Ue++)
      if (!fe(_e, nt[Ue]))
        return !1;
    if (it && arguments.length === 5) {
      var st = V(be);
      if (st.length !== 0) {
        var Le = 0;
        for (Ue = 0; Ue < st.length; Ue++) {
          var Ge = st[Ue];
          if (ce(be, Ge)) {
            if (!ce(_e, Ge))
              return !1;
            nt.push(Ge), Le++;
          } else if (ce(_e, Ge))
            return !1;
        }
        var pt = V(_e);
        if (st.length !== pt.length && he(_e, pt).length !== Le)
          return !1;
      } else {
        var je = V(_e);
        if (je.length !== 0 && he(_e, je).length !== 0)
          return !1;
      }
    }
    if (nt.length === 0 && (Be === U || Be === Y && be.length === 0 || be.size === 0))
      return !0;
    if (Ae === void 0)
      Ae = {
        val1: /* @__PURE__ */ new Map(),
        val2: /* @__PURE__ */ new Map(),
        position: 0
      };
    else {
      var Je = Ae.val1.get(be);
      if (Je !== void 0) {
        var dt = Ae.val2.get(_e);
        if (dt !== void 0)
          return Je === dt;
      }
      Ae.position++;
    }
    Ae.val1.set(be, Ae.position), Ae.val2.set(_e, Ae.position);
    var ze = qe(be, _e, it, nt, Ae, Be);
    return Ae.val1.delete(be), Ae.val2.delete(_e), ze;
  }
  function Qe(be, _e, it, Ae) {
    for (var Be = z(be), nt = 0; nt < Be.length; nt++) {
      var Te = Be[nt];
      if (ve(_e, Te, it, Ae))
        return be.delete(Te), !0;
    }
    return !1;
  }
  function Ie(be) {
    switch (D(be)) {
      case "undefined":
        return null;
      case "object":
        return;
      case "symbol":
        return !1;
      case "string":
        be = +be;
      case "number":
        if (X(be))
          return !1;
    }
    return !0;
  }
  function De(be, _e, it) {
    var Ae = Ie(it);
    return Ae ?? (_e.has(Ae) && !be.has(Ae));
  }
  function at(be, _e, it, Ae, Be) {
    var nt = Ie(it);
    if (nt != null)
      return nt;
    var Te = _e.get(nt);
    return Te === void 0 && !_e.has(nt) || !ve(Ae, Te, !1, Be) ? !1 : !be.has(nt) && ve(Ae, Te, !1, Be);
  }
  function ke(be, _e, it, Ae) {
    for (var Be = null, nt = z(be), Te = 0; Te < nt.length; Te++) {
      var Ue = nt[Te];
      if (D(Ue) === "object" && Ue !== null)
        Be === null && (Be = /* @__PURE__ */ new Set()), Be.add(Ue);
      else if (!_e.has(Ue)) {
        if (it || !De(be, _e, Ue))
          return !1;
        Be === null && (Be = /* @__PURE__ */ new Set()), Be.add(Ue);
      }
    }
    if (Be !== null) {
      for (var st = z(_e), Le = 0; Le < st.length; Le++) {
        var Ge = st[Le];
        if (D(Ge) === "object" && Ge !== null) {
          if (!Qe(Be, Ge, it, Ae)) return !1;
        } else if (!it && !be.has(Ge) && !Qe(Be, Ge, it, Ae))
          return !1;
      }
      return Be.size === 0;
    }
    return !0;
  }
  function Se(be, _e, it, Ae, Be, nt) {
    for (var Te = z(be), Ue = 0; Ue < Te.length; Ue++) {
      var st = Te[Ue];
      if (ve(it, st, Be, nt) && ve(Ae, _e.get(st), Be, nt))
        return be.delete(st), !0;
    }
    return !1;
  }
  function lt(be, _e, it, Ae) {
    for (var Be = null, nt = Z(be), Te = 0; Te < nt.length; Te++) {
      var Ue = w(nt[Te], 2), st = Ue[0], Le = Ue[1];
      if (D(st) === "object" && st !== null)
        Be === null && (Be = /* @__PURE__ */ new Set()), Be.add(st);
      else {
        var Ge = _e.get(st);
        if (Ge === void 0 && !_e.has(st) || !ve(Le, Ge, it, Ae)) {
          if (it || !at(be, _e, st, Le, Ae)) return !1;
          Be === null && (Be = /* @__PURE__ */ new Set()), Be.add(st);
        }
      }
    }
    if (Be !== null) {
      for (var pt = Z(_e), je = 0; je < pt.length; je++) {
        var Je = w(pt[je], 2), dt = Je[0], ze = Je[1];
        if (D(dt) === "object" && dt !== null) {
          if (!Se(Be, be, dt, ze, it, Ae)) return !1;
        } else if (!it && (!be.has(dt) || !ve(be.get(dt), ze, !1, Ae)) && !Se(Be, be, dt, ze, !1, Ae))
          return !1;
      }
      return Be.size === 0;
    }
    return !0;
  }
  function qe(be, _e, it, Ae, Be, nt) {
    var Te = 0;
    if (nt === te) {
      if (!ke(be, _e, it, Be))
        return !1;
    } else if (nt === oe) {
      if (!lt(be, _e, it, Be))
        return !1;
    } else if (nt === Y)
      for (; Te < be.length; Te++)
        if (fe(be, Te)) {
          if (!fe(_e, Te) || !ve(be[Te], _e[Te], it, Be))
            return !1;
        } else {
          if (fe(_e, Te))
            return !1;
          for (var Ue = Object.keys(be); Te < Ue.length; Te++) {
            var st = Ue[Te];
            if (!fe(_e, st) || !ve(be[st], _e[st], it, Be))
              return !1;
          }
          return Ue.length === Object.keys(_e).length;
        }
    for (Te = 0; Te < Ae.length; Te++) {
      var Le = Ae[Te];
      if (!ve(be[Le], _e[Le], it, Be))
        return !1;
    }
    return !0;
  }
  function He(be, _e) {
    return ve(be, _e, I);
  }
  function ot(be, _e) {
    return ve(be, _e, _);
  }
  return comparisons = {
    isDeepEqual: He,
    isDeepStrictEqual: ot
  }, comparisons;
}
var hasRequiredAssert;
function requireAssert() {
  if (hasRequiredAssert) return assert$k.exports;
  hasRequiredAssert = 1;
  function w(te) {
    "@babel/helpers - typeof";
    return w = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(oe) {
      return typeof oe;
    } : function(oe) {
      return oe && typeof Symbol == "function" && oe.constructor === Symbol && oe !== Symbol.prototype ? "symbol" : typeof oe;
    }, w(te);
  }
  function M(te, oe, re) {
    return Object.defineProperty(te, "prototype", { writable: !1 }), te;
  }
  function x(te, oe) {
    if (!(te instanceof oe))
      throw new TypeError("Cannot call a class as a function");
  }
  var $ = requireErrors(), T = $.codes, S = T.ERR_AMBIGUOUS_ARGUMENT, D = T.ERR_INVALID_ARG_TYPE, F = T.ERR_INVALID_ARG_VALUE, z = T.ERR_INVALID_RETURN_VALUE, Z = T.ERR_MISSING_ARGS, H = requireAssertion_error(), V = util$3, X = V.inspect, Q = util$3.types, fe = Q.isPromise, ce = Q.isRegExp, me = polyfill$2(), de = polyfill$1(), ne = callBound$1("RegExp.prototype.test"), ge, pe;
  function $e() {
    var te = requireComparisons();
    ge = te.isDeepEqual, pe = te.isDeepStrictEqual;
  }
  var Re = !1, Pe = assert$k.exports = y, Oe = {};
  function xe(te) {
    throw te.message instanceof Error ? te.message : new H(te);
  }
  function rt(te, oe, re, ee, ae) {
    var ue = arguments.length, ye;
    if (ue === 0)
      ye = "Failed";
    else if (ue === 1)
      re = te, te = void 0;
    else {
      if (Re === !1) {
        Re = !0;
        var ve = process$1.emitWarning ? process$1.emitWarning : console.warn.bind(console);
        ve("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
      }
      ue === 2 && (ee = "!=");
    }
    if (re instanceof Error) throw re;
    var he = {
      actual: te,
      expected: oe,
      operator: ee === void 0 ? "fail" : ee,
      stackStartFn: ae || rt
    };
    re !== void 0 && (he.message = re);
    var Me = new H(he);
    throw ye && (Me.message = ye, Me.generatedMessage = !0), Me;
  }
  Pe.fail = rt, Pe.AssertionError = H;
  function N(te, oe, re, ee) {
    if (!re) {
      var ae = !1;
      if (oe === 0)
        ae = !0, ee = "No value argument passed to `assert.ok()`";
      else if (ee instanceof Error)
        throw ee;
      var ue = new H({
        actual: re,
        expected: !0,
        message: ee,
        operator: "==",
        stackStartFn: te
      });
      throw ue.generatedMessage = ae, ue;
    }
  }
  function y() {
    for (var te = arguments.length, oe = new Array(te), re = 0; re < te; re++)
      oe[re] = arguments[re];
    N.apply(void 0, [y, oe.length].concat(oe));
  }
  Pe.ok = y, Pe.equal = function te(oe, re, ee) {
    if (arguments.length < 2)
      throw new Z("actual", "expected");
    oe != re && xe({
      actual: oe,
      expected: re,
      message: ee,
      operator: "==",
      stackStartFn: te
    });
  }, Pe.notEqual = function te(oe, re, ee) {
    if (arguments.length < 2)
      throw new Z("actual", "expected");
    oe == re && xe({
      actual: oe,
      expected: re,
      message: ee,
      operator: "!=",
      stackStartFn: te
    });
  }, Pe.deepEqual = function te(oe, re, ee) {
    if (arguments.length < 2)
      throw new Z("actual", "expected");
    ge === void 0 && $e(), ge(oe, re) || xe({
      actual: oe,
      expected: re,
      message: ee,
      operator: "deepEqual",
      stackStartFn: te
    });
  }, Pe.notDeepEqual = function te(oe, re, ee) {
    if (arguments.length < 2)
      throw new Z("actual", "expected");
    ge === void 0 && $e(), ge(oe, re) && xe({
      actual: oe,
      expected: re,
      message: ee,
      operator: "notDeepEqual",
      stackStartFn: te
    });
  }, Pe.deepStrictEqual = function te(oe, re, ee) {
    if (arguments.length < 2)
      throw new Z("actual", "expected");
    ge === void 0 && $e(), pe(oe, re) || xe({
      actual: oe,
      expected: re,
      message: ee,
      operator: "deepStrictEqual",
      stackStartFn: te
    });
  }, Pe.notDeepStrictEqual = E;
  function E(te, oe, re) {
    if (arguments.length < 2)
      throw new Z("actual", "expected");
    ge === void 0 && $e(), pe(te, oe) && xe({
      actual: te,
      expected: oe,
      message: re,
      operator: "notDeepStrictEqual",
      stackStartFn: E
    });
  }
  Pe.strictEqual = function te(oe, re, ee) {
    if (arguments.length < 2)
      throw new Z("actual", "expected");
    de(oe, re) || xe({
      actual: oe,
      expected: re,
      message: ee,
      operator: "strictEqual",
      stackStartFn: te
    });
  }, Pe.notStrictEqual = function te(oe, re, ee) {
    if (arguments.length < 2)
      throw new Z("actual", "expected");
    de(oe, re) && xe({
      actual: oe,
      expected: re,
      message: ee,
      operator: "notStrictEqual",
      stackStartFn: te
    });
  };
  var A = /* @__PURE__ */ M(function te(oe, re, ee) {
    var ae = this;
    x(this, te), re.forEach(function(ue) {
      ue in oe && (ee !== void 0 && typeof ee[ue] == "string" && ce(oe[ue]) && ne(oe[ue], ee[ue]) ? ae[ue] = ee[ue] : ae[ue] = oe[ue]);
    });
  });
  function B(te, oe, re, ee, ae, ue) {
    if (!(re in te) || !pe(te[re], oe[re])) {
      if (!ee) {
        var ye = new A(te, ae), ve = new A(oe, ae, te), he = new H({
          actual: ye,
          expected: ve,
          operator: "deepStrictEqual",
          stackStartFn: ue
        });
        throw he.actual = te, he.expected = oe, he.operator = ue.name, he;
      }
      xe({
        actual: te,
        expected: oe,
        message: ee,
        operator: ue.name,
        stackStartFn: ue
      });
    }
  }
  function O(te, oe, re, ee) {
    if (typeof oe != "function") {
      if (ce(oe)) return ne(oe, te);
      if (arguments.length === 2)
        throw new D("expected", ["Function", "RegExp"], oe);
      if (w(te) !== "object" || te === null) {
        var ae = new H({
          actual: te,
          expected: oe,
          message: re,
          operator: "deepStrictEqual",
          stackStartFn: ee
        });
        throw ae.operator = ee.name, ae;
      }
      var ue = Object.keys(oe);
      if (oe instanceof Error)
        ue.push("name", "message");
      else if (ue.length === 0)
        throw new F("error", oe, "may not be an empty object");
      return ge === void 0 && $e(), ue.forEach(function(ye) {
        typeof te[ye] == "string" && ce(oe[ye]) && ne(oe[ye], te[ye]) || B(te, oe, ye, re, ue, ee);
      }), !0;
    }
    return oe.prototype !== void 0 && te instanceof oe ? !0 : Error.isPrototypeOf(oe) ? !1 : oe.call({}, te) === !0;
  }
  function C(te) {
    if (typeof te != "function")
      throw new D("fn", "Function", te);
    try {
      te();
    } catch (oe) {
      return oe;
    }
    return Oe;
  }
  function L(te) {
    return fe(te) || te !== null && w(te) === "object" && typeof te.then == "function" && typeof te.catch == "function";
  }
  function P(te) {
    return Promise.resolve().then(function() {
      var oe;
      if (typeof te == "function") {
        if (oe = te(), !L(oe))
          throw new z("instance of Promise", "promiseFn", oe);
      } else if (L(te))
        oe = te;
      else
        throw new D("promiseFn", ["Function", "Promise"], te);
      return Promise.resolve().then(function() {
        return oe;
      }).then(function() {
        return Oe;
      }).catch(function(re) {
        return re;
      });
    });
  }
  function _(te, oe, re, ee) {
    if (typeof re == "string") {
      if (arguments.length === 4)
        throw new D("error", ["Object", "Error", "Function", "RegExp"], re);
      if (w(oe) === "object" && oe !== null) {
        if (oe.message === re)
          throw new S("error/message", 'The error message "'.concat(oe.message, '" is identical to the message.'));
      } else if (oe === re)
        throw new S("error/message", 'The error "'.concat(oe, '" is identical to the message.'));
      ee = re, re = void 0;
    } else if (re != null && w(re) !== "object" && typeof re != "function")
      throw new D("error", ["Object", "Error", "Function", "RegExp"], re);
    if (oe === Oe) {
      var ae = "";
      re && re.name && (ae += " (".concat(re.name, ")")), ae += ee ? ": ".concat(ee) : ".";
      var ue = te.name === "rejects" ? "rejection" : "exception";
      xe({
        actual: void 0,
        expected: re,
        operator: te.name,
        message: "Missing expected ".concat(ue).concat(ae),
        stackStartFn: te
      });
    }
    if (re && !O(oe, re, ee, te))
      throw oe;
  }
  function I(te, oe, re, ee) {
    if (oe !== Oe) {
      if (typeof re == "string" && (ee = re, re = void 0), !re || O(oe, re)) {
        var ae = ee ? ": ".concat(ee) : ".", ue = te.name === "doesNotReject" ? "rejection" : "exception";
        xe({
          actual: oe,
          expected: re,
          operator: te.name,
          message: "Got unwanted ".concat(ue).concat(ae, `
`) + 'Actual message: "'.concat(oe && oe.message, '"'),
          stackStartFn: te
        });
      }
      throw oe;
    }
  }
  Pe.throws = function te(oe) {
    for (var re = arguments.length, ee = new Array(re > 1 ? re - 1 : 0), ae = 1; ae < re; ae++)
      ee[ae - 1] = arguments[ae];
    _.apply(void 0, [te, C(oe)].concat(ee));
  }, Pe.rejects = function te(oe) {
    for (var re = arguments.length, ee = new Array(re > 1 ? re - 1 : 0), ae = 1; ae < re; ae++)
      ee[ae - 1] = arguments[ae];
    return P(oe).then(function(ue) {
      return _.apply(void 0, [te, ue].concat(ee));
    });
  }, Pe.doesNotThrow = function te(oe) {
    for (var re = arguments.length, ee = new Array(re > 1 ? re - 1 : 0), ae = 1; ae < re; ae++)
      ee[ae - 1] = arguments[ae];
    I.apply(void 0, [te, C(oe)].concat(ee));
  }, Pe.doesNotReject = function te(oe) {
    for (var re = arguments.length, ee = new Array(re > 1 ? re - 1 : 0), ae = 1; ae < re; ae++)
      ee[ae - 1] = arguments[ae];
    return P(oe).then(function(ue) {
      return I.apply(void 0, [te, ue].concat(ee));
    });
  }, Pe.ifError = function te(oe) {
    if (oe != null) {
      var re = "ifError got unwanted exception: ";
      w(oe) === "object" && typeof oe.message == "string" ? oe.message.length === 0 && oe.constructor ? re += oe.constructor.name : re += oe.message : re += X(oe);
      var ee = new H({
        actual: oe,
        expected: null,
        operator: "ifError",
        message: re,
        stackStartFn: te
      }), ae = oe.stack;
      if (typeof ae == "string") {
        var ue = ae.split(`
`);
        ue.shift();
        for (var ye = ee.stack.split(`
`), ve = 0; ve < ue.length; ve++) {
          var he = ye.indexOf(ue[ve]);
          if (he !== -1) {
            ye = ye.slice(0, he);
            break;
          }
        }
        ee.stack = "".concat(ye.join(`
`), `
`).concat(ue.join(`
`));
      }
      throw ee;
    }
  };
  function U(te, oe, re, ee, ae) {
    if (!ce(oe))
      throw new D("regexp", "RegExp", oe);
    var ue = ae === "match";
    if (typeof te != "string" || ne(oe, te) !== ue) {
      if (re instanceof Error)
        throw re;
      var ye = !re;
      re = re || (typeof te != "string" ? 'The "string" argument must be of type string. Received type ' + "".concat(w(te), " (").concat(X(te), ")") : (ue ? "The input did not match the regular expression " : "The input was expected to not match the regular expression ") + "".concat(X(oe), `. Input:

`).concat(X(te), `
`));
      var ve = new H({
        actual: te,
        expected: oe,
        message: re,
        operator: ae,
        stackStartFn: ee
      });
      throw ve.generatedMessage = ye, ve;
    }
  }
  Pe.match = function te(oe, re, ee) {
    U(oe, re, ee, te, "match");
  }, Pe.doesNotMatch = function te(oe, re, ee) {
    U(oe, re, ee, te, "doesNotMatch");
  };
  function Y() {
    for (var te = arguments.length, oe = new Array(te), re = 0; re < te; re++)
      oe[re] = arguments[re];
    N.apply(void 0, [Y, oe.length].concat(oe));
  }
  return Pe.strict = me(Y, Pe, {
    equal: Pe.strictEqual,
    deepEqual: Pe.deepStrictEqual,
    notEqual: Pe.notStrictEqual,
    notDeepEqual: Pe.notDeepStrictEqual
  }), Pe.strict.strict = Pe.strict, assert$k.exports;
}
var assertExports = requireAssert();
const assert$j = /* @__PURE__ */ getDefaultExportFromCjs$1(assertExports);
var empty = null, empty_1 = empty;
function assertPath(w) {
  if (typeof w != "string")
    throw new TypeError("Path must be a string. Received " + JSON.stringify(w));
}
function normalizeStringPosix(w, M) {
  for (var x = "", $ = 0, T = -1, S = 0, D, F = 0; F <= w.length; ++F) {
    if (F < w.length)
      D = w.charCodeAt(F);
    else {
      if (D === 47)
        break;
      D = 47;
    }
    if (D === 47) {
      if (!(T === F - 1 || S === 1)) if (T !== F - 1 && S === 2) {
        if (x.length < 2 || $ !== 2 || x.charCodeAt(x.length - 1) !== 46 || x.charCodeAt(x.length - 2) !== 46) {
          if (x.length > 2) {
            var z = x.lastIndexOf("/");
            if (z !== x.length - 1) {
              z === -1 ? (x = "", $ = 0) : (x = x.slice(0, z), $ = x.length - 1 - x.lastIndexOf("/")), T = F, S = 0;
              continue;
            }
          } else if (x.length === 2 || x.length === 1) {
            x = "", $ = 0, T = F, S = 0;
            continue;
          }
        }
        M && (x.length > 0 ? x += "/.." : x = "..", $ = 2);
      } else
        x.length > 0 ? x += "/" + w.slice(T + 1, F) : x = w.slice(T + 1, F), $ = F - T - 1;
      T = F, S = 0;
    } else D === 46 && S !== -1 ? ++S : S = -1;
  }
  return x;
}
function _format(w, M) {
  var x = M.dir || M.root, $ = M.base || (M.name || "") + (M.ext || "");
  return x ? x === M.root ? x + $ : x + w + $ : $;
}
var posix = {
  // path.resolve([from ...], to)
  resolve: function() {
    for (var M = "", x = !1, $, T = arguments.length - 1; T >= -1 && !x; T--) {
      var S;
      T >= 0 ? S = arguments[T] : ($ === void 0 && ($ = process$1.cwd()), S = $), assertPath(S), S.length !== 0 && (M = S + "/" + M, x = S.charCodeAt(0) === 47);
    }
    return M = normalizeStringPosix(M, !x), x ? M.length > 0 ? "/" + M : "/" : M.length > 0 ? M : ".";
  },
  normalize: function(M) {
    if (assertPath(M), M.length === 0) return ".";
    var x = M.charCodeAt(0) === 47, $ = M.charCodeAt(M.length - 1) === 47;
    return M = normalizeStringPosix(M, !x), M.length === 0 && !x && (M = "."), M.length > 0 && $ && (M += "/"), x ? "/" + M : M;
  },
  isAbsolute: function(M) {
    return assertPath(M), M.length > 0 && M.charCodeAt(0) === 47;
  },
  join: function() {
    if (arguments.length === 0)
      return ".";
    for (var M, x = 0; x < arguments.length; ++x) {
      var $ = arguments[x];
      assertPath($), $.length > 0 && (M === void 0 ? M = $ : M += "/" + $);
    }
    return M === void 0 ? "." : posix.normalize(M);
  },
  relative: function(M, x) {
    if (assertPath(M), assertPath(x), M === x || (M = posix.resolve(M), x = posix.resolve(x), M === x)) return "";
    for (var $ = 1; $ < M.length && M.charCodeAt($) === 47; ++$)
      ;
    for (var T = M.length, S = T - $, D = 1; D < x.length && x.charCodeAt(D) === 47; ++D)
      ;
    for (var F = x.length, z = F - D, Z = S < z ? S : z, H = -1, V = 0; V <= Z; ++V) {
      if (V === Z) {
        if (z > Z) {
          if (x.charCodeAt(D + V) === 47)
            return x.slice(D + V + 1);
          if (V === 0)
            return x.slice(D + V);
        } else S > Z && (M.charCodeAt($ + V) === 47 ? H = V : V === 0 && (H = 0));
        break;
      }
      var X = M.charCodeAt($ + V), Q = x.charCodeAt(D + V);
      if (X !== Q)
        break;
      X === 47 && (H = V);
    }
    var fe = "";
    for (V = $ + H + 1; V <= T; ++V)
      (V === T || M.charCodeAt(V) === 47) && (fe.length === 0 ? fe += ".." : fe += "/..");
    return fe.length > 0 ? fe + x.slice(D + H) : (D += H, x.charCodeAt(D) === 47 && ++D, x.slice(D));
  },
  _makeLong: function(M) {
    return M;
  },
  dirname: function(M) {
    if (assertPath(M), M.length === 0) return ".";
    for (var x = M.charCodeAt(0), $ = x === 47, T = -1, S = !0, D = M.length - 1; D >= 1; --D)
      if (x = M.charCodeAt(D), x === 47) {
        if (!S) {
          T = D;
          break;
        }
      } else
        S = !1;
    return T === -1 ? $ ? "/" : "." : $ && T === 1 ? "//" : M.slice(0, T);
  },
  basename: function(M, x) {
    if (x !== void 0 && typeof x != "string") throw new TypeError('"ext" argument must be a string');
    assertPath(M);
    var $ = 0, T = -1, S = !0, D;
    if (x !== void 0 && x.length > 0 && x.length <= M.length) {
      if (x.length === M.length && x === M) return "";
      var F = x.length - 1, z = -1;
      for (D = M.length - 1; D >= 0; --D) {
        var Z = M.charCodeAt(D);
        if (Z === 47) {
          if (!S) {
            $ = D + 1;
            break;
          }
        } else
          z === -1 && (S = !1, z = D + 1), F >= 0 && (Z === x.charCodeAt(F) ? --F === -1 && (T = D) : (F = -1, T = z));
      }
      return $ === T ? T = z : T === -1 && (T = M.length), M.slice($, T);
    } else {
      for (D = M.length - 1; D >= 0; --D)
        if (M.charCodeAt(D) === 47) {
          if (!S) {
            $ = D + 1;
            break;
          }
        } else T === -1 && (S = !1, T = D + 1);
      return T === -1 ? "" : M.slice($, T);
    }
  },
  extname: function(M) {
    assertPath(M);
    for (var x = -1, $ = 0, T = -1, S = !0, D = 0, F = M.length - 1; F >= 0; --F) {
      var z = M.charCodeAt(F);
      if (z === 47) {
        if (!S) {
          $ = F + 1;
          break;
        }
        continue;
      }
      T === -1 && (S = !1, T = F + 1), z === 46 ? x === -1 ? x = F : D !== 1 && (D = 1) : x !== -1 && (D = -1);
    }
    return x === -1 || T === -1 || // We saw a non-dot character immediately before the dot
    D === 0 || // The (right-most) trimmed path component is exactly '..'
    D === 1 && x === T - 1 && x === $ + 1 ? "" : M.slice(x, T);
  },
  format: function(M) {
    if (M === null || typeof M != "object")
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof M);
    return _format("/", M);
  },
  parse: function(M) {
    assertPath(M);
    var x = { root: "", dir: "", base: "", ext: "", name: "" };
    if (M.length === 0) return x;
    var $ = M.charCodeAt(0), T = $ === 47, S;
    T ? (x.root = "/", S = 1) : S = 0;
    for (var D = -1, F = 0, z = -1, Z = !0, H = M.length - 1, V = 0; H >= S; --H) {
      if ($ = M.charCodeAt(H), $ === 47) {
        if (!Z) {
          F = H + 1;
          break;
        }
        continue;
      }
      z === -1 && (Z = !1, z = H + 1), $ === 46 ? D === -1 ? D = H : V !== 1 && (V = 1) : D !== -1 && (V = -1);
    }
    return D === -1 || z === -1 || // We saw a non-dot character immediately before the dot
    V === 0 || // The (right-most) trimmed path component is exactly '..'
    V === 1 && D === z - 1 && D === F + 1 ? z !== -1 && (F === 0 && T ? x.base = x.name = M.slice(1, z) : x.base = x.name = M.slice(F, z)) : (F === 0 && T ? (x.name = M.slice(1, D), x.base = M.slice(1, z)) : (x.name = M.slice(F, D), x.base = M.slice(F, z)), x.ext = M.slice(D, z)), F > 0 ? x.dir = M.slice(0, F - 1) : T && (x.dir = "/"), x;
  },
  sep: "/",
  delimiter: ":",
  win32: null,
  posix: null
};
posix.posix = posix;
var pathBrowserify = posix;
const keyConcat = (w, [M, x]) => typeof x == "string" ? (w[M] ?? (w[M] = x), w) : (Object.entries(x).forEach(([$, T]) => keyConcat(w, [`${M}|${$}`, T])), w), flatKeys = (w, M = {}) => Object.entries(w).reduce(keyConcat, M), loadFlat = ({ directory: w, fileName: M }) => {
  const x = pathBrowserify.join(w, M);
  assert$j(empty_1.existsSync(x), `Invalid Path: ${pathBrowserify.resolve(x)}`);
  const $ = empty_1.readFileSync(x, { encoding: "utf-8" }), T = JSON.parse($);
  return flatKeys(T);
}, list = (w) => empty_1.readdirSync(pathBrowserify.normalize(w)).filter((M) => M !== "en.json" && M.includes(".js")), locale$1 = {
  json: {
    loadFlat,
    list
  }
}, getHttpHandlerExtensionConfiguration = (w) => ({
  setHttpHandler(M) {
    w.httpHandler = M;
  },
  httpHandler() {
    return w.httpHandler;
  },
  updateHttpClientConfig(M, x) {
    var $;
    ($ = w.httpHandler) == null || $.updateHttpClientConfig(M, x);
  },
  httpHandlerConfigs() {
    return w.httpHandler.httpHandlerConfigs();
  }
}), resolveHttpHandlerRuntimeConfig = (w) => ({
  httpHandler: w.httpHandler()
});
var HttpAuthLocation;
(function(w) {
  w.HEADER = "header", w.QUERY = "query";
})(HttpAuthLocation || (HttpAuthLocation = {}));
var HttpApiKeyAuthLocation;
(function(w) {
  w.HEADER = "header", w.QUERY = "query";
})(HttpApiKeyAuthLocation || (HttpApiKeyAuthLocation = {}));
var EndpointURLScheme;
(function(w) {
  w.HTTP = "http", w.HTTPS = "https";
})(EndpointURLScheme || (EndpointURLScheme = {}));
var AlgorithmId;
(function(w) {
  w.MD5 = "md5", w.CRC32 = "crc32", w.CRC32C = "crc32c", w.SHA1 = "sha1", w.SHA256 = "sha256";
})(AlgorithmId || (AlgorithmId = {}));
var FieldPosition;
(function(w) {
  w[w.HEADER = 0] = "HEADER", w[w.TRAILER = 1] = "TRAILER";
})(FieldPosition || (FieldPosition = {}));
const SMITHY_CONTEXT_KEY = "__smithy_context";
var IniSectionType;
(function(w) {
  w.PROFILE = "profile", w.SSO_SESSION = "sso-session", w.SERVICES = "services";
})(IniSectionType || (IniSectionType = {}));
var RequestHandlerProtocol;
(function(w) {
  w.HTTP_0_9 = "http/0.9", w.HTTP_1_0 = "http/1.0", w.TDS_8_0 = "tds/8.0";
})(RequestHandlerProtocol || (RequestHandlerProtocol = {}));
class HttpRequest {
  constructor(M) {
    this.method = M.method || "GET", this.hostname = M.hostname || "localhost", this.port = M.port, this.query = M.query || {}, this.headers = M.headers || {}, this.body = M.body, this.protocol = M.protocol ? M.protocol.slice(-1) !== ":" ? `${M.protocol}:` : M.protocol : "https:", this.path = M.path ? M.path.charAt(0) !== "/" ? `/${M.path}` : M.path : "/", this.username = M.username, this.password = M.password, this.fragment = M.fragment;
  }
  static clone(M) {
    const x = new HttpRequest({
      ...M,
      headers: { ...M.headers }
    });
    return x.query && (x.query = cloneQuery(x.query)), x;
  }
  static isInstance(M) {
    if (!M)
      return !1;
    const x = M;
    return "method" in x && "protocol" in x && "hostname" in x && "path" in x && typeof x.query == "object" && typeof x.headers == "object";
  }
  clone() {
    return HttpRequest.clone(this);
  }
}
function cloneQuery(w) {
  return Object.keys(w).reduce((M, x) => {
    const $ = w[x];
    return {
      ...M,
      [x]: Array.isArray($) ? [...$] : $
    };
  }, {});
}
class HttpResponse {
  constructor(M) {
    this.statusCode = M.statusCode, this.reason = M.reason, this.headers = M.headers || {}, this.body = M.body;
  }
  static isInstance(M) {
    if (!M)
      return !1;
    const x = M;
    return typeof x.statusCode == "number" && typeof x.headers == "object";
  }
}
function resolveHostHeaderConfig(w) {
  return w;
}
const hostHeaderMiddleware = (w) => (M) => async (x) => {
  if (!HttpRequest.isInstance(x.request))
    return M(x);
  const { request: $ } = x, { handlerProtocol: T = "" } = w.requestHandler.metadata || {};
  if (T.indexOf("h2") >= 0 && !$.headers[":authority"])
    delete $.headers.host, $.headers[":authority"] = $.hostname + ($.port ? ":" + $.port : "");
  else if (!$.headers.host) {
    let S = $.hostname;
    $.port != null && (S += `:${$.port}`), $.headers.host = S;
  }
  return M(x);
}, hostHeaderMiddlewareOptions = {
  name: "hostHeaderMiddleware",
  step: "build",
  priority: "low",
  tags: ["HOST"],
  override: !0
}, getHostHeaderPlugin = (w) => ({
  applyToStack: (M) => {
    M.add(hostHeaderMiddleware(w), hostHeaderMiddlewareOptions);
  }
}), loggerMiddleware = () => (w, M) => async (x) => {
  var $, T;
  try {
    const S = await w(x), { clientName: D, commandName: F, logger: z, dynamoDbDocumentClientOptions: Z = {} } = M, { overrideInputFilterSensitiveLog: H, overrideOutputFilterSensitiveLog: V } = Z, X = H ?? M.inputFilterSensitiveLog, Q = V ?? M.outputFilterSensitiveLog, { $metadata: fe, ...ce } = S.output;
    return ($ = z == null ? void 0 : z.info) == null || $.call(z, {
      clientName: D,
      commandName: F,
      input: X(x.input),
      output: Q(ce),
      metadata: fe
    }), S;
  } catch (S) {
    const { clientName: D, commandName: F, logger: z, dynamoDbDocumentClientOptions: Z = {} } = M, { overrideInputFilterSensitiveLog: H } = Z, V = H ?? M.inputFilterSensitiveLog;
    throw (T = z == null ? void 0 : z.error) == null || T.call(z, {
      clientName: D,
      commandName: F,
      input: V(x.input),
      error: S,
      metadata: S.$metadata
    }), S;
  }
}, loggerMiddlewareOptions = {
  name: "loggerMiddleware",
  tags: ["LOGGER"],
  step: "initialize",
  override: !0
}, getLoggerPlugin = (w) => ({
  applyToStack: (M) => {
    M.add(loggerMiddleware(), loggerMiddlewareOptions);
  }
}), TRACE_ID_HEADER_NAME = "X-Amzn-Trace-Id", ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME", ENV_TRACE_ID = "_X_AMZN_TRACE_ID", recursionDetectionMiddleware = (w) => (M) => async (x) => {
  const { request: $ } = x;
  if (!HttpRequest.isInstance($) || w.runtime !== "node")
    return M(x);
  const T = Object.keys($.headers ?? {}).find((z) => z.toLowerCase() === TRACE_ID_HEADER_NAME.toLowerCase()) ?? TRACE_ID_HEADER_NAME;
  if ($.headers.hasOwnProperty(T))
    return M(x);
  const S = process$1.env[ENV_LAMBDA_FUNCTION_NAME], D = process$1.env[ENV_TRACE_ID], F = (z) => typeof z == "string" && z.length > 0;
  return F(S) && F(D) && ($.headers[TRACE_ID_HEADER_NAME] = D), M({
    ...x,
    request: $
  });
}, addRecursionDetectionMiddlewareOptions = {
  step: "build",
  tags: ["RECURSION_DETECTION"],
  name: "recursionDetectionMiddleware",
  override: !0,
  priority: "low"
}, getRecursionDetectionPlugin = (w) => ({
  applyToStack: (M) => {
    M.add(recursionDetectionMiddleware(w), addRecursionDetectionMiddlewareOptions);
  }
}), getSmithyContext = (w) => w[SMITHY_CONTEXT_KEY] || (w[SMITHY_CONTEXT_KEY] = {}), normalizeProvider$1 = (w) => {
  if (typeof w == "function")
    return w;
  const M = Promise.resolve(w);
  return () => M;
}, resolveAuthOptions = (w, M) => {
  if (!M || M.length === 0)
    return w;
  const x = [];
  for (const $ of M)
    for (const T of w)
      T.schemeId.split("#")[1] === $ && x.push(T);
  for (const $ of w)
    x.find(({ schemeId: T }) => T === $.schemeId) || x.push($);
  return x;
};
function convertHttpAuthSchemesToMap(w) {
  const M = /* @__PURE__ */ new Map();
  for (const x of w)
    M.set(x.schemeId, x);
  return M;
}
const httpAuthSchemeMiddleware = (w, M) => (x, $) => async (T) => {
  var V;
  const S = w.httpAuthSchemeProvider(await M.httpAuthSchemeParametersProvider(w, $, T.input)), D = w.authSchemePreference ? await w.authSchemePreference() : [], F = resolveAuthOptions(S, D), z = convertHttpAuthSchemesToMap(w.httpAuthSchemes), Z = getSmithyContext($), H = [];
  for (const X of F) {
    const Q = z.get(X.schemeId);
    if (!Q) {
      H.push(`HttpAuthScheme \`${X.schemeId}\` was not enabled for this service.`);
      continue;
    }
    const fe = Q.identityProvider(await M.identityProviderConfigProvider(w));
    if (!fe) {
      H.push(`HttpAuthScheme \`${X.schemeId}\` did not have an IdentityProvider configured.`);
      continue;
    }
    const { identityProperties: ce = {}, signingProperties: me = {} } = ((V = X.propertiesExtractor) == null ? void 0 : V.call(X, w, $)) || {};
    X.identityProperties = Object.assign(X.identityProperties || {}, ce), X.signingProperties = Object.assign(X.signingProperties || {}, me), Z.selectedHttpAuthScheme = {
      httpAuthOption: X,
      identity: await fe(X.identityProperties),
      signer: Q.signer
    };
    break;
  }
  if (!Z.selectedHttpAuthScheme)
    throw new Error(H.join(`
`));
  return x(T);
}, httpAuthSchemeEndpointRuleSetMiddlewareOptions = {
  step: "serialize",
  tags: ["HTTP_AUTH_SCHEME"],
  name: "httpAuthSchemeMiddleware",
  override: !0,
  relation: "before",
  toMiddleware: "endpointV2Middleware"
}, getHttpAuthSchemeEndpointRuleSetPlugin = (w, { httpAuthSchemeParametersProvider: M, identityProviderConfigProvider: x }) => ({
  applyToStack: ($) => {
    $.addRelativeTo(httpAuthSchemeMiddleware(w, {
      httpAuthSchemeParametersProvider: M,
      identityProviderConfigProvider: x
    }), httpAuthSchemeEndpointRuleSetMiddlewareOptions);
  }
}), deserializerMiddleware = (w, M) => (x, $) => async (T) => {
  var D, F, z, Z;
  const { response: S } = await x(T);
  try {
    const H = await M(S, w);
    return {
      response: S,
      output: H
    };
  } catch (H) {
    if (Object.defineProperty(H, "$response", {
      value: S
    }), !("$metadata" in H)) {
      const V = "Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.";
      try {
        H.message += `
  ` + V;
      } catch {
        !$.logger || ((F = (D = $.logger) == null ? void 0 : D.constructor) == null ? void 0 : F.name) === "NoOpLogger" ? console.warn(V) : (Z = (z = $.logger) == null ? void 0 : z.warn) == null || Z.call(z, V);
      }
      typeof H.$responseBodyText < "u" && H.$response && (H.$response.body = H.$responseBodyText);
      try {
        if (HttpResponse.isInstance(S)) {
          const { headers: X = {} } = S, Q = Object.entries(X);
          H.$metadata = {
            httpStatusCode: S.statusCode,
            requestId: findHeader(/^x-[\w-]+-request-?id$/, Q),
            extendedRequestId: findHeader(/^x-[\w-]+-id-2$/, Q),
            cfId: findHeader(/^x-[\w-]+-cf-id$/, Q)
          };
        }
      } catch {
      }
    }
    throw H;
  }
}, findHeader = (w, M) => (M.find(([x]) => x.match(w)) || [void 0, void 0])[1], serializerMiddleware = (w, M) => (x, $) => async (T) => {
  var F;
  const S = (F = $.endpointV2) != null && F.url && w.urlParser ? async () => w.urlParser($.endpointV2.url) : w.endpoint;
  if (!S)
    throw new Error("No valid endpoint provider available.");
  const D = await M(T.input, { ...w, endpoint: S });
  return x({
    ...T,
    request: D
  });
}, deserializerMiddlewareOption = {
  name: "deserializerMiddleware",
  step: "deserialize",
  tags: ["DESERIALIZER"],
  override: !0
}, serializerMiddlewareOption = {
  name: "serializerMiddleware",
  step: "serialize",
  tags: ["SERIALIZER"],
  override: !0
};
function getSerdePlugin(w, M, x) {
  return {
    applyToStack: ($) => {
      $.add(deserializerMiddleware(w, x), deserializerMiddlewareOption), $.add(serializerMiddleware(w, M), serializerMiddlewareOption);
    }
  };
}
serializerMiddlewareOption.name;
const defaultErrorHandler = (w) => (M) => {
  throw M;
}, defaultSuccessHandler = (w, M) => {
}, httpSigningMiddleware = (w) => (M, x) => async ($) => {
  if (!HttpRequest.isInstance($.request))
    return M($);
  const S = getSmithyContext(x).selectedHttpAuthScheme;
  if (!S)
    throw new Error("No HttpAuthScheme was selected: unable to sign request");
  const { httpAuthOption: { signingProperties: D = {} }, identity: F, signer: z } = S, Z = await M({
    ...$,
    request: await z.sign($.request, F, D)
  }).catch((z.errorHandler || defaultErrorHandler)(D));
  return (z.successHandler || defaultSuccessHandler)(Z.response, D), Z;
}, httpSigningMiddlewareOptions = {
  step: "finalizeRequest",
  tags: ["HTTP_SIGNING"],
  name: "httpSigningMiddleware",
  aliases: ["apiKeyMiddleware", "tokenMiddleware", "awsAuthMiddleware"],
  override: !0,
  relation: "after",
  toMiddleware: "retryMiddleware"
}, getHttpSigningPlugin = (w) => ({
  applyToStack: (M) => {
    M.addRelativeTo(httpSigningMiddleware(), httpSigningMiddlewareOptions);
  }
}), normalizeProvider = (w) => {
  if (typeof w == "function")
    return w;
  const M = Promise.resolve(w);
  return () => M;
}, alphabetByEncoding = {}, alphabetByValue = new Array(64);
for (let w = 0, M = 65, x = 90; w + M <= x; w++) {
  const $ = String.fromCharCode(w + M);
  alphabetByEncoding[$] = w, alphabetByValue[w] = $;
}
for (let w = 0, M = 97, x = 122; w + M <= x; w++) {
  const $ = String.fromCharCode(w + M), T = w + 26;
  alphabetByEncoding[$] = T, alphabetByValue[T] = $;
}
for (let w = 0; w < 10; w++) {
  alphabetByEncoding[w.toString(10)] = w + 52;
  const M = w.toString(10), x = w + 52;
  alphabetByEncoding[M] = x, alphabetByValue[x] = M;
}
alphabetByEncoding["+"] = 62;
alphabetByValue[62] = "+";
alphabetByEncoding["/"] = 63;
alphabetByValue[63] = "/";
const bitsPerLetter = 6, bitsPerByte = 8, maxLetterValue = 63, fromBase64 = (w) => {
  let M = w.length / 4 * 3;
  w.slice(-2) === "==" ? M -= 2 : w.slice(-1) === "=" && M--;
  const x = new ArrayBuffer(M), $ = new DataView(x);
  for (let T = 0; T < w.length; T += 4) {
    let S = 0, D = 0;
    for (let Z = T, H = T + 3; Z <= H; Z++)
      if (w[Z] !== "=") {
        if (!(w[Z] in alphabetByEncoding))
          throw new TypeError(`Invalid character ${w[Z]} in base64 string.`);
        S |= alphabetByEncoding[w[Z]] << (H - Z) * bitsPerLetter, D += bitsPerLetter;
      } else
        S >>= bitsPerLetter;
    const F = T / 4 * 3;
    S >>= D % bitsPerByte;
    const z = Math.floor(D / bitsPerByte);
    for (let Z = 0; Z < z; Z++) {
      const H = (z - Z - 1) * bitsPerByte;
      $.setUint8(F + Z, (S & 255 << H) >> H);
    }
  }
  return new Uint8Array(x);
}, fromUtf8$2 = (w) => new TextEncoder().encode(w), toUint8Array = (w) => typeof w == "string" ? fromUtf8$2(w) : ArrayBuffer.isView(w) ? new Uint8Array(w.buffer, w.byteOffset, w.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(w), toUtf8 = (w) => {
  if (typeof w == "string")
    return w;
  if (typeof w != "object" || typeof w.byteOffset != "number" || typeof w.byteLength != "number")
    throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
  return new TextDecoder("utf-8").decode(w);
};
function toBase64(w) {
  let M;
  typeof w == "string" ? M = fromUtf8$2(w) : M = w;
  const x = typeof M == "object" && typeof M.length == "number", $ = typeof M == "object" && typeof M.byteOffset == "number" && typeof M.byteLength == "number";
  if (!x && !$)
    throw new Error("@smithy/util-base64: toBase64 encoder function only accepts string | Uint8Array.");
  let T = "";
  for (let S = 0; S < M.length; S += 3) {
    let D = 0, F = 0;
    for (let Z = S, H = Math.min(S + 3, M.length); Z < H; Z++)
      D |= M[Z] << (H - Z - 1) * bitsPerByte, F += bitsPerByte;
    const z = Math.ceil(F / bitsPerLetter);
    D <<= z * bitsPerLetter - F;
    for (let Z = 1; Z <= z; Z++) {
      const H = (z - Z) * bitsPerLetter;
      T += alphabetByValue[(D & maxLetterValue << H) >> H];
    }
    T += "==".slice(0, 4 - z);
  }
  return T;
}
function transformToString(w, M = "utf-8") {
  return M === "base64" ? toBase64(w) : toUtf8(w);
}
function transformFromString(w, M) {
  return M === "base64" ? Uint8ArrayBlobAdapter.mutate(fromBase64(w)) : Uint8ArrayBlobAdapter.mutate(fromUtf8$2(w));
}
class Uint8ArrayBlobAdapter extends Uint8Array {
  static fromString(M, x = "utf-8") {
    switch (typeof M) {
      case "string":
        return transformFromString(M, x);
      default:
        throw new Error(`Unsupported conversion from ${typeof M} to Uint8ArrayBlobAdapter.`);
    }
  }
  static mutate(M) {
    return Object.setPrototypeOf(M, Uint8ArrayBlobAdapter.prototype), M;
  }
  transformToString(M = "utf-8") {
    return transformToString(this, M);
  }
}
var dist = {};
(function(w) {
  Object.defineProperties(w, { __esModule: { value: !0 }, [Symbol.toStringTag]: { value: "Module" } });
  var M = {}, x = {};
  x.byteLength = H, x.toByteArray = X, x.fromByteArray = ce;
  for (var $ = [], T = [], S = typeof Uint8Array < "u" ? Uint8Array : Array, D = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", F = 0, z = D.length; F < z; ++F)
    $[F] = D[F], T[D.charCodeAt(F)] = F;
  T[45] = 62, T[95] = 63;
  function Z(ne) {
    var ge = ne.length;
    if (ge % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var pe = ne.indexOf("=");
    pe === -1 && (pe = ge);
    var $e = pe === ge ? 0 : 4 - pe % 4;
    return [pe, $e];
  }
  function H(ne) {
    var ge = Z(ne), pe = ge[0], $e = ge[1];
    return (pe + $e) * 3 / 4 - $e;
  }
  function V(ne, ge, pe) {
    return (ge + pe) * 3 / 4 - pe;
  }
  function X(ne) {
    var ge, pe = Z(ne), $e = pe[0], Re = pe[1], Pe = new S(V(ne, $e, Re)), Oe = 0, xe = Re > 0 ? $e - 4 : $e, rt;
    for (rt = 0; rt < xe; rt += 4)
      ge = T[ne.charCodeAt(rt)] << 18 | T[ne.charCodeAt(rt + 1)] << 12 | T[ne.charCodeAt(rt + 2)] << 6 | T[ne.charCodeAt(rt + 3)], Pe[Oe++] = ge >> 16 & 255, Pe[Oe++] = ge >> 8 & 255, Pe[Oe++] = ge & 255;
    return Re === 2 && (ge = T[ne.charCodeAt(rt)] << 2 | T[ne.charCodeAt(rt + 1)] >> 4, Pe[Oe++] = ge & 255), Re === 1 && (ge = T[ne.charCodeAt(rt)] << 10 | T[ne.charCodeAt(rt + 1)] << 4 | T[ne.charCodeAt(rt + 2)] >> 2, Pe[Oe++] = ge >> 8 & 255, Pe[Oe++] = ge & 255), Pe;
  }
  function Q(ne) {
    return $[ne >> 18 & 63] + $[ne >> 12 & 63] + $[ne >> 6 & 63] + $[ne & 63];
  }
  function fe(ne, ge, pe) {
    for (var $e, Re = [], Pe = ge; Pe < pe; Pe += 3)
      $e = (ne[Pe] << 16 & 16711680) + (ne[Pe + 1] << 8 & 65280) + (ne[Pe + 2] & 255), Re.push(Q($e));
    return Re.join("");
  }
  function ce(ne) {
    for (var ge, pe = ne.length, $e = pe % 3, Re = [], Pe = 16383, Oe = 0, xe = pe - $e; Oe < xe; Oe += Pe)
      Re.push(fe(ne, Oe, Oe + Pe > xe ? xe : Oe + Pe));
    return $e === 1 ? (ge = ne[pe - 1], Re.push(
      $[ge >> 2] + $[ge << 4 & 63] + "=="
    )) : $e === 2 && (ge = (ne[pe - 2] << 8) + ne[pe - 1], Re.push(
      $[ge >> 10] + $[ge >> 4 & 63] + $[ge << 2 & 63] + "="
    )), Re.join("");
  }
  var me = {};
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  me.read = function(ne, ge, pe, $e, Re) {
    var Pe, Oe, xe = Re * 8 - $e - 1, rt = (1 << xe) - 1, N = rt >> 1, y = -7, E = pe ? Re - 1 : 0, A = pe ? -1 : 1, B = ne[ge + E];
    for (E += A, Pe = B & (1 << -y) - 1, B >>= -y, y += xe; y > 0; Pe = Pe * 256 + ne[ge + E], E += A, y -= 8)
      ;
    for (Oe = Pe & (1 << -y) - 1, Pe >>= -y, y += $e; y > 0; Oe = Oe * 256 + ne[ge + E], E += A, y -= 8)
      ;
    if (Pe === 0)
      Pe = 1 - N;
    else {
      if (Pe === rt)
        return Oe ? NaN : (B ? -1 : 1) * (1 / 0);
      Oe = Oe + Math.pow(2, $e), Pe = Pe - N;
    }
    return (B ? -1 : 1) * Oe * Math.pow(2, Pe - $e);
  }, me.write = function(ne, ge, pe, $e, Re, Pe) {
    var Oe, xe, rt, N = Pe * 8 - Re - 1, y = (1 << N) - 1, E = y >> 1, A = Re === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, B = $e ? 0 : Pe - 1, O = $e ? 1 : -1, C = ge < 0 || ge === 0 && 1 / ge < 0 ? 1 : 0;
    for (ge = Math.abs(ge), isNaN(ge) || ge === 1 / 0 ? (xe = isNaN(ge) ? 1 : 0, Oe = y) : (Oe = Math.floor(Math.log(ge) / Math.LN2), ge * (rt = Math.pow(2, -Oe)) < 1 && (Oe--, rt *= 2), Oe + E >= 1 ? ge += A / rt : ge += A * Math.pow(2, 1 - E), ge * rt >= 2 && (Oe++, rt /= 2), Oe + E >= y ? (xe = 0, Oe = y) : Oe + E >= 1 ? (xe = (ge * rt - 1) * Math.pow(2, Re), Oe = Oe + E) : (xe = ge * Math.pow(2, E - 1) * Math.pow(2, Re), Oe = 0)); Re >= 8; ne[pe + B] = xe & 255, B += O, xe /= 256, Re -= 8)
      ;
    for (Oe = Oe << Re | xe, N += Re; N > 0; ne[pe + B] = Oe & 255, B += O, Oe /= 256, N -= 8)
      ;
    ne[pe + B - O] |= C * 128;
  };
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  (function(ne) {
    const ge = x, pe = me, $e = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    ne.Buffer = y, ne.SlowBuffer = Y, ne.INSPECT_MAX_BYTES = 50;
    const Re = 2147483647;
    ne.kMaxLength = Re;
    const { Uint8Array: Pe, ArrayBuffer: Oe, SharedArrayBuffer: xe } = globalThis;
    y.TYPED_ARRAY_SUPPORT = rt(), !y.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
    function rt() {
      try {
        const se = new Pe(1), J = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(J, Pe.prototype), Object.setPrototypeOf(se, J), se.foo() === 42;
      } catch {
        return !1;
      }
    }
    Object.defineProperty(y.prototype, "parent", {
      enumerable: !0,
      get: function() {
        if (y.isBuffer(this))
          return this.buffer;
      }
    }), Object.defineProperty(y.prototype, "offset", {
      enumerable: !0,
      get: function() {
        if (y.isBuffer(this))
          return this.byteOffset;
      }
    });
    function N(se) {
      if (se > Re)
        throw new RangeError('The value "' + se + '" is invalid for option "size"');
      const J = new Pe(se);
      return Object.setPrototypeOf(J, y.prototype), J;
    }
    function y(se, J, ie) {
      if (typeof se == "number") {
        if (typeof J == "string")
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        return O(se);
      }
      return E(se, J, ie);
    }
    y.poolSize = 8192;
    function E(se, J, ie) {
      if (typeof se == "string")
        return C(se, J);
      if (Oe.isView(se))
        return P(se);
      if (se == null)
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof se
        );
      if (Ye(se, Oe) || se && Ye(se.buffer, Oe) || typeof xe < "u" && (Ye(se, xe) || se && Ye(se.buffer, xe)))
        return _(se, J, ie);
      if (typeof se == "number")
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      const le = se.valueOf && se.valueOf();
      if (le != null && le !== se)
        return y.from(le, J, ie);
      const we = I(se);
      if (we) return we;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof se[Symbol.toPrimitive] == "function")
        return y.from(se[Symbol.toPrimitive]("string"), J, ie);
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof se
      );
    }
    y.from = function(se, J, ie) {
      return E(se, J, ie);
    }, Object.setPrototypeOf(y.prototype, Pe.prototype), Object.setPrototypeOf(y, Pe);
    function A(se) {
      if (typeof se != "number")
        throw new TypeError('"size" argument must be of type number');
      if (se < 0)
        throw new RangeError('The value "' + se + '" is invalid for option "size"');
    }
    function B(se, J, ie) {
      return A(se), se <= 0 ? N(se) : J !== void 0 ? typeof ie == "string" ? N(se).fill(J, ie) : N(se).fill(J) : N(se);
    }
    y.alloc = function(se, J, ie) {
      return B(se, J, ie);
    };
    function O(se) {
      return A(se), N(se < 0 ? 0 : U(se) | 0);
    }
    y.allocUnsafe = function(se) {
      return O(se);
    }, y.allocUnsafeSlow = function(se) {
      return O(se);
    };
    function C(se, J) {
      if ((typeof J != "string" || J === "") && (J = "utf8"), !y.isEncoding(J))
        throw new TypeError("Unknown encoding: " + J);
      const ie = te(se, J) | 0;
      let le = N(ie);
      const we = le.write(se, J);
      return we !== ie && (le = le.slice(0, we)), le;
    }
    function L(se) {
      const J = se.length < 0 ? 0 : U(se.length) | 0, ie = N(J);
      for (let le = 0; le < J; le += 1)
        ie[le] = se[le] & 255;
      return ie;
    }
    function P(se) {
      if (Ye(se, Pe)) {
        const J = new Pe(se);
        return _(J.buffer, J.byteOffset, J.byteLength);
      }
      return L(se);
    }
    function _(se, J, ie) {
      if (J < 0 || se.byteLength < J)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (se.byteLength < J + (ie || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      let le;
      return J === void 0 && ie === void 0 ? le = new Pe(se) : ie === void 0 ? le = new Pe(se, J) : le = new Pe(se, J, ie), Object.setPrototypeOf(le, y.prototype), le;
    }
    function I(se) {
      if (y.isBuffer(se)) {
        const J = U(se.length) | 0, ie = N(J);
        return ie.length === 0 || se.copy(ie, 0, 0, J), ie;
      }
      if (se.length !== void 0)
        return typeof se.length != "number" || gt(se.length) ? N(0) : L(se);
      if (se.type === "Buffer" && Array.isArray(se.data))
        return L(se.data);
    }
    function U(se) {
      if (se >= Re)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Re.toString(16) + " bytes");
      return se | 0;
    }
    function Y(se) {
      return +se != se && (se = 0), y.alloc(+se);
    }
    y.isBuffer = function(J) {
      return J != null && J._isBuffer === !0 && J !== y.prototype;
    }, y.compare = function(J, ie) {
      if (Ye(J, Pe) && (J = y.from(J, J.offset, J.byteLength)), Ye(ie, Pe) && (ie = y.from(ie, ie.offset, ie.byteLength)), !y.isBuffer(J) || !y.isBuffer(ie))
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      if (J === ie) return 0;
      let le = J.length, we = ie.length;
      for (let Ce = 0, Ee = Math.min(le, we); Ce < Ee; ++Ce)
        if (J[Ce] !== ie[Ce]) {
          le = J[Ce], we = ie[Ce];
          break;
        }
      return le < we ? -1 : we < le ? 1 : 0;
    }, y.isEncoding = function(J) {
      switch (String(J).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1;
      }
    }, y.concat = function(J, ie) {
      if (!Array.isArray(J))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (J.length === 0)
        return y.alloc(0);
      let le;
      if (ie === void 0)
        for (ie = 0, le = 0; le < J.length; ++le)
          ie += J[le].length;
      const we = y.allocUnsafe(ie);
      let Ce = 0;
      for (le = 0; le < J.length; ++le) {
        let Ee = J[le];
        if (Ye(Ee, Pe))
          Ce + Ee.length > we.length ? (y.isBuffer(Ee) || (Ee = y.from(Ee)), Ee.copy(we, Ce)) : Pe.prototype.set.call(
            we,
            Ee,
            Ce
          );
        else if (y.isBuffer(Ee))
          Ee.copy(we, Ce);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        Ce += Ee.length;
      }
      return we;
    };
    function te(se, J) {
      if (y.isBuffer(se))
        return se.length;
      if (Oe.isView(se) || Ye(se, Oe))
        return se.byteLength;
      if (typeof se != "string")
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof se
        );
      const ie = se.length, le = arguments.length > 2 && arguments[2] === !0;
      if (!le && ie === 0) return 0;
      let we = !1;
      for (; ; )
        switch (J) {
          case "ascii":
          case "latin1":
          case "binary":
            return ie;
          case "utf8":
          case "utf-8":
            return dt(se).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ie * 2;
          case "hex":
            return ie >>> 1;
          case "base64":
            return yt(se).length;
          default:
            if (we)
              return le ? -1 : dt(se).length;
            J = ("" + J).toLowerCase(), we = !0;
        }
    }
    y.byteLength = te;
    function oe(se, J, ie) {
      let le = !1;
      if ((J === void 0 || J < 0) && (J = 0), J > this.length || ((ie === void 0 || ie > this.length) && (ie = this.length), ie <= 0) || (ie >>>= 0, J >>>= 0, ie <= J))
        return "";
      for (se || (se = "utf8"); ; )
        switch (se) {
          case "hex":
            return lt(this, J, ie);
          case "utf8":
          case "utf-8":
            return Ie(this, J, ie);
          case "ascii":
            return ke(this, J, ie);
          case "latin1":
          case "binary":
            return Se(this, J, ie);
          case "base64":
            return Qe(this, J, ie);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return qe(this, J, ie);
          default:
            if (le) throw new TypeError("Unknown encoding: " + se);
            se = (se + "").toLowerCase(), le = !0;
        }
    }
    y.prototype._isBuffer = !0;
    function re(se, J, ie) {
      const le = se[J];
      se[J] = se[ie], se[ie] = le;
    }
    y.prototype.swap16 = function() {
      const J = this.length;
      if (J % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (let ie = 0; ie < J; ie += 2)
        re(this, ie, ie + 1);
      return this;
    }, y.prototype.swap32 = function() {
      const J = this.length;
      if (J % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (let ie = 0; ie < J; ie += 4)
        re(this, ie, ie + 3), re(this, ie + 1, ie + 2);
      return this;
    }, y.prototype.swap64 = function() {
      const J = this.length;
      if (J % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let ie = 0; ie < J; ie += 8)
        re(this, ie, ie + 7), re(this, ie + 1, ie + 6), re(this, ie + 2, ie + 5), re(this, ie + 3, ie + 4);
      return this;
    }, y.prototype.toString = function() {
      const J = this.length;
      return J === 0 ? "" : arguments.length === 0 ? Ie(this, 0, J) : oe.apply(this, arguments);
    }, y.prototype.toLocaleString = y.prototype.toString, y.prototype.equals = function(J) {
      if (!y.isBuffer(J)) throw new TypeError("Argument must be a Buffer");
      return this === J ? !0 : y.compare(this, J) === 0;
    }, y.prototype.inspect = function() {
      let J = "";
      const ie = ne.INSPECT_MAX_BYTES;
      return J = this.toString("hex", 0, ie).replace(/(.{2})/g, "$1 ").trim(), this.length > ie && (J += " ... "), "<Buffer " + J + ">";
    }, $e && (y.prototype[$e] = y.prototype.inspect), y.prototype.compare = function(J, ie, le, we, Ce) {
      if (Ye(J, Pe) && (J = y.from(J, J.offset, J.byteLength)), !y.isBuffer(J))
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof J
        );
      if (ie === void 0 && (ie = 0), le === void 0 && (le = J ? J.length : 0), we === void 0 && (we = 0), Ce === void 0 && (Ce = this.length), ie < 0 || le > J.length || we < 0 || Ce > this.length)
        throw new RangeError("out of range index");
      if (we >= Ce && ie >= le)
        return 0;
      if (we >= Ce)
        return -1;
      if (ie >= le)
        return 1;
      if (ie >>>= 0, le >>>= 0, we >>>= 0, Ce >>>= 0, this === J) return 0;
      let Ee = Ce - we, Fe = le - ie;
      const ut = Math.min(Ee, Fe), Ne = this.slice(we, Ce), Ve = J.slice(ie, le);
      for (let ht = 0; ht < ut; ++ht)
        if (Ne[ht] !== Ve[ht]) {
          Ee = Ne[ht], Fe = Ve[ht];
          break;
        }
      return Ee < Fe ? -1 : Fe < Ee ? 1 : 0;
    };
    function ee(se, J, ie, le, we) {
      if (se.length === 0) return -1;
      if (typeof ie == "string" ? (le = ie, ie = 0) : ie > 2147483647 ? ie = 2147483647 : ie < -2147483648 && (ie = -2147483648), ie = +ie, gt(ie) && (ie = we ? 0 : se.length - 1), ie < 0 && (ie = se.length + ie), ie >= se.length) {
        if (we) return -1;
        ie = se.length - 1;
      } else if (ie < 0)
        if (we) ie = 0;
        else return -1;
      if (typeof J == "string" && (J = y.from(J, le)), y.isBuffer(J))
        return J.length === 0 ? -1 : ae(se, J, ie, le, we);
      if (typeof J == "number")
        return J = J & 255, typeof Pe.prototype.indexOf == "function" ? we ? Pe.prototype.indexOf.call(se, J, ie) : Pe.prototype.lastIndexOf.call(se, J, ie) : ae(se, [J], ie, le, we);
      throw new TypeError("val must be string, number or Buffer");
    }
    function ae(se, J, ie, le, we) {
      let Ce = 1, Ee = se.length, Fe = J.length;
      if (le !== void 0 && (le = String(le).toLowerCase(), le === "ucs2" || le === "ucs-2" || le === "utf16le" || le === "utf-16le")) {
        if (se.length < 2 || J.length < 2)
          return -1;
        Ce = 2, Ee /= 2, Fe /= 2, ie /= 2;
      }
      function ut(Ve, ht) {
        return Ce === 1 ? Ve[ht] : Ve.readUInt16BE(ht * Ce);
      }
      let Ne;
      if (we) {
        let Ve = -1;
        for (Ne = ie; Ne < Ee; Ne++)
          if (ut(se, Ne) === ut(J, Ve === -1 ? 0 : Ne - Ve)) {
            if (Ve === -1 && (Ve = Ne), Ne - Ve + 1 === Fe) return Ve * Ce;
          } else
            Ve !== -1 && (Ne -= Ne - Ve), Ve = -1;
      } else
        for (ie + Fe > Ee && (ie = Ee - Fe), Ne = ie; Ne >= 0; Ne--) {
          let Ve = !0;
          for (let ht = 0; ht < Fe; ht++)
            if (ut(se, Ne + ht) !== ut(J, ht)) {
              Ve = !1;
              break;
            }
          if (Ve) return Ne;
        }
      return -1;
    }
    y.prototype.includes = function(J, ie, le) {
      return this.indexOf(J, ie, le) !== -1;
    }, y.prototype.indexOf = function(J, ie, le) {
      return ee(this, J, ie, le, !0);
    }, y.prototype.lastIndexOf = function(J, ie, le) {
      return ee(this, J, ie, le, !1);
    };
    function ue(se, J, ie, le) {
      ie = Number(ie) || 0;
      const we = se.length - ie;
      le ? (le = Number(le), le > we && (le = we)) : le = we;
      const Ce = J.length;
      le > Ce / 2 && (le = Ce / 2);
      let Ee;
      for (Ee = 0; Ee < le; ++Ee) {
        const Fe = parseInt(J.substr(Ee * 2, 2), 16);
        if (gt(Fe)) return Ee;
        se[ie + Ee] = Fe;
      }
      return Ee;
    }
    function ye(se, J, ie, le) {
      return Ke(dt(J, se.length - ie), se, ie, le);
    }
    function ve(se, J, ie, le) {
      return Ke(ze(J), se, ie, le);
    }
    function he(se, J, ie, le) {
      return Ke(yt(J), se, ie, le);
    }
    function Me(se, J, ie, le) {
      return Ke(et(J, se.length - ie), se, ie, le);
    }
    y.prototype.write = function(J, ie, le, we) {
      if (ie === void 0)
        we = "utf8", le = this.length, ie = 0;
      else if (le === void 0 && typeof ie == "string")
        we = ie, le = this.length, ie = 0;
      else if (isFinite(ie))
        ie = ie >>> 0, isFinite(le) ? (le = le >>> 0, we === void 0 && (we = "utf8")) : (we = le, le = void 0);
      else
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      const Ce = this.length - ie;
      if ((le === void 0 || le > Ce) && (le = Ce), J.length > 0 && (le < 0 || ie < 0) || ie > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      we || (we = "utf8");
      let Ee = !1;
      for (; ; )
        switch (we) {
          case "hex":
            return ue(this, J, ie, le);
          case "utf8":
          case "utf-8":
            return ye(this, J, ie, le);
          case "ascii":
          case "latin1":
          case "binary":
            return ve(this, J, ie, le);
          case "base64":
            return he(this, J, ie, le);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return Me(this, J, ie, le);
          default:
            if (Ee) throw new TypeError("Unknown encoding: " + we);
            we = ("" + we).toLowerCase(), Ee = !0;
        }
    }, y.prototype.toJSON = function() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function Qe(se, J, ie) {
      return J === 0 && ie === se.length ? ge.fromByteArray(se) : ge.fromByteArray(se.slice(J, ie));
    }
    function Ie(se, J, ie) {
      ie = Math.min(se.length, ie);
      const le = [];
      let we = J;
      for (; we < ie; ) {
        const Ce = se[we];
        let Ee = null, Fe = Ce > 239 ? 4 : Ce > 223 ? 3 : Ce > 191 ? 2 : 1;
        if (we + Fe <= ie) {
          let ut, Ne, Ve, ht;
          switch (Fe) {
            case 1:
              Ce < 128 && (Ee = Ce);
              break;
            case 2:
              ut = se[we + 1], (ut & 192) === 128 && (ht = (Ce & 31) << 6 | ut & 63, ht > 127 && (Ee = ht));
              break;
            case 3:
              ut = se[we + 1], Ne = se[we + 2], (ut & 192) === 128 && (Ne & 192) === 128 && (ht = (Ce & 15) << 12 | (ut & 63) << 6 | Ne & 63, ht > 2047 && (ht < 55296 || ht > 57343) && (Ee = ht));
              break;
            case 4:
              ut = se[we + 1], Ne = se[we + 2], Ve = se[we + 3], (ut & 192) === 128 && (Ne & 192) === 128 && (Ve & 192) === 128 && (ht = (Ce & 15) << 18 | (ut & 63) << 12 | (Ne & 63) << 6 | Ve & 63, ht > 65535 && ht < 1114112 && (Ee = ht));
          }
        }
        Ee === null ? (Ee = 65533, Fe = 1) : Ee > 65535 && (Ee -= 65536, le.push(Ee >>> 10 & 1023 | 55296), Ee = 56320 | Ee & 1023), le.push(Ee), we += Fe;
      }
      return at(le);
    }
    const De = 4096;
    function at(se) {
      const J = se.length;
      if (J <= De)
        return String.fromCharCode.apply(String, se);
      let ie = "", le = 0;
      for (; le < J; )
        ie += String.fromCharCode.apply(
          String,
          se.slice(le, le += De)
        );
      return ie;
    }
    function ke(se, J, ie) {
      let le = "";
      ie = Math.min(se.length, ie);
      for (let we = J; we < ie; ++we)
        le += String.fromCharCode(se[we] & 127);
      return le;
    }
    function Se(se, J, ie) {
      let le = "";
      ie = Math.min(se.length, ie);
      for (let we = J; we < ie; ++we)
        le += String.fromCharCode(se[we]);
      return le;
    }
    function lt(se, J, ie) {
      const le = se.length;
      (!J || J < 0) && (J = 0), (!ie || ie < 0 || ie > le) && (ie = le);
      let we = "";
      for (let Ce = J; Ce < ie; ++Ce)
        we += We[se[Ce]];
      return we;
    }
    function qe(se, J, ie) {
      const le = se.slice(J, ie);
      let we = "";
      for (let Ce = 0; Ce < le.length - 1; Ce += 2)
        we += String.fromCharCode(le[Ce] + le[Ce + 1] * 256);
      return we;
    }
    y.prototype.slice = function(J, ie) {
      const le = this.length;
      J = ~~J, ie = ie === void 0 ? le : ~~ie, J < 0 ? (J += le, J < 0 && (J = 0)) : J > le && (J = le), ie < 0 ? (ie += le, ie < 0 && (ie = 0)) : ie > le && (ie = le), ie < J && (ie = J);
      const we = this.subarray(J, ie);
      return Object.setPrototypeOf(we, y.prototype), we;
    };
    function He(se, J, ie) {
      if (se % 1 !== 0 || se < 0) throw new RangeError("offset is not uint");
      if (se + J > ie) throw new RangeError("Trying to access beyond buffer length");
    }
    y.prototype.readUintLE = y.prototype.readUIntLE = function(J, ie, le) {
      J = J >>> 0, ie = ie >>> 0, le || He(J, ie, this.length);
      let we = this[J], Ce = 1, Ee = 0;
      for (; ++Ee < ie && (Ce *= 256); )
        we += this[J + Ee] * Ce;
      return we;
    }, y.prototype.readUintBE = y.prototype.readUIntBE = function(J, ie, le) {
      J = J >>> 0, ie = ie >>> 0, le || He(J, ie, this.length);
      let we = this[J + --ie], Ce = 1;
      for (; ie > 0 && (Ce *= 256); )
        we += this[J + --ie] * Ce;
      return we;
    }, y.prototype.readUint8 = y.prototype.readUInt8 = function(J, ie) {
      return J = J >>> 0, ie || He(J, 1, this.length), this[J];
    }, y.prototype.readUint16LE = y.prototype.readUInt16LE = function(J, ie) {
      return J = J >>> 0, ie || He(J, 2, this.length), this[J] | this[J + 1] << 8;
    }, y.prototype.readUint16BE = y.prototype.readUInt16BE = function(J, ie) {
      return J = J >>> 0, ie || He(J, 2, this.length), this[J] << 8 | this[J + 1];
    }, y.prototype.readUint32LE = y.prototype.readUInt32LE = function(J, ie) {
      return J = J >>> 0, ie || He(J, 4, this.length), (this[J] | this[J + 1] << 8 | this[J + 2] << 16) + this[J + 3] * 16777216;
    }, y.prototype.readUint32BE = y.prototype.readUInt32BE = function(J, ie) {
      return J = J >>> 0, ie || He(J, 4, this.length), this[J] * 16777216 + (this[J + 1] << 16 | this[J + 2] << 8 | this[J + 3]);
    }, y.prototype.readBigUInt64LE = Xe(function(J) {
      J = J >>> 0, Ge(J, "offset");
      const ie = this[J], le = this[J + 7];
      (ie === void 0 || le === void 0) && pt(J, this.length - 8);
      const we = ie + this[++J] * 2 ** 8 + this[++J] * 2 ** 16 + this[++J] * 2 ** 24, Ce = this[++J] + this[++J] * 2 ** 8 + this[++J] * 2 ** 16 + le * 2 ** 24;
      return BigInt(we) + (BigInt(Ce) << BigInt(32));
    }), y.prototype.readBigUInt64BE = Xe(function(J) {
      J = J >>> 0, Ge(J, "offset");
      const ie = this[J], le = this[J + 7];
      (ie === void 0 || le === void 0) && pt(J, this.length - 8);
      const we = ie * 2 ** 24 + this[++J] * 2 ** 16 + this[++J] * 2 ** 8 + this[++J], Ce = this[++J] * 2 ** 24 + this[++J] * 2 ** 16 + this[++J] * 2 ** 8 + le;
      return (BigInt(we) << BigInt(32)) + BigInt(Ce);
    }), y.prototype.readIntLE = function(J, ie, le) {
      J = J >>> 0, ie = ie >>> 0, le || He(J, ie, this.length);
      let we = this[J], Ce = 1, Ee = 0;
      for (; ++Ee < ie && (Ce *= 256); )
        we += this[J + Ee] * Ce;
      return Ce *= 128, we >= Ce && (we -= Math.pow(2, 8 * ie)), we;
    }, y.prototype.readIntBE = function(J, ie, le) {
      J = J >>> 0, ie = ie >>> 0, le || He(J, ie, this.length);
      let we = ie, Ce = 1, Ee = this[J + --we];
      for (; we > 0 && (Ce *= 256); )
        Ee += this[J + --we] * Ce;
      return Ce *= 128, Ee >= Ce && (Ee -= Math.pow(2, 8 * ie)), Ee;
    }, y.prototype.readInt8 = function(J, ie) {
      return J = J >>> 0, ie || He(J, 1, this.length), this[J] & 128 ? (255 - this[J] + 1) * -1 : this[J];
    }, y.prototype.readInt16LE = function(J, ie) {
      J = J >>> 0, ie || He(J, 2, this.length);
      const le = this[J] | this[J + 1] << 8;
      return le & 32768 ? le | 4294901760 : le;
    }, y.prototype.readInt16BE = function(J, ie) {
      J = J >>> 0, ie || He(J, 2, this.length);
      const le = this[J + 1] | this[J] << 8;
      return le & 32768 ? le | 4294901760 : le;
    }, y.prototype.readInt32LE = function(J, ie) {
      return J = J >>> 0, ie || He(J, 4, this.length), this[J] | this[J + 1] << 8 | this[J + 2] << 16 | this[J + 3] << 24;
    }, y.prototype.readInt32BE = function(J, ie) {
      return J = J >>> 0, ie || He(J, 4, this.length), this[J] << 24 | this[J + 1] << 16 | this[J + 2] << 8 | this[J + 3];
    }, y.prototype.readBigInt64LE = Xe(function(J) {
      J = J >>> 0, Ge(J, "offset");
      const ie = this[J], le = this[J + 7];
      (ie === void 0 || le === void 0) && pt(J, this.length - 8);
      const we = this[J + 4] + this[J + 5] * 2 ** 8 + this[J + 6] * 2 ** 16 + (le << 24);
      return (BigInt(we) << BigInt(32)) + BigInt(ie + this[++J] * 2 ** 8 + this[++J] * 2 ** 16 + this[++J] * 2 ** 24);
    }), y.prototype.readBigInt64BE = Xe(function(J) {
      J = J >>> 0, Ge(J, "offset");
      const ie = this[J], le = this[J + 7];
      (ie === void 0 || le === void 0) && pt(J, this.length - 8);
      const we = (ie << 24) + // Overflow
      this[++J] * 2 ** 16 + this[++J] * 2 ** 8 + this[++J];
      return (BigInt(we) << BigInt(32)) + BigInt(this[++J] * 2 ** 24 + this[++J] * 2 ** 16 + this[++J] * 2 ** 8 + le);
    }), y.prototype.readFloatLE = function(J, ie) {
      return J = J >>> 0, ie || He(J, 4, this.length), pe.read(this, J, !0, 23, 4);
    }, y.prototype.readFloatBE = function(J, ie) {
      return J = J >>> 0, ie || He(J, 4, this.length), pe.read(this, J, !1, 23, 4);
    }, y.prototype.readDoubleLE = function(J, ie) {
      return J = J >>> 0, ie || He(J, 8, this.length), pe.read(this, J, !0, 52, 8);
    }, y.prototype.readDoubleBE = function(J, ie) {
      return J = J >>> 0, ie || He(J, 8, this.length), pe.read(this, J, !1, 52, 8);
    };
    function ot(se, J, ie, le, we, Ce) {
      if (!y.isBuffer(se)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (J > we || J < Ce) throw new RangeError('"value" argument is out of bounds');
      if (ie + le > se.length) throw new RangeError("Index out of range");
    }
    y.prototype.writeUintLE = y.prototype.writeUIntLE = function(J, ie, le, we) {
      if (J = +J, ie = ie >>> 0, le = le >>> 0, !we) {
        const Fe = Math.pow(2, 8 * le) - 1;
        ot(this, J, ie, le, Fe, 0);
      }
      let Ce = 1, Ee = 0;
      for (this[ie] = J & 255; ++Ee < le && (Ce *= 256); )
        this[ie + Ee] = J / Ce & 255;
      return ie + le;
    }, y.prototype.writeUintBE = y.prototype.writeUIntBE = function(J, ie, le, we) {
      if (J = +J, ie = ie >>> 0, le = le >>> 0, !we) {
        const Fe = Math.pow(2, 8 * le) - 1;
        ot(this, J, ie, le, Fe, 0);
      }
      let Ce = le - 1, Ee = 1;
      for (this[ie + Ce] = J & 255; --Ce >= 0 && (Ee *= 256); )
        this[ie + Ce] = J / Ee & 255;
      return ie + le;
    }, y.prototype.writeUint8 = y.prototype.writeUInt8 = function(J, ie, le) {
      return J = +J, ie = ie >>> 0, le || ot(this, J, ie, 1, 255, 0), this[ie] = J & 255, ie + 1;
    }, y.prototype.writeUint16LE = y.prototype.writeUInt16LE = function(J, ie, le) {
      return J = +J, ie = ie >>> 0, le || ot(this, J, ie, 2, 65535, 0), this[ie] = J & 255, this[ie + 1] = J >>> 8, ie + 2;
    }, y.prototype.writeUint16BE = y.prototype.writeUInt16BE = function(J, ie, le) {
      return J = +J, ie = ie >>> 0, le || ot(this, J, ie, 2, 65535, 0), this[ie] = J >>> 8, this[ie + 1] = J & 255, ie + 2;
    }, y.prototype.writeUint32LE = y.prototype.writeUInt32LE = function(J, ie, le) {
      return J = +J, ie = ie >>> 0, le || ot(this, J, ie, 4, 4294967295, 0), this[ie + 3] = J >>> 24, this[ie + 2] = J >>> 16, this[ie + 1] = J >>> 8, this[ie] = J & 255, ie + 4;
    }, y.prototype.writeUint32BE = y.prototype.writeUInt32BE = function(J, ie, le) {
      return J = +J, ie = ie >>> 0, le || ot(this, J, ie, 4, 4294967295, 0), this[ie] = J >>> 24, this[ie + 1] = J >>> 16, this[ie + 2] = J >>> 8, this[ie + 3] = J & 255, ie + 4;
    };
    function be(se, J, ie, le, we) {
      Le(J, le, we, se, ie, 7);
      let Ce = Number(J & BigInt(4294967295));
      se[ie++] = Ce, Ce = Ce >> 8, se[ie++] = Ce, Ce = Ce >> 8, se[ie++] = Ce, Ce = Ce >> 8, se[ie++] = Ce;
      let Ee = Number(J >> BigInt(32) & BigInt(4294967295));
      return se[ie++] = Ee, Ee = Ee >> 8, se[ie++] = Ee, Ee = Ee >> 8, se[ie++] = Ee, Ee = Ee >> 8, se[ie++] = Ee, ie;
    }
    function _e(se, J, ie, le, we) {
      Le(J, le, we, se, ie, 7);
      let Ce = Number(J & BigInt(4294967295));
      se[ie + 7] = Ce, Ce = Ce >> 8, se[ie + 6] = Ce, Ce = Ce >> 8, se[ie + 5] = Ce, Ce = Ce >> 8, se[ie + 4] = Ce;
      let Ee = Number(J >> BigInt(32) & BigInt(4294967295));
      return se[ie + 3] = Ee, Ee = Ee >> 8, se[ie + 2] = Ee, Ee = Ee >> 8, se[ie + 1] = Ee, Ee = Ee >> 8, se[ie] = Ee, ie + 8;
    }
    y.prototype.writeBigUInt64LE = Xe(function(J, ie = 0) {
      return be(this, J, ie, BigInt(0), BigInt("0xffffffffffffffff"));
    }), y.prototype.writeBigUInt64BE = Xe(function(J, ie = 0) {
      return _e(this, J, ie, BigInt(0), BigInt("0xffffffffffffffff"));
    }), y.prototype.writeIntLE = function(J, ie, le, we) {
      if (J = +J, ie = ie >>> 0, !we) {
        const ut = Math.pow(2, 8 * le - 1);
        ot(this, J, ie, le, ut - 1, -ut);
      }
      let Ce = 0, Ee = 1, Fe = 0;
      for (this[ie] = J & 255; ++Ce < le && (Ee *= 256); )
        J < 0 && Fe === 0 && this[ie + Ce - 1] !== 0 && (Fe = 1), this[ie + Ce] = (J / Ee >> 0) - Fe & 255;
      return ie + le;
    }, y.prototype.writeIntBE = function(J, ie, le, we) {
      if (J = +J, ie = ie >>> 0, !we) {
        const ut = Math.pow(2, 8 * le - 1);
        ot(this, J, ie, le, ut - 1, -ut);
      }
      let Ce = le - 1, Ee = 1, Fe = 0;
      for (this[ie + Ce] = J & 255; --Ce >= 0 && (Ee *= 256); )
        J < 0 && Fe === 0 && this[ie + Ce + 1] !== 0 && (Fe = 1), this[ie + Ce] = (J / Ee >> 0) - Fe & 255;
      return ie + le;
    }, y.prototype.writeInt8 = function(J, ie, le) {
      return J = +J, ie = ie >>> 0, le || ot(this, J, ie, 1, 127, -128), J < 0 && (J = 255 + J + 1), this[ie] = J & 255, ie + 1;
    }, y.prototype.writeInt16LE = function(J, ie, le) {
      return J = +J, ie = ie >>> 0, le || ot(this, J, ie, 2, 32767, -32768), this[ie] = J & 255, this[ie + 1] = J >>> 8, ie + 2;
    }, y.prototype.writeInt16BE = function(J, ie, le) {
      return J = +J, ie = ie >>> 0, le || ot(this, J, ie, 2, 32767, -32768), this[ie] = J >>> 8, this[ie + 1] = J & 255, ie + 2;
    }, y.prototype.writeInt32LE = function(J, ie, le) {
      return J = +J, ie = ie >>> 0, le || ot(this, J, ie, 4, 2147483647, -2147483648), this[ie] = J & 255, this[ie + 1] = J >>> 8, this[ie + 2] = J >>> 16, this[ie + 3] = J >>> 24, ie + 4;
    }, y.prototype.writeInt32BE = function(J, ie, le) {
      return J = +J, ie = ie >>> 0, le || ot(this, J, ie, 4, 2147483647, -2147483648), J < 0 && (J = 4294967295 + J + 1), this[ie] = J >>> 24, this[ie + 1] = J >>> 16, this[ie + 2] = J >>> 8, this[ie + 3] = J & 255, ie + 4;
    }, y.prototype.writeBigInt64LE = Xe(function(J, ie = 0) {
      return be(this, J, ie, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }), y.prototype.writeBigInt64BE = Xe(function(J, ie = 0) {
      return _e(this, J, ie, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function it(se, J, ie, le, we, Ce) {
      if (ie + le > se.length) throw new RangeError("Index out of range");
      if (ie < 0) throw new RangeError("Index out of range");
    }
    function Ae(se, J, ie, le, we) {
      return J = +J, ie = ie >>> 0, we || it(se, J, ie, 4), pe.write(se, J, ie, le, 23, 4), ie + 4;
    }
    y.prototype.writeFloatLE = function(J, ie, le) {
      return Ae(this, J, ie, !0, le);
    }, y.prototype.writeFloatBE = function(J, ie, le) {
      return Ae(this, J, ie, !1, le);
    };
    function Be(se, J, ie, le, we) {
      return J = +J, ie = ie >>> 0, we || it(se, J, ie, 8), pe.write(se, J, ie, le, 52, 8), ie + 8;
    }
    y.prototype.writeDoubleLE = function(J, ie, le) {
      return Be(this, J, ie, !0, le);
    }, y.prototype.writeDoubleBE = function(J, ie, le) {
      return Be(this, J, ie, !1, le);
    }, y.prototype.copy = function(J, ie, le, we) {
      if (!y.isBuffer(J)) throw new TypeError("argument should be a Buffer");
      if (le || (le = 0), !we && we !== 0 && (we = this.length), ie >= J.length && (ie = J.length), ie || (ie = 0), we > 0 && we < le && (we = le), we === le || J.length === 0 || this.length === 0) return 0;
      if (ie < 0)
        throw new RangeError("targetStart out of bounds");
      if (le < 0 || le >= this.length) throw new RangeError("Index out of range");
      if (we < 0) throw new RangeError("sourceEnd out of bounds");
      we > this.length && (we = this.length), J.length - ie < we - le && (we = J.length - ie + le);
      const Ce = we - le;
      return this === J && typeof Pe.prototype.copyWithin == "function" ? this.copyWithin(ie, le, we) : Pe.prototype.set.call(
        J,
        this.subarray(le, we),
        ie
      ), Ce;
    }, y.prototype.fill = function(J, ie, le, we) {
      if (typeof J == "string") {
        if (typeof ie == "string" ? (we = ie, ie = 0, le = this.length) : typeof le == "string" && (we = le, le = this.length), we !== void 0 && typeof we != "string")
          throw new TypeError("encoding must be a string");
        if (typeof we == "string" && !y.isEncoding(we))
          throw new TypeError("Unknown encoding: " + we);
        if (J.length === 1) {
          const Ee = J.charCodeAt(0);
          (we === "utf8" && Ee < 128 || we === "latin1") && (J = Ee);
        }
      } else typeof J == "number" ? J = J & 255 : typeof J == "boolean" && (J = Number(J));
      if (ie < 0 || this.length < ie || this.length < le)
        throw new RangeError("Out of range index");
      if (le <= ie)
        return this;
      ie = ie >>> 0, le = le === void 0 ? this.length : le >>> 0, J || (J = 0);
      let Ce;
      if (typeof J == "number")
        for (Ce = ie; Ce < le; ++Ce)
          this[Ce] = J;
      else {
        const Ee = y.isBuffer(J) ? J : y.from(J, we), Fe = Ee.length;
        if (Fe === 0)
          throw new TypeError('The value "' + J + '" is invalid for argument "value"');
        for (Ce = 0; Ce < le - ie; ++Ce)
          this[Ce + ie] = Ee[Ce % Fe];
      }
      return this;
    };
    const nt = {};
    function Te(se, J, ie) {
      nt[se] = class extends ie {
        constructor() {
          super(), Object.defineProperty(this, "message", {
            value: J.apply(this, arguments),
            writable: !0,
            configurable: !0
          }), this.name = `${this.name} [${se}]`, this.stack, delete this.name;
        }
        get code() {
          return se;
        }
        set code(we) {
          Object.defineProperty(this, "code", {
            configurable: !0,
            enumerable: !0,
            value: we,
            writable: !0
          });
        }
        toString() {
          return `${this.name} [${se}]: ${this.message}`;
        }
      };
    }
    Te(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(se) {
        return se ? `${se} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
      },
      RangeError
    ), Te(
      "ERR_INVALID_ARG_TYPE",
      function(se, J) {
        return `The "${se}" argument must be of type number. Received type ${typeof J}`;
      },
      TypeError
    ), Te(
      "ERR_OUT_OF_RANGE",
      function(se, J, ie) {
        let le = `The value of "${se}" is out of range.`, we = ie;
        return Number.isInteger(ie) && Math.abs(ie) > 2 ** 32 ? we = Ue(String(ie)) : typeof ie == "bigint" && (we = String(ie), (ie > BigInt(2) ** BigInt(32) || ie < -(BigInt(2) ** BigInt(32))) && (we = Ue(we)), we += "n"), le += ` It must be ${J}. Received ${we}`, le;
      },
      RangeError
    );
    function Ue(se) {
      let J = "", ie = se.length;
      const le = se[0] === "-" ? 1 : 0;
      for (; ie >= le + 4; ie -= 3)
        J = `_${se.slice(ie - 3, ie)}${J}`;
      return `${se.slice(0, ie)}${J}`;
    }
    function st(se, J, ie) {
      Ge(J, "offset"), (se[J] === void 0 || se[J + ie] === void 0) && pt(J, se.length - (ie + 1));
    }
    function Le(se, J, ie, le, we, Ce) {
      if (se > ie || se < J) {
        const Ee = typeof J == "bigint" ? "n" : "";
        let Fe;
        throw J === 0 || J === BigInt(0) ? Fe = `>= 0${Ee} and < 2${Ee} ** ${(Ce + 1) * 8}${Ee}` : Fe = `>= -(2${Ee} ** ${(Ce + 1) * 8 - 1}${Ee}) and < 2 ** ${(Ce + 1) * 8 - 1}${Ee}`, new nt.ERR_OUT_OF_RANGE("value", Fe, se);
      }
      st(le, we, Ce);
    }
    function Ge(se, J) {
      if (typeof se != "number")
        throw new nt.ERR_INVALID_ARG_TYPE(J, "number", se);
    }
    function pt(se, J, ie) {
      throw Math.floor(se) !== se ? (Ge(se, ie), new nt.ERR_OUT_OF_RANGE("offset", "an integer", se)) : J < 0 ? new nt.ERR_BUFFER_OUT_OF_BOUNDS() : new nt.ERR_OUT_OF_RANGE(
        "offset",
        `>= 0 and <= ${J}`,
        se
      );
    }
    const je = /[^+/0-9A-Za-z-_]/g;
    function Je(se) {
      if (se = se.split("=")[0], se = se.trim().replace(je, ""), se.length < 2) return "";
      for (; se.length % 4 !== 0; )
        se = se + "=";
      return se;
    }
    function dt(se, J) {
      J = J || 1 / 0;
      let ie;
      const le = se.length;
      let we = null;
      const Ce = [];
      for (let Ee = 0; Ee < le; ++Ee) {
        if (ie = se.charCodeAt(Ee), ie > 55295 && ie < 57344) {
          if (!we) {
            if (ie > 56319) {
              (J -= 3) > -1 && Ce.push(239, 191, 189);
              continue;
            } else if (Ee + 1 === le) {
              (J -= 3) > -1 && Ce.push(239, 191, 189);
              continue;
            }
            we = ie;
            continue;
          }
          if (ie < 56320) {
            (J -= 3) > -1 && Ce.push(239, 191, 189), we = ie;
            continue;
          }
          ie = (we - 55296 << 10 | ie - 56320) + 65536;
        } else we && (J -= 3) > -1 && Ce.push(239, 191, 189);
        if (we = null, ie < 128) {
          if ((J -= 1) < 0) break;
          Ce.push(ie);
        } else if (ie < 2048) {
          if ((J -= 2) < 0) break;
          Ce.push(
            ie >> 6 | 192,
            ie & 63 | 128
          );
        } else if (ie < 65536) {
          if ((J -= 3) < 0) break;
          Ce.push(
            ie >> 12 | 224,
            ie >> 6 & 63 | 128,
            ie & 63 | 128
          );
        } else if (ie < 1114112) {
          if ((J -= 4) < 0) break;
          Ce.push(
            ie >> 18 | 240,
            ie >> 12 & 63 | 128,
            ie >> 6 & 63 | 128,
            ie & 63 | 128
          );
        } else
          throw new Error("Invalid code point");
      }
      return Ce;
    }
    function ze(se) {
      const J = [];
      for (let ie = 0; ie < se.length; ++ie)
        J.push(se.charCodeAt(ie) & 255);
      return J;
    }
    function et(se, J) {
      let ie, le, we;
      const Ce = [];
      for (let Ee = 0; Ee < se.length && !((J -= 2) < 0); ++Ee)
        ie = se.charCodeAt(Ee), le = ie >> 8, we = ie % 256, Ce.push(we), Ce.push(le);
      return Ce;
    }
    function yt(se) {
      return ge.toByteArray(Je(se));
    }
    function Ke(se, J, ie, le) {
      let we;
      for (we = 0; we < le && !(we + ie >= J.length || we >= se.length); ++we)
        J[we + ie] = se[we];
      return we;
    }
    function Ye(se, J) {
      return se instanceof J || se != null && se.constructor != null && se.constructor.name != null && se.constructor.name === J.name;
    }
    function gt(se) {
      return se !== se;
    }
    const We = function() {
      const se = "0123456789abcdef", J = new Array(256);
      for (let ie = 0; ie < 16; ++ie) {
        const le = ie * 16;
        for (let we = 0; we < 16; ++we)
          J[le + we] = se[ie] + se[we];
      }
      return J;
    }();
    function Xe(se) {
      return typeof BigInt > "u" ? bt : se;
    }
    function bt() {
      throw new Error("BigInt not supported");
    }
  })(M);
  const de = M.Buffer;
  w.Blob = M.Blob, w.BlobOptions = M.BlobOptions, w.Buffer = M.Buffer, w.File = M.File, w.FileOptions = M.FileOptions, w.INSPECT_MAX_BYTES = M.INSPECT_MAX_BYTES, w.SlowBuffer = M.SlowBuffer, w.TranscodeEncoding = M.TranscodeEncoding, w.atob = M.atob, w.btoa = M.btoa, w.constants = M.constants, w.default = de, w.isAscii = M.isAscii, w.isUtf8 = M.isUtf8, w.kMaxLength = M.kMaxLength, w.kStringMaxLength = M.kStringMaxLength, w.resolveObjectURL = M.resolveObjectURL, w.transcode = M.transcode;
})(dist);
const Buffer$D = /* @__PURE__ */ getDefaultExportFromCjs$1(dist), escapeUri = (w) => encodeURIComponent(w).replace(/[!'()*]/g, hexEncode), hexEncode = (w) => `%${w.charCodeAt(0).toString(16).toUpperCase()}`;
function buildQueryString(w) {
  const M = [];
  for (let x of Object.keys(w).sort()) {
    const $ = w[x];
    if (x = escapeUri(x), Array.isArray($))
      for (let T = 0, S = $.length; T < S; T++)
        M.push(`${x}=${escapeUri($[T])}`);
    else {
      let T = x;
      ($ || typeof $ == "string") && (T += `=${escapeUri($)}`), M.push(T);
    }
  }
  return M.join("&");
}
function createRequest(w, M) {
  return new Request(w, M);
}
function requestTimeout(w = 0) {
  return new Promise((M, x) => {
    w && setTimeout(() => {
      const $ = new Error(`Request did not complete within ${w} ms`);
      $.name = "TimeoutError", x($);
    }, w);
  });
}
const keepAliveSupport = {
  supported: void 0
};
class FetchHttpHandler {
  static create(M) {
    return typeof (M == null ? void 0 : M.handle) == "function" ? M : new FetchHttpHandler(M);
  }
  constructor(M) {
    typeof M == "function" ? this.configProvider = M().then((x) => x || {}) : (this.config = M ?? {}, this.configProvider = Promise.resolve(this.config)), keepAliveSupport.supported === void 0 && (keepAliveSupport.supported = typeof Request < "u" && "keepalive" in createRequest("https://[::1]"));
  }
  destroy() {
  }
  async handle(M, { abortSignal: x } = {}) {
    var de;
    this.config || (this.config = await this.configProvider);
    const $ = this.config.requestTimeout, T = this.config.keepAlive === !0, S = this.config.credentials;
    if (x != null && x.aborted) {
      const ne = new Error("Request aborted");
      return ne.name = "AbortError", Promise.reject(ne);
    }
    let D = M.path;
    const F = buildQueryString(M.query || {});
    F && (D += `?${F}`), M.fragment && (D += `#${M.fragment}`);
    let z = "";
    if (M.username != null || M.password != null) {
      const ne = M.username ?? "", ge = M.password ?? "";
      z = `${ne}:${ge}@`;
    }
    const { port: Z, method: H } = M, V = `${M.protocol}//${z}${M.hostname}${Z ? `:${Z}` : ""}${D}`, X = H === "GET" || H === "HEAD" ? void 0 : M.body, Q = {
      body: X,
      headers: new Headers(M.headers),
      method: H,
      credentials: S
    };
    (de = this.config) != null && de.cache && (Q.cache = this.config.cache), X && (Q.duplex = "half"), typeof AbortController < "u" && (Q.signal = x), keepAliveSupport.supported && (Q.keepalive = T), typeof this.config.requestInit == "function" && Object.assign(Q, this.config.requestInit(M));
    let fe = () => {
    };
    const ce = createRequest(V, Q), me = [
      fetch(ce).then((ne) => {
        const ge = ne.headers, pe = {};
        for (const Re of ge.entries())
          pe[Re[0]] = Re[1];
        return ne.body != null ? {
          response: new HttpResponse({
            headers: pe,
            reason: ne.statusText,
            statusCode: ne.status,
            body: ne.body
          })
        } : ne.blob().then((Re) => ({
          response: new HttpResponse({
            headers: pe,
            reason: ne.statusText,
            statusCode: ne.status,
            body: Re
          })
        }));
      }),
      requestTimeout($)
    ];
    return x && me.push(new Promise((ne, ge) => {
      const pe = () => {
        const $e = new Error("Request aborted");
        $e.name = "AbortError", ge($e);
      };
      if (typeof x.addEventListener == "function") {
        const $e = x;
        $e.addEventListener("abort", pe, { once: !0 }), fe = () => $e.removeEventListener("abort", pe);
      } else
        x.onabort = pe;
    })), Promise.race(me).finally(fe);
  }
  updateHttpClientConfig(M, x) {
    this.config = void 0, this.configProvider = this.configProvider.then(($) => ($[M] = x, $));
  }
  httpHandlerConfigs() {
    return this.config ?? {};
  }
}
const streamCollector = async (w) => {
  var M;
  return typeof Blob == "function" && w instanceof Blob || ((M = w.constructor) == null ? void 0 : M.name) === "Blob" ? Blob.prototype.arrayBuffer !== void 0 ? new Uint8Array(await w.arrayBuffer()) : collectBlob(w) : collectStream(w);
};
async function collectBlob(w) {
  const M = await readToBase64(w), x = fromBase64(M);
  return new Uint8Array(x);
}
async function collectStream(w) {
  const M = [], x = w.getReader();
  let $ = !1, T = 0;
  for (; !$; ) {
    const { done: F, value: z } = await x.read();
    z && (M.push(z), T += z.length), $ = F;
  }
  const S = new Uint8Array(T);
  let D = 0;
  for (const F of M)
    S.set(F, D), D += F.length;
  return S;
}
function readToBase64(w) {
  return new Promise((M, x) => {
    const $ = new FileReader();
    $.onloadend = () => {
      if ($.readyState !== 2)
        return x(new Error("Reader aborted too early"));
      const T = $.result ?? "", S = T.indexOf(","), D = S > -1 ? S + 1 : T.length;
      M(T.substring(D));
    }, $.onabort = () => x(new Error("Read aborted")), $.onerror = () => x($.error), $.readAsDataURL(w);
  });
}
const SHORT_TO_HEX = {}, HEX_TO_SHORT = {};
for (let w = 0; w < 256; w++) {
  let M = w.toString(16).toLowerCase();
  M.length === 1 && (M = `0${M}`), SHORT_TO_HEX[w] = M, HEX_TO_SHORT[M] = w;
}
function fromHex(w) {
  if (w.length % 2 !== 0)
    throw new Error("Hex encoded strings must have an even number length");
  const M = new Uint8Array(w.length / 2);
  for (let x = 0; x < w.length; x += 2) {
    const $ = w.slice(x, x + 2).toLowerCase();
    if ($ in HEX_TO_SHORT)
      M[x / 2] = HEX_TO_SHORT[$];
    else
      throw new Error(`Cannot decode unrecognized sequence ${$} as hexadecimal`);
  }
  return M;
}
function toHex$1(w) {
  let M = "";
  for (let x = 0; x < w.byteLength; x++)
    M += SHORT_TO_HEX[w[x]];
  return M;
}
const collectBody = async (w = new Uint8Array(), M) => {
  if (w instanceof Uint8Array)
    return Uint8ArrayBlobAdapter.mutate(w);
  if (!w)
    return Uint8ArrayBlobAdapter.mutate(new Uint8Array());
  const x = M.streamCollector(w);
  return Uint8ArrayBlobAdapter.mutate(await x);
};
function setFeature$1(w, M, x) {
  w.__smithy_context ? w.__smithy_context.features || (w.__smithy_context.features = {}) : w.__smithy_context = {
    features: {}
  }, w.__smithy_context.features[M] = x;
}
class DefaultIdentityProviderConfig {
  constructor(M) {
    this.authSchemes = /* @__PURE__ */ new Map();
    for (const [x, $] of Object.entries(M))
      $ !== void 0 && this.authSchemes.set(x, $);
  }
  getIdentityProvider(M) {
    return this.authSchemes.get(M);
  }
}
const createIsIdentityExpiredFunction = (w) => (M) => doesIdentityRequireRefresh(M) && M.expiration.getTime() - Date.now() < w, EXPIRATION_MS = 3e5, isIdentityExpired = createIsIdentityExpiredFunction(EXPIRATION_MS), doesIdentityRequireRefresh = (w) => w.expiration !== void 0, memoizeIdentityProvider = (w, M, x) => {
  if (w === void 0)
    return;
  const $ = typeof w != "function" ? async () => Promise.resolve(w) : w;
  let T, S, D, F = !1;
  const z = async (Z) => {
    S || (S = $(Z));
    try {
      T = await S, D = !0, F = !1;
    } finally {
      S = void 0;
    }
    return T;
  };
  return M === void 0 ? async (Z) => ((!D || Z != null && Z.forceRefresh) && (T = await z(Z)), T) : async (Z) => ((!D || Z != null && Z.forceRefresh) && (T = await z(Z)), F ? T : x(T) ? (M(T) && await z(Z), T) : (F = !0, T));
}, DEFAULT_UA_APP_ID = void 0;
function isValidUserAgentAppId(w) {
  return w === void 0 ? !0 : typeof w == "string" && w.length <= 50;
}
function resolveUserAgentConfig(w) {
  const M = normalizeProvider(w.userAgentAppId ?? DEFAULT_UA_APP_ID), { customUserAgent: x } = w;
  return Object.assign(w, {
    customUserAgent: typeof x == "string" ? [[x]] : x,
    userAgentAppId: async () => {
      var T, S;
      const $ = await M();
      if (!isValidUserAgentAppId($)) {
        const D = ((S = (T = w.logger) == null ? void 0 : T.constructor) == null ? void 0 : S.name) === "NoOpLogger" || !w.logger ? console : w.logger;
        typeof $ != "string" ? D == null || D.warn("userAgentAppId must be a string or undefined.") : $.length > 50 && (D == null || D.warn("The provided userAgentAppId exceeds the maximum length of 50 characters."));
      }
      return $;
    }
  });
}
class EndpointCache {
  constructor({ size: M, params: x }) {
    this.data = /* @__PURE__ */ new Map(), this.parameters = [], this.capacity = M ?? 50, x && (this.parameters = x);
  }
  get(M, x) {
    const $ = this.hash(M);
    if ($ === !1)
      return x();
    if (!this.data.has($)) {
      if (this.data.size > this.capacity + 10) {
        const T = this.data.keys();
        let S = 0;
        for (; ; ) {
          const { value: D, done: F } = T.next();
          if (this.data.delete(D), F || ++S > 10)
            break;
        }
      }
      this.data.set($, x());
    }
    return this.data.get($);
  }
  size() {
    return this.data.size;
  }
  hash(M) {
    let x = "";
    const { parameters: $ } = this;
    if ($.length === 0)
      return !1;
    for (const T of $) {
      const S = String(M[T] ?? "");
      if (S.includes("|;"))
        return !1;
      x += S + "|;";
    }
    return x;
  }
}
const IP_V4_REGEX = new RegExp("^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$"), isIpAddress = (w) => IP_V4_REGEX.test(w) || w.startsWith("[") && w.endsWith("]"), VALID_HOST_LABEL_REGEX = new RegExp("^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$"), isValidHostLabel = (w, M = !1) => {
  if (!M)
    return VALID_HOST_LABEL_REGEX.test(w);
  const x = w.split(".");
  for (const $ of x)
    if (!isValidHostLabel($))
      return !1;
  return !0;
}, customEndpointFunctions = {}, debugId = "endpoints";
function toDebugString(w) {
  return typeof w != "object" || w == null ? w : "ref" in w ? `$${toDebugString(w.ref)}` : "fn" in w ? `${w.fn}(${(w.argv || []).map(toDebugString).join(", ")})` : JSON.stringify(w, null, 2);
}
class EndpointError extends Error {
  constructor(M) {
    super(M), this.name = "EndpointError";
  }
}
const booleanEquals = (w, M) => w === M, getAttrPathList = (w) => {
  const M = w.split("."), x = [];
  for (const $ of M) {
    const T = $.indexOf("[");
    if (T !== -1) {
      if ($.indexOf("]") !== $.length - 1)
        throw new EndpointError(`Path: '${w}' does not end with ']'`);
      const S = $.slice(T + 1, -1);
      if (Number.isNaN(parseInt(S)))
        throw new EndpointError(`Invalid array index: '${S}' in path: '${w}'`);
      T !== 0 && x.push($.slice(0, T)), x.push(S);
    } else
      x.push($);
  }
  return x;
}, getAttr = (w, M) => getAttrPathList(M).reduce((x, $) => {
  if (typeof x != "object")
    throw new EndpointError(`Index '${$}' in '${M}' not found in '${JSON.stringify(w)}'`);
  return Array.isArray(x) ? x[parseInt($)] : x[$];
}, w), isSet = (w) => w != null, not = (w) => !w, DEFAULT_PORTS = {
  [EndpointURLScheme.HTTP]: 80,
  [EndpointURLScheme.HTTPS]: 443
}, parseURL = (w) => {
  const M = (() => {
    try {
      if (w instanceof URL)
        return w;
      if (typeof w == "object" && "hostname" in w) {
        const { hostname: X, port: Q, protocol: fe = "", path: ce = "", query: me = {} } = w, de = new URL(`${fe}//${X}${Q ? `:${Q}` : ""}${ce}`);
        return de.search = Object.entries(me).map(([ne, ge]) => `${ne}=${ge}`).join("&"), de;
      }
      return new URL(w);
    } catch {
      return null;
    }
  })();
  if (!M)
    return console.error(`Unable to parse ${JSON.stringify(w)} as a whatwg URL.`), null;
  const x = M.href, { host: $, hostname: T, pathname: S, protocol: D, search: F } = M;
  if (F)
    return null;
  const z = D.slice(0, -1);
  if (!Object.values(EndpointURLScheme).includes(z))
    return null;
  const Z = isIpAddress(T), H = x.includes(`${$}:${DEFAULT_PORTS[z]}`) || typeof w == "string" && w.includes(`${$}:${DEFAULT_PORTS[z]}`), V = `${$}${H ? `:${DEFAULT_PORTS[z]}` : ""}`;
  return {
    scheme: z,
    authority: V,
    path: S,
    normalizedPath: S.endsWith("/") ? S : `${S}/`,
    isIp: Z
  };
}, stringEquals = (w, M) => w === M, substring = (w, M, x, $) => M >= x || w.length < x ? null : $ ? w.substring(w.length - x, w.length - M) : w.substring(M, x), uriEncode = (w) => encodeURIComponent(w).replace(/[!*'()]/g, (M) => `%${M.charCodeAt(0).toString(16).toUpperCase()}`), endpointFunctions = {
  booleanEquals,
  getAttr,
  isSet,
  isValidHostLabel,
  not,
  parseURL,
  stringEquals,
  substring,
  uriEncode
}, evaluateTemplate = (w, M) => {
  const x = [], $ = {
    ...M.endpointParams,
    ...M.referenceRecord
  };
  let T = 0;
  for (; T < w.length; ) {
    const S = w.indexOf("{", T);
    if (S === -1) {
      x.push(w.slice(T));
      break;
    }
    x.push(w.slice(T, S));
    const D = w.indexOf("}", S);
    if (D === -1) {
      x.push(w.slice(S));
      break;
    }
    w[S + 1] === "{" && w[D + 1] === "}" && (x.push(w.slice(S + 1, D)), T = D + 2);
    const F = w.substring(S + 1, D);
    if (F.includes("#")) {
      const [z, Z] = F.split("#");
      x.push(getAttr($[z], Z));
    } else
      x.push($[F]);
    T = D + 1;
  }
  return x.join("");
}, getReferenceValue = ({ ref: w }, M) => ({
  ...M.endpointParams,
  ...M.referenceRecord
})[w], evaluateExpression = (w, M, x) => {
  if (typeof w == "string")
    return evaluateTemplate(w, x);
  if (w.fn)
    return callFunction(w, x);
  if (w.ref)
    return getReferenceValue(w, x);
  throw new EndpointError(`'${M}': ${String(w)} is not a string, function or reference.`);
}, callFunction = ({ fn: w, argv: M }, x) => {
  const $ = M.map((S) => ["boolean", "number"].includes(typeof S) ? S : evaluateExpression(S, "arg", x)), T = w.split(".");
  return T[0] in customEndpointFunctions && T[1] != null ? customEndpointFunctions[T[0]][T[1]](...$) : endpointFunctions[w](...$);
}, evaluateCondition = ({ assign: w, ...M }, x) => {
  var T, S;
  if (w && w in x.referenceRecord)
    throw new EndpointError(`'${w}' is already defined in Reference Record.`);
  const $ = callFunction(M, x);
  return (S = (T = x.logger) == null ? void 0 : T.debug) == null || S.call(T, `${debugId} evaluateCondition: ${toDebugString(M)} = ${toDebugString($)}`), {
    result: $ === "" ? !0 : !!$,
    ...w != null && { toAssign: { name: w, value: $ } }
  };
}, evaluateConditions = (w = [], M) => {
  var $, T;
  const x = {};
  for (const S of w) {
    const { result: D, toAssign: F } = evaluateCondition(S, {
      ...M,
      referenceRecord: {
        ...M.referenceRecord,
        ...x
      }
    });
    if (!D)
      return { result: D };
    F && (x[F.name] = F.value, (T = ($ = M.logger) == null ? void 0 : $.debug) == null || T.call($, `${debugId} assign: ${F.name} := ${toDebugString(F.value)}`));
  }
  return { result: !0, referenceRecord: x };
}, getEndpointHeaders = (w, M) => Object.entries(w).reduce((x, [$, T]) => ({
  ...x,
  [$]: T.map((S) => {
    const D = evaluateExpression(S, "Header value entry", M);
    if (typeof D != "string")
      throw new EndpointError(`Header '${$}' value '${D}' is not a string`);
    return D;
  })
}), {}), getEndpointProperty = (w, M) => {
  if (Array.isArray(w))
    return w.map((x) => getEndpointProperty(x, M));
  switch (typeof w) {
    case "string":
      return evaluateTemplate(w, M);
    case "object":
      if (w === null)
        throw new EndpointError(`Unexpected endpoint property: ${w}`);
      return getEndpointProperties(w, M);
    case "boolean":
      return w;
    default:
      throw new EndpointError(`Unexpected endpoint property type: ${typeof w}`);
  }
}, getEndpointProperties = (w, M) => Object.entries(w).reduce((x, [$, T]) => ({
  ...x,
  [$]: getEndpointProperty(T, M)
}), {}), getEndpointUrl = (w, M) => {
  const x = evaluateExpression(w, "Endpoint URL", M);
  if (typeof x == "string")
    try {
      return new URL(x);
    } catch ($) {
      throw console.error(`Failed to construct URL with ${x}`, $), $;
    }
  throw new EndpointError(`Endpoint URL must be a string, got ${typeof x}`);
}, evaluateEndpointRule = (w, M) => {
  var H, V;
  const { conditions: x, endpoint: $ } = w, { result: T, referenceRecord: S } = evaluateConditions(x, M);
  if (!T)
    return;
  const D = {
    ...M,
    referenceRecord: { ...M.referenceRecord, ...S }
  }, { url: F, properties: z, headers: Z } = $;
  return (V = (H = M.logger) == null ? void 0 : H.debug) == null || V.call(H, `${debugId} Resolving endpoint from template: ${toDebugString($)}`), {
    ...Z != null && {
      headers: getEndpointHeaders(Z, D)
    },
    ...z != null && {
      properties: getEndpointProperties(z, D)
    },
    url: getEndpointUrl(F, D)
  };
}, evaluateErrorRule = (w, M) => {
  const { conditions: x, error: $ } = w, { result: T, referenceRecord: S } = evaluateConditions(x, M);
  if (T)
    throw new EndpointError(evaluateExpression($, "Error", {
      ...M,
      referenceRecord: { ...M.referenceRecord, ...S }
    }));
}, evaluateTreeRule = (w, M) => {
  const { conditions: x, rules: $ } = w, { result: T, referenceRecord: S } = evaluateConditions(x, M);
  if (T)
    return evaluateRules($, {
      ...M,
      referenceRecord: { ...M.referenceRecord, ...S }
    });
}, evaluateRules = (w, M) => {
  for (const x of w)
    if (x.type === "endpoint") {
      const $ = evaluateEndpointRule(x, M);
      if ($)
        return $;
    } else if (x.type === "error")
      evaluateErrorRule(x, M);
    else if (x.type === "tree") {
      const $ = evaluateTreeRule(x, M);
      if ($)
        return $;
    } else
      throw new EndpointError(`Unknown endpoint rule: ${x}`);
  throw new EndpointError("Rules evaluation failed");
}, resolveEndpoint = (w, M) => {
  var Z, H, V, X;
  const { endpointParams: x, logger: $ } = M, { parameters: T, rules: S } = w;
  (H = (Z = M.logger) == null ? void 0 : Z.debug) == null || H.call(Z, `${debugId} Initial EndpointParams: ${toDebugString(x)}`);
  const D = Object.entries(T).filter(([, Q]) => Q.default != null).map(([Q, fe]) => [Q, fe.default]);
  if (D.length > 0)
    for (const [Q, fe] of D)
      x[Q] = x[Q] ?? fe;
  const F = Object.entries(T).filter(([, Q]) => Q.required).map(([Q]) => Q);
  for (const Q of F)
    if (x[Q] == null)
      throw new EndpointError(`Missing required parameter: '${Q}'`);
  const z = evaluateRules(S, { endpointParams: x, logger: $, referenceRecord: {} });
  return (X = (V = M.logger) == null ? void 0 : V.debug) == null || X.call(V, `${debugId} Resolved endpoint: ${toDebugString(z)}`), z;
}, isVirtualHostableS3Bucket = (w, M = !1) => {
  if (M) {
    for (const x of w.split("."))
      if (!isVirtualHostableS3Bucket(x))
        return !1;
    return !0;
  }
  return !(!isValidHostLabel(w) || w.length < 3 || w.length > 63 || w !== w.toLowerCase() || isIpAddress(w));
}, ARN_DELIMITER = ":", RESOURCE_DELIMITER = "/", parseArn = (w) => {
  const M = w.split(ARN_DELIMITER);
  if (M.length < 6)
    return null;
  const [x, $, T, S, D, ...F] = M;
  if (x !== "arn" || $ === "" || T === "" || F.join(ARN_DELIMITER) === "")
    return null;
  const z = F.map((Z) => Z.split(RESOURCE_DELIMITER)).flat();
  return {
    partition: $,
    service: T,
    region: S,
    accountId: D,
    resourceId: z
  };
}, partitions = [
  {
    id: "aws",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      implicitGlobalRegion: "us-east-1",
      name: "aws",
      supportsDualStack: !0,
      supportsFIPS: !0
    },
    regionRegex: "^(us|eu|ap|sa|ca|me|af|il|mx)\\-\\w+\\-\\d+$",
    regions: {
      "af-south-1": {
        description: "Africa (Cape Town)"
      },
      "ap-east-1": {
        description: "Asia Pacific (Hong Kong)"
      },
      "ap-northeast-1": {
        description: "Asia Pacific (Tokyo)"
      },
      "ap-northeast-2": {
        description: "Asia Pacific (Seoul)"
      },
      "ap-northeast-3": {
        description: "Asia Pacific (Osaka)"
      },
      "ap-south-1": {
        description: "Asia Pacific (Mumbai)"
      },
      "ap-south-2": {
        description: "Asia Pacific (Hyderabad)"
      },
      "ap-southeast-1": {
        description: "Asia Pacific (Singapore)"
      },
      "ap-southeast-2": {
        description: "Asia Pacific (Sydney)"
      },
      "ap-southeast-3": {
        description: "Asia Pacific (Jakarta)"
      },
      "ap-southeast-4": {
        description: "Asia Pacific (Melbourne)"
      },
      "ap-southeast-5": {
        description: "Asia Pacific (Malaysia)"
      },
      "ap-southeast-7": {
        description: "Asia Pacific (Thailand)"
      },
      "aws-global": {
        description: "AWS Standard global region"
      },
      "ca-central-1": {
        description: "Canada (Central)"
      },
      "ca-west-1": {
        description: "Canada West (Calgary)"
      },
      "eu-central-1": {
        description: "Europe (Frankfurt)"
      },
      "eu-central-2": {
        description: "Europe (Zurich)"
      },
      "eu-north-1": {
        description: "Europe (Stockholm)"
      },
      "eu-south-1": {
        description: "Europe (Milan)"
      },
      "eu-south-2": {
        description: "Europe (Spain)"
      },
      "eu-west-1": {
        description: "Europe (Ireland)"
      },
      "eu-west-2": {
        description: "Europe (London)"
      },
      "eu-west-3": {
        description: "Europe (Paris)"
      },
      "il-central-1": {
        description: "Israel (Tel Aviv)"
      },
      "me-central-1": {
        description: "Middle East (UAE)"
      },
      "me-south-1": {
        description: "Middle East (Bahrain)"
      },
      "mx-central-1": {
        description: "Mexico (Central)"
      },
      "sa-east-1": {
        description: "South America (Sao Paulo)"
      },
      "us-east-1": {
        description: "US East (N. Virginia)"
      },
      "us-east-2": {
        description: "US East (Ohio)"
      },
      "us-west-1": {
        description: "US West (N. California)"
      },
      "us-west-2": {
        description: "US West (Oregon)"
      }
    }
  },
  {
    id: "aws-cn",
    outputs: {
      dnsSuffix: "amazonaws.com.cn",
      dualStackDnsSuffix: "api.amazonwebservices.com.cn",
      implicitGlobalRegion: "cn-northwest-1",
      name: "aws-cn",
      supportsDualStack: !0,
      supportsFIPS: !0
    },
    regionRegex: "^cn\\-\\w+\\-\\d+$",
    regions: {
      "aws-cn-global": {
        description: "AWS China global region"
      },
      "cn-north-1": {
        description: "China (Beijing)"
      },
      "cn-northwest-1": {
        description: "China (Ningxia)"
      }
    }
  },
  {
    id: "aws-us-gov",
    outputs: {
      dnsSuffix: "amazonaws.com",
      dualStackDnsSuffix: "api.aws",
      implicitGlobalRegion: "us-gov-west-1",
      name: "aws-us-gov",
      supportsDualStack: !0,
      supportsFIPS: !0
    },
    regionRegex: "^us\\-gov\\-\\w+\\-\\d+$",
    regions: {
      "aws-us-gov-global": {
        description: "AWS GovCloud (US) global region"
      },
      "us-gov-east-1": {
        description: "AWS GovCloud (US-East)"
      },
      "us-gov-west-1": {
        description: "AWS GovCloud (US-West)"
      }
    }
  },
  {
    id: "aws-iso",
    outputs: {
      dnsSuffix: "c2s.ic.gov",
      dualStackDnsSuffix: "c2s.ic.gov",
      implicitGlobalRegion: "us-iso-east-1",
      name: "aws-iso",
      supportsDualStack: !1,
      supportsFIPS: !0
    },
    regionRegex: "^us\\-iso\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-global": {
        description: "AWS ISO (US) global region"
      },
      "us-iso-east-1": {
        description: "US ISO East"
      },
      "us-iso-west-1": {
        description: "US ISO WEST"
      }
    }
  },
  {
    id: "aws-iso-b",
    outputs: {
      dnsSuffix: "sc2s.sgov.gov",
      dualStackDnsSuffix: "sc2s.sgov.gov",
      implicitGlobalRegion: "us-isob-east-1",
      name: "aws-iso-b",
      supportsDualStack: !1,
      supportsFIPS: !0
    },
    regionRegex: "^us\\-isob\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-b-global": {
        description: "AWS ISOB (US) global region"
      },
      "us-isob-east-1": {
        description: "US ISOB East (Ohio)"
      }
    }
  },
  {
    id: "aws-iso-e",
    outputs: {
      dnsSuffix: "cloud.adc-e.uk",
      dualStackDnsSuffix: "cloud.adc-e.uk",
      implicitGlobalRegion: "eu-isoe-west-1",
      name: "aws-iso-e",
      supportsDualStack: !1,
      supportsFIPS: !0
    },
    regionRegex: "^eu\\-isoe\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-e-global": {
        description: "AWS ISOE (Europe) global region"
      },
      "eu-isoe-west-1": {
        description: "EU ISOE West"
      }
    }
  },
  {
    id: "aws-iso-f",
    outputs: {
      dnsSuffix: "csp.hci.ic.gov",
      dualStackDnsSuffix: "csp.hci.ic.gov",
      implicitGlobalRegion: "us-isof-south-1",
      name: "aws-iso-f",
      supportsDualStack: !1,
      supportsFIPS: !0
    },
    regionRegex: "^us\\-isof\\-\\w+\\-\\d+$",
    regions: {
      "aws-iso-f-global": {
        description: "AWS ISOF global region"
      },
      "us-isof-east-1": {
        description: "US ISOF EAST"
      },
      "us-isof-south-1": {
        description: "US ISOF SOUTH"
      }
    }
  },
  {
    id: "aws-eusc",
    outputs: {
      dnsSuffix: "amazonaws.eu",
      dualStackDnsSuffix: "amazonaws.eu",
      implicitGlobalRegion: "eusc-de-east-1",
      name: "aws-eusc",
      supportsDualStack: !1,
      supportsFIPS: !0
    },
    regionRegex: "^eusc\\-(de)\\-\\w+\\-\\d+$",
    regions: {
      "eusc-de-east-1": {
        description: "EU (Germany)"
      }
    }
  }
], partitionsInfo = {
  partitions
};
let selectedPartitionsInfo = partitionsInfo;
const partition = (w) => {
  const { partitions: M } = selectedPartitionsInfo;
  for (const $ of M) {
    const { regions: T, outputs: S } = $;
    for (const [D, F] of Object.entries(T))
      if (D === w)
        return {
          ...S,
          ...F
        };
  }
  for (const $ of M) {
    const { regionRegex: T, outputs: S } = $;
    if (new RegExp(T).test(w))
      return {
        ...S
      };
  }
  const x = M.find(($) => $.id === "aws");
  if (!x)
    throw new Error("Provided region was not found in the partition array or regex, and default partition with id 'aws' doesn't exist.");
  return {
    ...x.outputs
  };
}, awsEndpointFunctions = {
  isVirtualHostableS3Bucket,
  parseArn,
  partition
};
customEndpointFunctions.aws = awsEndpointFunctions;
function setCredentialFeature(w, M, x) {
  return w.$source || (w.$source = {}), w.$source[M] = x, w;
}
function setFeature(w, M, x) {
  w.__aws_sdk_context ? w.__aws_sdk_context.features || (w.__aws_sdk_context.features = {}) : w.__aws_sdk_context = {
    features: {}
  }, w.__aws_sdk_context.features[M] = x;
}
const getDateHeader = (w) => {
  var M, x;
  return HttpResponse.isInstance(w) ? ((M = w.headers) == null ? void 0 : M.date) ?? ((x = w.headers) == null ? void 0 : x.Date) : void 0;
}, getSkewCorrectedDate = (w) => new Date(Date.now() + w), isClockSkewed = (w, M) => Math.abs(getSkewCorrectedDate(M).getTime() - w) >= 3e5, getUpdatedSystemClockOffset = (w, M) => {
  const x = Date.parse(w);
  return isClockSkewed(x, M) ? x - Date.now() : M;
}, throwSigningPropertyError = (w, M) => {
  if (!M)
    throw new Error(`Property \`${w}\` is not resolved for AWS SDK SigV4Auth`);
  return M;
}, validateSigningProperties = async (w) => {
  var Z, H, V;
  const M = throwSigningPropertyError("context", w.context), x = throwSigningPropertyError("config", w.config), $ = (V = (H = (Z = M.endpointV2) == null ? void 0 : Z.properties) == null ? void 0 : H.authSchemes) == null ? void 0 : V[0], S = await throwSigningPropertyError("signer", x.signer)($), D = w == null ? void 0 : w.signingRegion, F = w == null ? void 0 : w.signingRegionSet, z = w == null ? void 0 : w.signingName;
  return {
    config: x,
    signer: S,
    signingRegion: D,
    signingRegionSet: F,
    signingName: z
  };
};
class AwsSdkSigV4Signer {
  async sign(M, x, $) {
    var V;
    if (!HttpRequest.isInstance(M))
      throw new Error("The request is not an instance of `HttpRequest` and cannot be signed");
    const T = await validateSigningProperties($), { config: S, signer: D } = T;
    let { signingRegion: F, signingName: z } = T;
    const Z = $.context;
    if (((V = Z == null ? void 0 : Z.authSchemes) == null ? void 0 : V.length) ?? !1) {
      const [X, Q] = Z.authSchemes;
      (X == null ? void 0 : X.name) === "sigv4a" && (Q == null ? void 0 : Q.name) === "sigv4" && (F = (Q == null ? void 0 : Q.signingRegion) ?? F, z = (Q == null ? void 0 : Q.signingName) ?? z);
    }
    return await D.sign(M, {
      signingDate: getSkewCorrectedDate(S.systemClockOffset),
      signingRegion: F,
      signingService: z
    });
  }
  errorHandler(M) {
    return (x) => {
      const $ = x.ServerTime ?? getDateHeader(x.$response);
      if ($) {
        const T = throwSigningPropertyError("config", M.config), S = T.systemClockOffset;
        T.systemClockOffset = getUpdatedSystemClockOffset($, T.systemClockOffset), T.systemClockOffset !== S && x.$metadata && (x.$metadata.clockSkewCorrected = !0);
      }
      throw x;
    };
  }
  successHandler(M, x) {
    const $ = getDateHeader(M);
    if ($) {
      const T = throwSigningPropertyError("config", x.config);
      T.systemClockOffset = getUpdatedSystemClockOffset($, T.systemClockOffset);
    }
  }
}
class ProviderError extends Error {
  constructor(M, x = !0) {
    var S;
    let $, T = !0;
    typeof x == "boolean" ? ($ = void 0, T = x) : x != null && typeof x == "object" && ($ = x.logger, T = x.tryNextLink ?? !0), super(M), this.name = "ProviderError", this.tryNextLink = T, Object.setPrototypeOf(this, ProviderError.prototype), (S = $ == null ? void 0 : $.debug) == null || S.call($, `@smithy/property-provider ${T ? "->" : "(!)"} ${M}`);
  }
  static from(M, x = !0) {
    return Object.assign(new this(M.message, x), M);
  }
}
class CredentialsProviderError extends ProviderError {
  constructor(M, x = !0) {
    super(M, x), this.name = "CredentialsProviderError", Object.setPrototypeOf(this, CredentialsProviderError.prototype);
  }
}
const memoize = (w, M, x) => {
  let $, T, S, D = !1;
  const F = async () => {
    T || (T = w());
    try {
      $ = await T, S = !0, D = !1;
    } finally {
      T = void 0;
    }
    return $;
  };
  return async (z) => ((!S || z != null && z.forceRefresh) && ($ = await F()), $);
}, ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm", CREDENTIAL_QUERY_PARAM = "X-Amz-Credential", AMZ_DATE_QUERY_PARAM = "X-Amz-Date", SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders", EXPIRES_QUERY_PARAM = "X-Amz-Expires", SIGNATURE_QUERY_PARAM = "X-Amz-Signature", TOKEN_QUERY_PARAM = "X-Amz-Security-Token", AUTH_HEADER = "authorization", AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase(), DATE_HEADER = "date", GENERATED_HEADERS = [AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER], SIGNATURE_HEADER = SIGNATURE_QUERY_PARAM.toLowerCase(), SHA256_HEADER = "x-amz-content-sha256", TOKEN_HEADER = TOKEN_QUERY_PARAM.toLowerCase(), ALWAYS_UNSIGNABLE_HEADERS = {
  authorization: !0,
  "cache-control": !0,
  connection: !0,
  expect: !0,
  from: !0,
  "keep-alive": !0,
  "max-forwards": !0,
  pragma: !0,
  referer: !0,
  te: !0,
  trailer: !0,
  "transfer-encoding": !0,
  upgrade: !0,
  "user-agent": !0,
  "x-amzn-trace-id": !0
}, PROXY_HEADER_PATTERN = /^proxy-/, SEC_HEADER_PATTERN = /^sec-/, ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256", EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD", UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD", MAX_CACHE_SIZE = 50, KEY_TYPE_IDENTIFIER = "aws4_request", MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7, signingKeyCache = {}, cacheQueue = [], createScope = (w, M, x) => `${w}/${M}/${x}/${KEY_TYPE_IDENTIFIER}`, getSigningKey = async (w, M, x, $, T) => {
  const S = await hmac$1(w, M.secretAccessKey, M.accessKeyId), D = `${x}:${$}:${T}:${toHex$1(S)}:${M.sessionToken}`;
  if (D in signingKeyCache)
    return signingKeyCache[D];
  for (cacheQueue.push(D); cacheQueue.length > MAX_CACHE_SIZE; )
    delete signingKeyCache[cacheQueue.shift()];
  let F = `AWS4${M.secretAccessKey}`;
  for (const z of [x, $, T, KEY_TYPE_IDENTIFIER])
    F = await hmac$1(w, F, z);
  return signingKeyCache[D] = F;
}, hmac$1 = (w, M, x) => {
  const $ = new w(M);
  return $.update(toUint8Array(x)), $.digest();
}, getCanonicalHeaders = ({ headers: w }, M, x) => {
  const $ = {};
  for (const T of Object.keys(w).sort()) {
    if (w[T] == null)
      continue;
    const S = T.toLowerCase();
    (S in ALWAYS_UNSIGNABLE_HEADERS || M != null && M.has(S) || PROXY_HEADER_PATTERN.test(S) || SEC_HEADER_PATTERN.test(S)) && (!x || x && !x.has(S)) || ($[S] = w[T].trim().replace(/\s+/g, " "));
  }
  return $;
}, isArrayBuffer = (w) => typeof ArrayBuffer == "function" && w instanceof ArrayBuffer || Object.prototype.toString.call(w) === "[object ArrayBuffer]", getPayloadHash = async ({ headers: w, body: M }, x) => {
  for (const $ of Object.keys(w))
    if ($.toLowerCase() === SHA256_HEADER)
      return w[$];
  if (M == null)
    return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
  if (typeof M == "string" || ArrayBuffer.isView(M) || isArrayBuffer(M)) {
    const $ = new x();
    return $.update(toUint8Array(M)), toHex$1(await $.digest());
  }
  return UNSIGNED_PAYLOAD;
};
class HeaderFormatter {
  format(M) {
    const x = [];
    for (const S of Object.keys(M)) {
      const D = fromUtf8$2(S);
      x.push(Uint8Array.from([D.byteLength]), D, this.formatHeaderValue(M[S]));
    }
    const $ = new Uint8Array(x.reduce((S, D) => S + D.byteLength, 0));
    let T = 0;
    for (const S of x)
      $.set(S, T), T += S.byteLength;
    return $;
  }
  formatHeaderValue(M) {
    switch (M.type) {
      case "boolean":
        return Uint8Array.from([M.value ? 0 : 1]);
      case "byte":
        return Uint8Array.from([2, M.value]);
      case "short":
        const x = new DataView(new ArrayBuffer(3));
        return x.setUint8(0, 3), x.setInt16(1, M.value, !1), new Uint8Array(x.buffer);
      case "integer":
        const $ = new DataView(new ArrayBuffer(5));
        return $.setUint8(0, 4), $.setInt32(1, M.value, !1), new Uint8Array($.buffer);
      case "long":
        const T = new Uint8Array(9);
        return T[0] = 5, T.set(M.value.bytes, 1), T;
      case "binary":
        const S = new DataView(new ArrayBuffer(3 + M.value.byteLength));
        S.setUint8(0, 6), S.setUint16(1, M.value.byteLength, !1);
        const D = new Uint8Array(S.buffer);
        return D.set(M.value, 3), D;
      case "string":
        const F = fromUtf8$2(M.value), z = new DataView(new ArrayBuffer(3 + F.byteLength));
        z.setUint8(0, 7), z.setUint16(1, F.byteLength, !1);
        const Z = new Uint8Array(z.buffer);
        return Z.set(F, 3), Z;
      case "timestamp":
        const H = new Uint8Array(9);
        return H[0] = 8, H.set(Int64.fromNumber(M.value.valueOf()).bytes, 1), H;
      case "uuid":
        if (!UUID_PATTERN.test(M.value))
          throw new Error(`Invalid UUID received: ${M.value}`);
        const V = new Uint8Array(17);
        return V[0] = 9, V.set(fromHex(M.value.replace(/\-/g, "")), 1), V;
    }
  }
}
var HEADER_VALUE_TYPE;
(function(w) {
  w[w.boolTrue = 0] = "boolTrue", w[w.boolFalse = 1] = "boolFalse", w[w.byte = 2] = "byte", w[w.short = 3] = "short", w[w.integer = 4] = "integer", w[w.long = 5] = "long", w[w.byteArray = 6] = "byteArray", w[w.string = 7] = "string", w[w.timestamp = 8] = "timestamp", w[w.uuid = 9] = "uuid";
})(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));
const UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;
class Int64 {
  constructor(M) {
    if (this.bytes = M, M.byteLength !== 8)
      throw new Error("Int64 buffers must be exactly 8 bytes");
  }
  static fromNumber(M) {
    if (M > 9223372036854776e3 || M < -9223372036854776e3)
      throw new Error(`${M} is too large (or, if negative, too small) to represent as an Int64`);
    const x = new Uint8Array(8);
    for (let $ = 7, T = Math.abs(Math.round(M)); $ > -1 && T > 0; $--, T /= 256)
      x[$] = T;
    return M < 0 && negate(x), new Int64(x);
  }
  valueOf() {
    const M = this.bytes.slice(0), x = M[0] & 128;
    return x && negate(M), parseInt(toHex$1(M), 16) * (x ? -1 : 1);
  }
  toString() {
    return String(this.valueOf());
  }
}
function negate(w) {
  for (let M = 0; M < 8; M++)
    w[M] ^= 255;
  for (let M = 7; M > -1 && (w[M]++, w[M] === 0); M--)
    ;
}
const hasHeader = (w, M) => {
  w = w.toLowerCase();
  for (const x of Object.keys(M))
    if (w === x.toLowerCase())
      return !0;
  return !1;
}, moveHeadersToQuery = (w, M = {}) => {
  var T, S;
  const { headers: x, query: $ = {} } = HttpRequest.clone(w);
  for (const D of Object.keys(x)) {
    const F = D.toLowerCase();
    (F.slice(0, 6) === "x-amz-" && !((T = M.unhoistableHeaders) != null && T.has(F)) || (S = M.hoistableHeaders) != null && S.has(F)) && ($[D] = x[D], delete x[D]);
  }
  return {
    ...w,
    headers: x,
    query: $
  };
}, prepareRequest = (w) => {
  w = HttpRequest.clone(w);
  for (const M of Object.keys(w.headers))
    GENERATED_HEADERS.indexOf(M.toLowerCase()) > -1 && delete w.headers[M];
  return w;
}, getCanonicalQuery = ({ query: w = {} }) => {
  const M = [], x = {};
  for (const $ of Object.keys(w)) {
    if ($.toLowerCase() === SIGNATURE_HEADER)
      continue;
    const T = escapeUri($);
    M.push(T);
    const S = w[$];
    typeof S == "string" ? x[T] = `${T}=${escapeUri(S)}` : Array.isArray(S) && (x[T] = S.slice(0).reduce((D, F) => D.concat([`${T}=${escapeUri(F)}`]), []).sort().join("&"));
  }
  return M.sort().map(($) => x[$]).filter(($) => $).join("&");
}, iso8601 = (w) => toDate(w).toISOString().replace(/\.\d{3}Z$/, "Z"), toDate = (w) => typeof w == "number" ? new Date(w * 1e3) : typeof w == "string" ? Number(w) ? new Date(Number(w) * 1e3) : new Date(w) : w;
class SignatureV4Base {
  constructor({ applyChecksum: M, credentials: x, region: $, service: T, sha256: S, uriEscapePath: D = !0 }) {
    this.service = T, this.sha256 = S, this.uriEscapePath = D, this.applyChecksum = typeof M == "boolean" ? M : !0, this.regionProvider = normalizeProvider$1($), this.credentialProvider = normalizeProvider$1(x);
  }
  createCanonicalRequest(M, x, $) {
    const T = Object.keys(x).sort();
    return `${M.method}
${this.getCanonicalPath(M)}
${getCanonicalQuery(M)}
${T.map((S) => `${S}:${x[S]}`).join(`
`)}

${T.join(";")}
${$}`;
  }
  async createStringToSign(M, x, $, T) {
    const S = new this.sha256();
    S.update(toUint8Array($));
    const D = await S.digest();
    return `${T}
${M}
${x}
${toHex$1(D)}`;
  }
  getCanonicalPath({ path: M }) {
    if (this.uriEscapePath) {
      const x = [];
      for (const S of M.split("/"))
        (S == null ? void 0 : S.length) !== 0 && S !== "." && (S === ".." ? x.pop() : x.push(S));
      const $ = `${M != null && M.startsWith("/") ? "/" : ""}${x.join("/")}${x.length > 0 && (M != null && M.endsWith("/")) ? "/" : ""}`;
      return escapeUri($).replace(/%2F/g, "/");
    }
    return M;
  }
  validateResolvedCredentials(M) {
    if (typeof M != "object" || typeof M.accessKeyId != "string" || typeof M.secretAccessKey != "string")
      throw new Error("Resolved credential object is not valid");
  }
  formatDate(M) {
    const x = iso8601(M).replace(/[\-:]/g, "");
    return {
      longDate: x,
      shortDate: x.slice(0, 8)
    };
  }
  getCanonicalHeaderList(M) {
    return Object.keys(M).sort().join(";");
  }
}
class SignatureV4 extends SignatureV4Base {
  constructor({ applyChecksum: M, credentials: x, region: $, service: T, sha256: S, uriEscapePath: D = !0 }) {
    super({
      applyChecksum: M,
      credentials: x,
      region: $,
      service: T,
      sha256: S,
      uriEscapePath: D
    }), this.headerFormatter = new HeaderFormatter();
  }
  async presign(M, x = {}) {
    const { signingDate: $ = /* @__PURE__ */ new Date(), expiresIn: T = 3600, unsignableHeaders: S, unhoistableHeaders: D, signableHeaders: F, hoistableHeaders: z, signingRegion: Z, signingService: H } = x, V = await this.credentialProvider();
    this.validateResolvedCredentials(V);
    const X = Z ?? await this.regionProvider(), { longDate: Q, shortDate: fe } = this.formatDate($);
    if (T > MAX_PRESIGNED_TTL)
      return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");
    const ce = createScope(fe, X, H ?? this.service), me = moveHeadersToQuery(prepareRequest(M), { unhoistableHeaders: D, hoistableHeaders: z });
    V.sessionToken && (me.query[TOKEN_QUERY_PARAM] = V.sessionToken), me.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER, me.query[CREDENTIAL_QUERY_PARAM] = `${V.accessKeyId}/${ce}`, me.query[AMZ_DATE_QUERY_PARAM] = Q, me.query[EXPIRES_QUERY_PARAM] = T.toString(10);
    const de = getCanonicalHeaders(me, S, F);
    return me.query[SIGNED_HEADERS_QUERY_PARAM] = this.getCanonicalHeaderList(de), me.query[SIGNATURE_QUERY_PARAM] = await this.getSignature(Q, ce, this.getSigningKey(V, X, fe, H), this.createCanonicalRequest(me, de, await getPayloadHash(M, this.sha256))), me;
  }
  async sign(M, x) {
    return typeof M == "string" ? this.signString(M, x) : M.headers && M.payload ? this.signEvent(M, x) : M.message ? this.signMessage(M, x) : this.signRequest(M, x);
  }
  async signEvent({ headers: M, payload: x }, { signingDate: $ = /* @__PURE__ */ new Date(), priorSignature: T, signingRegion: S, signingService: D }) {
    const F = S ?? await this.regionProvider(), { shortDate: z, longDate: Z } = this.formatDate($), H = createScope(z, F, D ?? this.service), V = await getPayloadHash({ headers: {}, body: x }, this.sha256), X = new this.sha256();
    X.update(M);
    const Q = toHex$1(await X.digest()), fe = [
      EVENT_ALGORITHM_IDENTIFIER,
      Z,
      H,
      T,
      Q,
      V
    ].join(`
`);
    return this.signString(fe, { signingDate: $, signingRegion: F, signingService: D });
  }
  async signMessage(M, { signingDate: x = /* @__PURE__ */ new Date(), signingRegion: $, signingService: T }) {
    return this.signEvent({
      headers: this.headerFormatter.format(M.message.headers),
      payload: M.message.body
    }, {
      signingDate: x,
      signingRegion: $,
      signingService: T,
      priorSignature: M.priorSignature
    }).then((D) => ({ message: M.message, signature: D }));
  }
  async signString(M, { signingDate: x = /* @__PURE__ */ new Date(), signingRegion: $, signingService: T } = {}) {
    const S = await this.credentialProvider();
    this.validateResolvedCredentials(S);
    const D = $ ?? await this.regionProvider(), { shortDate: F } = this.formatDate(x), z = new this.sha256(await this.getSigningKey(S, D, F, T));
    return z.update(toUint8Array(M)), toHex$1(await z.digest());
  }
  async signRequest(M, { signingDate: x = /* @__PURE__ */ new Date(), signableHeaders: $, unsignableHeaders: T, signingRegion: S, signingService: D } = {}) {
    const F = await this.credentialProvider();
    this.validateResolvedCredentials(F);
    const z = S ?? await this.regionProvider(), Z = prepareRequest(M), { longDate: H, shortDate: V } = this.formatDate(x), X = createScope(V, z, D ?? this.service);
    Z.headers[AMZ_DATE_HEADER] = H, F.sessionToken && (Z.headers[TOKEN_HEADER] = F.sessionToken);
    const Q = await getPayloadHash(Z, this.sha256);
    !hasHeader(SHA256_HEADER, Z.headers) && this.applyChecksum && (Z.headers[SHA256_HEADER] = Q);
    const fe = getCanonicalHeaders(Z, T, $), ce = await this.getSignature(H, X, this.getSigningKey(F, z, V, D), this.createCanonicalRequest(Z, fe, Q));
    return Z.headers[AUTH_HEADER] = `${ALGORITHM_IDENTIFIER} Credential=${F.accessKeyId}/${X}, SignedHeaders=${this.getCanonicalHeaderList(fe)}, Signature=${ce}`, Z;
  }
  async getSignature(M, x, $, T) {
    const S = await this.createStringToSign(M, x, T, ALGORITHM_IDENTIFIER), D = new this.sha256(await $);
    return D.update(toUint8Array(S)), toHex$1(await D.digest());
  }
  getSigningKey(M, x, $, T) {
    return getSigningKey(this.sha256, M, $, x, T || this.service);
  }
}
const resolveAwsSdkSigV4Config = (w) => {
  let M = w.credentials, x = !!w.credentials, $;
  Object.defineProperty(w, "credentials", {
    set(Z) {
      Z && Z !== M && Z !== $ && (x = !0), M = Z;
      const H = normalizeCredentialProvider(w, {
        credentials: M,
        credentialDefaultProvider: w.credentialDefaultProvider
      }), V = bindCallerConfig(w, H);
      x && !V.attributed ? ($ = async (X) => V(X).then((Q) => setCredentialFeature(Q, "CREDENTIALS_CODE", "e")), $.memoized = V.memoized, $.configBound = V.configBound, $.attributed = !0) : $ = V;
    },
    get() {
      return $;
    },
    enumerable: !0,
    configurable: !0
  }), w.credentials = M;
  const { signingEscapePath: T = !0, systemClockOffset: S = w.systemClockOffset || 0, sha256: D } = w;
  let F;
  return w.signer ? F = normalizeProvider(w.signer) : w.regionInfoProvider ? F = () => normalizeProvider(w.region)().then(async (Z) => [
    await w.regionInfoProvider(Z, {
      useFipsEndpoint: await w.useFipsEndpoint(),
      useDualstackEndpoint: await w.useDualstackEndpoint()
    }) || {},
    Z
  ]).then(([Z, H]) => {
    const { signingRegion: V, signingService: X } = Z;
    w.signingRegion = w.signingRegion || V || H, w.signingName = w.signingName || X || w.serviceId;
    const Q = {
      ...w,
      credentials: w.credentials,
      region: w.signingRegion,
      service: w.signingName,
      sha256: D,
      uriEscapePath: T
    }, fe = w.signerConstructor || SignatureV4;
    return new fe(Q);
  }) : F = async (Z) => {
    Z = Object.assign({}, {
      name: "sigv4",
      signingName: w.signingName || w.defaultSigningName,
      signingRegion: await normalizeProvider(w.region)(),
      properties: {}
    }, Z);
    const H = Z.signingRegion, V = Z.signingName;
    w.signingRegion = w.signingRegion || H, w.signingName = w.signingName || V || w.serviceId;
    const X = {
      ...w,
      credentials: w.credentials,
      region: w.signingRegion,
      service: w.signingName,
      sha256: D,
      uriEscapePath: T
    }, Q = w.signerConstructor || SignatureV4;
    return new Q(X);
  }, Object.assign(w, {
    systemClockOffset: S,
    signingEscapePath: T,
    signer: F
  });
};
function normalizeCredentialProvider(w, { credentials: M, credentialDefaultProvider: x }) {
  let $;
  return M ? M != null && M.memoized ? $ = M : $ = memoizeIdentityProvider(M, isIdentityExpired, doesIdentityRequireRefresh) : x ? $ = normalizeProvider(x(Object.assign({}, w, {
    parentClientConfig: w
  }))) : $ = async () => {
    throw new Error("@aws-sdk/core::resolveAwsSdkSigV4Config - `credentials` not provided and no credentialDefaultProvider was configured.");
  }, $.memoized = !0, $;
}
function bindCallerConfig(w, M) {
  if (M.configBound)
    return M;
  const x = async ($) => M({ ...$, callerClientConfig: w });
  return x.memoized = M.memoized, x.configBound = !0, x;
}
const getAllAliases = (w, M) => {
  const x = [];
  if (w && x.push(w), M)
    for (const $ of M)
      x.push($);
  return x;
}, getMiddlewareNameWithAliases = (w, M) => `${w || "anonymous"}${M && M.length > 0 ? ` (a.k.a. ${M.join(",")})` : ""}`, constructStack = () => {
  let w = [], M = [], x = !1;
  const $ = /* @__PURE__ */ new Set(), T = (V) => V.sort((X, Q) => stepWeights[Q.step] - stepWeights[X.step] || priorityWeights[Q.priority || "normal"] - priorityWeights[X.priority || "normal"]), S = (V) => {
    let X = !1;
    const Q = (fe) => {
      const ce = getAllAliases(fe.name, fe.aliases);
      if (ce.includes(V)) {
        X = !0;
        for (const me of ce)
          $.delete(me);
        return !1;
      }
      return !0;
    };
    return w = w.filter(Q), M = M.filter(Q), X;
  }, D = (V) => {
    let X = !1;
    const Q = (fe) => {
      if (fe.middleware === V) {
        X = !0;
        for (const ce of getAllAliases(fe.name, fe.aliases))
          $.delete(ce);
        return !1;
      }
      return !0;
    };
    return w = w.filter(Q), M = M.filter(Q), X;
  }, F = (V) => {
    var X;
    return w.forEach((Q) => {
      V.add(Q.middleware, { ...Q });
    }), M.forEach((Q) => {
      V.addRelativeTo(Q.middleware, { ...Q });
    }), (X = V.identifyOnResolve) == null || X.call(V, H.identifyOnResolve()), V;
  }, z = (V) => {
    const X = [];
    return V.before.forEach((Q) => {
      Q.before.length === 0 && Q.after.length === 0 ? X.push(Q) : X.push(...z(Q));
    }), X.push(V), V.after.reverse().forEach((Q) => {
      Q.before.length === 0 && Q.after.length === 0 ? X.push(Q) : X.push(...z(Q));
    }), X;
  }, Z = (V = !1) => {
    const X = [], Q = [], fe = {};
    return w.forEach((me) => {
      const de = {
        ...me,
        before: [],
        after: []
      };
      for (const ne of getAllAliases(de.name, de.aliases))
        fe[ne] = de;
      X.push(de);
    }), M.forEach((me) => {
      const de = {
        ...me,
        before: [],
        after: []
      };
      for (const ne of getAllAliases(de.name, de.aliases))
        fe[ne] = de;
      Q.push(de);
    }), Q.forEach((me) => {
      if (me.toMiddleware) {
        const de = fe[me.toMiddleware];
        if (de === void 0) {
          if (V)
            return;
          throw new Error(`${me.toMiddleware} is not found when adding ${getMiddlewareNameWithAliases(me.name, me.aliases)} middleware ${me.relation} ${me.toMiddleware}`);
        }
        me.relation === "after" && de.after.push(me), me.relation === "before" && de.before.push(me);
      }
    }), T(X).map(z).reduce((me, de) => (me.push(...de), me), []);
  }, H = {
    add: (V, X = {}) => {
      const { name: Q, override: fe, aliases: ce } = X, me = {
        step: "initialize",
        priority: "normal",
        middleware: V,
        ...X
      }, de = getAllAliases(Q, ce);
      if (de.length > 0) {
        if (de.some((ne) => $.has(ne))) {
          if (!fe)
            throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(Q, ce)}'`);
          for (const ne of de) {
            const ge = w.findIndex(($e) => {
              var Re;
              return $e.name === ne || ((Re = $e.aliases) == null ? void 0 : Re.some((Pe) => Pe === ne));
            });
            if (ge === -1)
              continue;
            const pe = w[ge];
            if (pe.step !== me.step || me.priority !== pe.priority)
              throw new Error(`"${getMiddlewareNameWithAliases(pe.name, pe.aliases)}" middleware with ${pe.priority} priority in ${pe.step} step cannot be overridden by "${getMiddlewareNameWithAliases(Q, ce)}" middleware with ${me.priority} priority in ${me.step} step.`);
            w.splice(ge, 1);
          }
        }
        for (const ne of de)
          $.add(ne);
      }
      w.push(me);
    },
    addRelativeTo: (V, X) => {
      const { name: Q, override: fe, aliases: ce } = X, me = {
        middleware: V,
        ...X
      }, de = getAllAliases(Q, ce);
      if (de.length > 0) {
        if (de.some((ne) => $.has(ne))) {
          if (!fe)
            throw new Error(`Duplicate middleware name '${getMiddlewareNameWithAliases(Q, ce)}'`);
          for (const ne of de) {
            const ge = M.findIndex(($e) => {
              var Re;
              return $e.name === ne || ((Re = $e.aliases) == null ? void 0 : Re.some((Pe) => Pe === ne));
            });
            if (ge === -1)
              continue;
            const pe = M[ge];
            if (pe.toMiddleware !== me.toMiddleware || pe.relation !== me.relation)
              throw new Error(`"${getMiddlewareNameWithAliases(pe.name, pe.aliases)}" middleware ${pe.relation} "${pe.toMiddleware}" middleware cannot be overridden by "${getMiddlewareNameWithAliases(Q, ce)}" middleware ${me.relation} "${me.toMiddleware}" middleware.`);
            M.splice(ge, 1);
          }
        }
        for (const ne of de)
          $.add(ne);
      }
      M.push(me);
    },
    clone: () => F(constructStack()),
    use: (V) => {
      V.applyToStack(H);
    },
    remove: (V) => typeof V == "string" ? S(V) : D(V),
    removeByTag: (V) => {
      let X = !1;
      const Q = (fe) => {
        const { tags: ce, name: me, aliases: de } = fe;
        if (ce && ce.includes(V)) {
          const ne = getAllAliases(me, de);
          for (const ge of ne)
            $.delete(ge);
          return X = !0, !1;
        }
        return !0;
      };
      return w = w.filter(Q), M = M.filter(Q), X;
    },
    concat: (V) => {
      var Q;
      const X = F(constructStack());
      return X.use(V), X.identifyOnResolve(x || X.identifyOnResolve() || (((Q = V.identifyOnResolve) == null ? void 0 : Q.call(V)) ?? !1)), X;
    },
    applyToStack: F,
    identify: () => Z(!0).map((V) => {
      const X = V.step ?? V.relation + " " + V.toMiddleware;
      return getMiddlewareNameWithAliases(V.name, V.aliases) + " - " + X;
    }),
    identifyOnResolve(V) {
      return typeof V == "boolean" && (x = V), x;
    },
    resolve: (V, X) => {
      for (const Q of Z().map((fe) => fe.middleware).reverse())
        V = Q(V, X);
      return x && console.log(H.identify()), V;
    }
  };
  return H;
}, stepWeights = {
  initialize: 5,
  serialize: 4,
  build: 3,
  finalizeRequest: 2,
  deserialize: 1
}, priorityWeights = {
  high: 3,
  normal: 2,
  low: 1
};
class Client {
  constructor(M) {
    this.config = M, this.middlewareStack = constructStack();
  }
  send(M, x, $) {
    const T = typeof x != "function" ? x : void 0, S = typeof x == "function" ? x : $, D = T === void 0 && this.config.cacheMiddleware === !0;
    let F;
    if (D) {
      this.handlers || (this.handlers = /* @__PURE__ */ new WeakMap());
      const z = this.handlers;
      z.has(M.constructor) ? F = z.get(M.constructor) : (F = M.resolveMiddleware(this.middlewareStack, this.config, T), z.set(M.constructor, F));
    } else
      delete this.handlers, F = M.resolveMiddleware(this.middlewareStack, this.config, T);
    if (S)
      F(M).then((z) => S(null, z.output), (z) => S(z)).catch(() => {
      });
    else
      return F(M).then((z) => z.output);
  }
  destroy() {
    var M, x, $;
    ($ = (x = (M = this.config) == null ? void 0 : M.requestHandler) == null ? void 0 : x.destroy) == null || $.call(x), delete this.handlers;
  }
}
class Command {
  constructor() {
    this.middlewareStack = constructStack();
  }
  static classBuilder() {
    return new ClassBuilder();
  }
  resolveMiddlewareWithContext(M, x, $, { middlewareFn: T, clientName: S, commandName: D, inputFilterSensitiveLog: F, outputFilterSensitiveLog: z, smithyContext: Z, additionalContext: H, CommandCtor: V }) {
    for (const me of T.bind(this)(V, M, x, $))
      this.middlewareStack.use(me);
    const X = M.concat(this.middlewareStack), { logger: Q } = x, fe = {
      logger: Q,
      clientName: S,
      commandName: D,
      inputFilterSensitiveLog: F,
      outputFilterSensitiveLog: z,
      [SMITHY_CONTEXT_KEY]: {
        commandInstance: this,
        ...Z
      },
      ...H
    }, { requestHandler: ce } = x;
    return X.resolve((me) => ce.handle(me.request, $ || {}), fe);
  }
}
class ClassBuilder {
  constructor() {
    this._init = () => {
    }, this._ep = {}, this._middlewareFn = () => [], this._commandName = "", this._clientName = "", this._additionalContext = {}, this._smithyContext = {}, this._inputFilterSensitiveLog = (M) => M, this._outputFilterSensitiveLog = (M) => M, this._serializer = null, this._deserializer = null;
  }
  init(M) {
    this._init = M;
  }
  ep(M) {
    return this._ep = M, this;
  }
  m(M) {
    return this._middlewareFn = M, this;
  }
  s(M, x, $ = {}) {
    return this._smithyContext = {
      service: M,
      operation: x,
      ...$
    }, this;
  }
  c(M = {}) {
    return this._additionalContext = M, this;
  }
  n(M, x) {
    return this._clientName = M, this._commandName = x, this;
  }
  f(M = ($) => $, x = ($) => $) {
    return this._inputFilterSensitiveLog = M, this._outputFilterSensitiveLog = x, this;
  }
  ser(M) {
    return this._serializer = M, this;
  }
  de(M) {
    return this._deserializer = M, this;
  }
  build() {
    const M = this;
    let x;
    return x = class extends Command {
      static getEndpointParameterInstructions() {
        return M._ep;
      }
      constructor(...[$]) {
        super(), this.serialize = M._serializer, this.deserialize = M._deserializer, this.input = $ ?? {}, M._init(this);
      }
      resolveMiddleware($, T, S) {
        return this.resolveMiddlewareWithContext($, T, S, {
          CommandCtor: x,
          middlewareFn: M._middlewareFn,
          clientName: M._clientName,
          commandName: M._commandName,
          inputFilterSensitiveLog: M._inputFilterSensitiveLog,
          outputFilterSensitiveLog: M._outputFilterSensitiveLog,
          smithyContext: M._smithyContext,
          additionalContext: M._additionalContext
        });
      }
    };
  }
}
class ServiceException extends Error {
  constructor(M) {
    super(M.message), Object.setPrototypeOf(this, Object.getPrototypeOf(this).constructor.prototype), this.name = M.name, this.$fault = M.$fault, this.$metadata = M.$metadata;
  }
  static isInstance(M) {
    if (!M)
      return !1;
    const x = M;
    return ServiceException.prototype.isPrototypeOf(x) || !!x.$fault && !!x.$metadata && (x.$fault === "client" || x.$fault === "server");
  }
  static [Symbol.hasInstance](M) {
    if (!M)
      return !1;
    const x = M;
    return this === ServiceException ? ServiceException.isInstance(M) : ServiceException.isInstance(M) ? x.name && this.name ? this.prototype.isPrototypeOf(M) || x.name === this.name : this.prototype.isPrototypeOf(M) : !1;
  }
}
const decorateServiceException = (w, M = {}) => {
  Object.entries(M).filter(([, $]) => $ !== void 0).forEach(([$, T]) => {
    (w[$] == null || w[$] === "") && (w[$] = T);
  });
  const x = w.message || w.Message || "UnknownError";
  return w.message = x, delete w.Message, w;
}, throwDefaultError$1 = ({ output: w, parsedBody: M, exceptionCtor: x, errorCode: $ }) => {
  const T = deserializeMetadata$1(w), S = T.httpStatusCode ? T.httpStatusCode + "" : void 0, D = new x({
    name: (M == null ? void 0 : M.code) || (M == null ? void 0 : M.Code) || $ || S || "UnknownError",
    $fault: "client",
    $metadata: T
  });
  throw decorateServiceException(D, M);
}, withBaseException = (w) => ({ output: M, parsedBody: x, errorCode: $ }) => {
  throwDefaultError$1({ output: M, parsedBody: x, exceptionCtor: w, errorCode: $ });
}, deserializeMetadata$1 = (w) => ({
  httpStatusCode: w.statusCode,
  requestId: w.headers["x-amzn-requestid"] ?? w.headers["x-amzn-request-id"] ?? w.headers["x-amz-request-id"],
  extendedRequestId: w.headers["x-amz-id-2"],
  cfId: w.headers["x-amz-cf-id"]
}), loadConfigsForDefaultMode = (w) => {
  switch (w) {
    case "standard":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "in-region":
      return {
        retryMode: "standard",
        connectionTimeout: 1100
      };
    case "cross-region":
      return {
        retryMode: "standard",
        connectionTimeout: 3100
      };
    case "mobile":
      return {
        retryMode: "standard",
        connectionTimeout: 3e4
      };
    default:
      return {};
  }
}, getChecksumConfiguration = (w) => {
  const M = [];
  for (const x in AlgorithmId) {
    const $ = AlgorithmId[x];
    w[$] !== void 0 && M.push({
      algorithmId: () => $,
      checksumConstructor: () => w[$]
    });
  }
  return {
    addChecksumAlgorithm(x) {
      M.push(x);
    },
    checksumAlgorithms() {
      return M;
    }
  };
}, resolveChecksumRuntimeConfig = (w) => {
  const M = {};
  return w.checksumAlgorithms().forEach((x) => {
    M[x.algorithmId()] = x.checksumConstructor();
  }), M;
}, getRetryConfiguration = (w) => ({
  setRetryStrategy(M) {
    w.retryStrategy = M;
  },
  retryStrategy() {
    return w.retryStrategy;
  }
}), resolveRetryRuntimeConfig = (w) => {
  const M = {};
  return M.retryStrategy = w.retryStrategy(), M;
}, getDefaultExtensionConfiguration = (w) => Object.assign(getChecksumConfiguration(w), getRetryConfiguration(w)), resolveDefaultRuntimeConfig = (w) => Object.assign(resolveChecksumRuntimeConfig(w), resolveRetryRuntimeConfig(w));
class NoOpLogger {
  trace() {
  }
  debug() {
  }
  info() {
  }
  warn() {
  }
  error() {
  }
}
const _json = (w) => {
  if (w == null)
    return {};
  if (Array.isArray(w))
    return w.filter((M) => M != null).map(_json);
  if (typeof w == "object") {
    const M = {};
    for (const x of Object.keys(w))
      w[x] != null && (M[x] = _json(w[x]));
    return M;
  }
  return w;
}, collectBodyString = (w, M) => collectBody(w, M).then((x) => M.utf8Encoder(x)), parseJsonBody = (w, M) => collectBodyString(w, M).then((x) => {
  if (x.length)
    try {
      return JSON.parse(x);
    } catch ($) {
      throw ($ == null ? void 0 : $.name) === "SyntaxError" && Object.defineProperty($, "$responseBodyText", {
        value: x
      }), $;
    }
  return {};
}), parseJsonErrorBody = async (w, M) => {
  const x = await parseJsonBody(w, M);
  return x.message = x.message ?? x.Message, x;
}, loadRestJsonErrorCode = (w, M) => {
  const x = (S, D) => Object.keys(S).find((F) => F.toLowerCase() === D.toLowerCase()), $ = (S) => {
    let D = S;
    return typeof D == "number" && (D = D.toString()), D.indexOf(",") >= 0 && (D = D.split(",")[0]), D.indexOf(":") >= 0 && (D = D.split(":")[0]), D.indexOf("#") >= 0 && (D = D.split("#")[1]), D;
  }, T = x(w.headers, "x-amzn-errortype");
  if (T !== void 0)
    return $(w.headers[T]);
  if (M.code !== void 0)
    return $(M.code);
  if (M.__type !== void 0)
    return $(M.__type);
}, ACCOUNT_ID_ENDPOINT_REGEX = /\d{12}\.ddb/;
async function checkFeatures(w, M, x) {
  var S, D, F, z, Z, H, V;
  const $ = x.request;
  if (((S = $ == null ? void 0 : $.headers) == null ? void 0 : S["smithy-protocol"]) === "rpc-v2-cbor" && setFeature(w, "PROTOCOL_RPC_V2_CBOR", "M"), typeof M.retryStrategy == "function") {
    const X = await M.retryStrategy();
    typeof X.acquireInitialRetryToken == "function" ? (F = (D = X.constructor) == null ? void 0 : D.name) != null && F.includes("Adaptive") ? setFeature(w, "RETRY_MODE_ADAPTIVE", "F") : setFeature(w, "RETRY_MODE_STANDARD", "E") : setFeature(w, "RETRY_MODE_LEGACY", "D");
  }
  if (typeof M.accountIdEndpointMode == "function") {
    const X = w.endpointV2;
    switch (String((z = X == null ? void 0 : X.url) == null ? void 0 : z.hostname).match(ACCOUNT_ID_ENDPOINT_REGEX) && setFeature(w, "ACCOUNT_ID_ENDPOINT", "O"), await ((Z = M.accountIdEndpointMode) == null ? void 0 : Z.call(M))) {
      case "disabled":
        setFeature(w, "ACCOUNT_ID_MODE_DISABLED", "Q");
        break;
      case "preferred":
        setFeature(w, "ACCOUNT_ID_MODE_PREFERRED", "P");
        break;
      case "required":
        setFeature(w, "ACCOUNT_ID_MODE_REQUIRED", "R");
        break;
    }
  }
  const T = (V = (H = w.__smithy_context) == null ? void 0 : H.selectedHttpAuthScheme) == null ? void 0 : V.identity;
  if (T != null && T.$source) {
    const X = T;
    X.accountId && setFeature(w, "RESOLVED_ACCOUNT_ID", "T");
    for (const [Q, fe] of Object.entries(X.$source ?? {}))
      setFeature(w, Q, fe);
  }
}
const USER_AGENT = "user-agent", X_AMZ_USER_AGENT = "x-amz-user-agent", SPACE = " ", UA_NAME_SEPARATOR = "/", UA_NAME_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g, UA_VALUE_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g, UA_ESCAPE_CHAR = "-", BYTE_LIMIT = 1024;
function encodeFeatures(w) {
  let M = "";
  for (const x in w) {
    const $ = w[x];
    if (M.length + $.length + 1 <= BYTE_LIMIT) {
      M.length ? M += "," + $ : M += $;
      continue;
    }
    break;
  }
  return M;
}
const userAgentMiddleware = (w) => (M, x) => async ($) => {
  var Q, fe, ce, me;
  const { request: T } = $;
  if (!HttpRequest.isInstance(T))
    return M($);
  const { headers: S } = T, D = ((Q = x == null ? void 0 : x.userAgent) == null ? void 0 : Q.map(escapeUserAgent)) || [], F = (await w.defaultUserAgentProvider()).map(escapeUserAgent);
  await checkFeatures(x, w, $);
  const z = x;
  F.push(`m/${encodeFeatures(Object.assign({}, (fe = x.__smithy_context) == null ? void 0 : fe.features, (ce = z.__aws_sdk_context) == null ? void 0 : ce.features))}`);
  const Z = ((me = w == null ? void 0 : w.customUserAgent) == null ? void 0 : me.map(escapeUserAgent)) || [], H = await w.userAgentAppId();
  H && F.push(escapeUserAgent([`app/${H}`]));
  const V = [].concat([...F, ...D, ...Z]).join(SPACE), X = [
    ...F.filter((de) => de.startsWith("aws-sdk-")),
    ...Z
  ].join(SPACE);
  return w.runtime !== "browser" ? (X && (S[X_AMZ_USER_AGENT] = S[X_AMZ_USER_AGENT] ? `${S[USER_AGENT]} ${X}` : X), S[USER_AGENT] = V) : S[X_AMZ_USER_AGENT] = V, M({
    ...$,
    request: T
  });
}, escapeUserAgent = (w) => {
  var D;
  const M = w[0].split(UA_NAME_SEPARATOR).map((F) => F.replace(UA_NAME_ESCAPE_REGEX, UA_ESCAPE_CHAR)).join(UA_NAME_SEPARATOR), x = (D = w[1]) == null ? void 0 : D.replace(UA_VALUE_ESCAPE_REGEX, UA_ESCAPE_CHAR), $ = M.indexOf(UA_NAME_SEPARATOR), T = M.substring(0, $);
  let S = M.substring($ + 1);
  return T === "api" && (S = S.toLowerCase()), [T, S, x].filter((F) => F && F.length > 0).reduce((F, z, Z) => {
    switch (Z) {
      case 0:
        return z;
      case 1:
        return `${F}/${z}`;
      default:
        return `${F}#${z}`;
    }
  }, "");
}, getUserAgentMiddlewareOptions = {
  name: "getUserAgentMiddleware",
  step: "build",
  priority: "low",
  tags: ["SET_USER_AGENT", "USER_AGENT"],
  override: !0
}, getUserAgentPlugin = (w) => ({
  applyToStack: (M) => {
    M.add(userAgentMiddleware(w), getUserAgentMiddlewareOptions);
  }
});
var SelectorType;
(function(w) {
  w.ENV = "env", w.CONFIG = "shared config entry";
})(SelectorType || (SelectorType = {}));
const DEFAULT_USE_DUALSTACK_ENDPOINT = !1, DEFAULT_USE_FIPS_ENDPOINT = !1, isFipsRegion = (w) => typeof w == "string" && (w.startsWith("fips-") || w.endsWith("-fips")), getRealRegion = (w) => isFipsRegion(w) ? ["fips-aws-global", "aws-fips"].includes(w) ? "us-east-1" : w.replace(/fips-(dkr-|prod-)?|-fips/, "") : w, resolveRegionConfig = (w) => {
  const { region: M, useFipsEndpoint: x } = w;
  if (!M)
    throw new Error("Region is missing");
  return Object.assign(w, {
    region: async () => {
      if (typeof M == "string")
        return getRealRegion(M);
      const $ = await M();
      return getRealRegion($);
    },
    useFipsEndpoint: async () => {
      const $ = typeof M == "string" ? M : await M();
      return isFipsRegion($) ? !0 : typeof x != "function" ? Promise.resolve(!!x) : x();
    }
  });
}, CONTENT_LENGTH_HEADER = "content-length";
function contentLengthMiddleware(w) {
  return (M) => async (x) => {
    const $ = x.request;
    if (HttpRequest.isInstance($)) {
      const { body: T, headers: S } = $;
      if (T && Object.keys(S).map((D) => D.toLowerCase()).indexOf(CONTENT_LENGTH_HEADER) === -1)
        try {
          const D = w(T);
          $.headers = {
            ...$.headers,
            [CONTENT_LENGTH_HEADER]: String(D)
          };
        } catch {
        }
    }
    return M({
      ...x,
      request: $
    });
  };
}
const contentLengthMiddlewareOptions = {
  step: "build",
  tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
  name: "contentLengthMiddleware",
  override: !0
}, getContentLengthPlugin = (w) => ({
  applyToStack: (M) => {
    M.add(contentLengthMiddleware(w.bodyLengthChecker), contentLengthMiddlewareOptions);
  }
}), resolveParamsForS3 = async (w) => {
  const M = (w == null ? void 0 : w.Bucket) || "";
  if (typeof w.Bucket == "string" && (w.Bucket = M.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"))), isArnBucketName(M)) {
    if (w.ForcePathStyle === !0)
      throw new Error("Path-style addressing cannot be used with ARN buckets");
  } else (!isDnsCompatibleBucketName(M) || M.indexOf(".") !== -1 && !String(w.Endpoint).startsWith("http:") || M.toLowerCase() !== M || M.length < 3) && (w.ForcePathStyle = !0);
  return w.DisableMultiRegionAccessPoints && (w.disableMultiRegionAccessPoints = !0, w.DisableMRAP = !0), w;
}, DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/, IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/, DOTS_PATTERN = /\.\./, isDnsCompatibleBucketName = (w) => DOMAIN_PATTERN.test(w) && !IP_ADDRESS_PATTERN.test(w) && !DOTS_PATTERN.test(w), isArnBucketName = (w) => {
  const [M, x, $, , , T] = w.split(":"), S = M === "arn" && w.split(":").length >= 6, D = !!(S && x && $ && T);
  if (S && !D)
    throw new Error(`Invalid ARN: ${w} was an invalid ARN.`);
  return D;
}, createConfigValueProvider = (w, M, x) => {
  const $ = async () => {
    const T = x[w] ?? x[M];
    return typeof T == "function" ? T() : T;
  };
  return w === "credentialScope" || M === "CredentialScope" ? async () => {
    const T = typeof x.credentials == "function" ? await x.credentials() : x.credentials;
    return (T == null ? void 0 : T.credentialScope) ?? (T == null ? void 0 : T.CredentialScope);
  } : w === "accountId" || M === "AccountId" ? async () => {
    const T = typeof x.credentials == "function" ? await x.credentials() : x.credentials;
    return (T == null ? void 0 : T.accountId) ?? (T == null ? void 0 : T.AccountId);
  } : w === "endpoint" || M === "endpoint" ? async () => {
    const T = await $();
    if (T && typeof T == "object") {
      if ("url" in T)
        return T.url.href;
      if ("hostname" in T) {
        const { protocol: S, hostname: D, port: F, path: z } = T;
        return `${S}//${D}${F ? ":" + F : ""}${z}`;
      }
    }
    return T;
  } : $;
}, getEndpointFromConfig = async (w) => {
};
function parseQueryString(w) {
  const M = {};
  if (w = w.replace(/^\?/, ""), w)
    for (const x of w.split("&")) {
      let [$, T = null] = x.split("=");
      $ = decodeURIComponent($), T && (T = decodeURIComponent(T)), $ in M ? Array.isArray(M[$]) ? M[$].push(T) : M[$] = [M[$], T] : M[$] = T;
    }
  return M;
}
const parseUrl = (w) => {
  if (typeof w == "string")
    return parseUrl(new URL(w));
  const { hostname: M, pathname: x, port: $, protocol: T, search: S } = w;
  let D;
  return S && (D = parseQueryString(S)), {
    hostname: M,
    port: $ ? parseInt($) : void 0,
    protocol: T,
    path: x,
    query: D
  };
}, toEndpointV1 = (w) => typeof w == "object" ? "url" in w ? parseUrl(w.url) : w : parseUrl(w), getEndpointFromInstructions = async (w, M, x, $) => {
  if (!x.endpoint) {
    let D;
    x.serviceConfiguredEndpoint ? D = await x.serviceConfiguredEndpoint() : D = await getEndpointFromConfig(x.serviceId), D && (x.endpoint = () => Promise.resolve(toEndpointV1(D)));
  }
  const T = await resolveParams(w, M, x);
  if (typeof x.endpointProvider != "function")
    throw new Error("config.endpointProvider is not set.");
  return x.endpointProvider(T, $);
}, resolveParams = async (w, M, x) => {
  var S;
  const $ = {}, T = ((S = M == null ? void 0 : M.getEndpointParameterInstructions) == null ? void 0 : S.call(M)) || {};
  for (const [D, F] of Object.entries(T))
    switch (F.type) {
      case "staticContextParams":
        $[D] = F.value;
        break;
      case "contextParams":
        $[D] = w[F.name];
        break;
      case "clientContextParams":
      case "builtInParams":
        $[D] = await createConfigValueProvider(F.name, D, x)();
        break;
      case "operationContextParams":
        $[D] = F.get(w);
        break;
      default:
        throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(F));
    }
  return Object.keys(T).length === 0 && Object.assign($, x), String(x.serviceId).toLowerCase() === "s3" && await resolveParamsForS3($), $;
}, endpointMiddleware = ({ config: w, instructions: M }) => (x, $) => async (T) => {
  var F, z, Z;
  w.endpoint && setFeature$1($, "ENDPOINT_OVERRIDE", "N");
  const S = await getEndpointFromInstructions(T.input, {
    getEndpointParameterInstructions() {
      return M;
    }
  }, { ...w }, $);
  $.endpointV2 = S, $.authSchemes = (F = S.properties) == null ? void 0 : F.authSchemes;
  const D = (z = $.authSchemes) == null ? void 0 : z[0];
  if (D) {
    $.signing_region = D.signingRegion, $.signing_service = D.signingName;
    const H = getSmithyContext($), V = (Z = H == null ? void 0 : H.selectedHttpAuthScheme) == null ? void 0 : Z.httpAuthOption;
    V && (V.signingProperties = Object.assign(V.signingProperties || {}, {
      signing_region: D.signingRegion,
      signingRegion: D.signingRegion,
      signing_service: D.signingName,
      signingName: D.signingName,
      signingRegionSet: D.signingRegionSet
    }, D.properties));
  }
  return x({
    ...T
  });
}, endpointMiddlewareOptions = {
  step: "serialize",
  tags: ["ENDPOINT_PARAMETERS", "ENDPOINT_V2", "ENDPOINT"],
  name: "endpointV2Middleware",
  override: !0,
  relation: "before",
  toMiddleware: serializerMiddlewareOption.name
}, getEndpointPlugin = (w, M) => ({
  applyToStack: (x) => {
    x.addRelativeTo(endpointMiddleware({
      config: w,
      instructions: M
    }), endpointMiddlewareOptions);
  }
}), resolveEndpointConfig = (w) => {
  const M = w.tls ?? !0, { endpoint: x, useDualstackEndpoint: $, useFipsEndpoint: T } = w, S = x != null ? async () => toEndpointV1(await normalizeProvider$1(x)()) : void 0, F = Object.assign(w, {
    endpoint: S,
    tls: M,
    isCustomEndpoint: !!x,
    useDualstackEndpoint: normalizeProvider$1($ ?? !1),
    useFipsEndpoint: normalizeProvider$1(T ?? !1)
  });
  let z;
  return F.serviceConfiguredEndpoint = async () => (w.serviceId && !z && (z = getEndpointFromConfig(w.serviceId)), z), F;
};
var RETRY_MODES;
(function(w) {
  w.STANDARD = "standard", w.ADAPTIVE = "adaptive";
})(RETRY_MODES || (RETRY_MODES = {}));
const DEFAULT_MAX_ATTEMPTS = 3, DEFAULT_RETRY_MODE = RETRY_MODES.STANDARD, THROTTLING_ERROR_CODES = [
  "BandwidthLimitExceeded",
  "EC2ThrottledException",
  "LimitExceededException",
  "PriorRequestNotComplete",
  "ProvisionedThroughputExceededException",
  "RequestLimitExceeded",
  "RequestThrottled",
  "RequestThrottledException",
  "SlowDown",
  "ThrottledException",
  "Throttling",
  "ThrottlingException",
  "TooManyRequestsException",
  "TransactionInProgressException"
], TRANSIENT_ERROR_CODES = ["TimeoutError", "RequestTimeout", "RequestTimeoutException"], TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504], NODEJS_TIMEOUT_ERROR_CODES = ["ECONNRESET", "ECONNREFUSED", "EPIPE", "ETIMEDOUT"], isClockSkewCorrectedError = (w) => {
  var M;
  return (M = w.$metadata) == null ? void 0 : M.clockSkewCorrected;
}, isBrowserNetworkError = (w) => {
  const M = /* @__PURE__ */ new Set([
    "Failed to fetch",
    "NetworkError when attempting to fetch resource",
    "The Internet connection appears to be offline",
    "Load failed",
    "Network request failed"
  ]);
  return w && w instanceof TypeError ? M.has(w.message) : !1;
}, isThrottlingError = (w) => {
  var M, x;
  return ((M = w.$metadata) == null ? void 0 : M.httpStatusCode) === 429 || THROTTLING_ERROR_CODES.includes(w.name) || ((x = w.$retryable) == null ? void 0 : x.throttling) == !0;
}, isTransientError = (w, M = 0) => {
  var x;
  return isClockSkewCorrectedError(w) || TRANSIENT_ERROR_CODES.includes(w.name) || NODEJS_TIMEOUT_ERROR_CODES.includes((w == null ? void 0 : w.code) || "") || TRANSIENT_ERROR_STATUS_CODES.includes(((x = w.$metadata) == null ? void 0 : x.httpStatusCode) || 0) || isBrowserNetworkError(w) || w.cause !== void 0 && M <= 10 && isTransientError(w.cause, M + 1);
}, isServerError = (w) => {
  var M;
  if (((M = w.$metadata) == null ? void 0 : M.httpStatusCode) !== void 0) {
    const x = w.$metadata.httpStatusCode;
    return 500 <= x && x <= 599 && !isTransientError(w);
  }
  return !1;
};
class DefaultRateLimiter {
  constructor(M) {
    this.currentCapacity = 0, this.enabled = !1, this.lastMaxRate = 0, this.measuredTxRate = 0, this.requestCount = 0, this.lastTimestamp = 0, this.timeWindow = 0, this.beta = (M == null ? void 0 : M.beta) ?? 0.7, this.minCapacity = (M == null ? void 0 : M.minCapacity) ?? 1, this.minFillRate = (M == null ? void 0 : M.minFillRate) ?? 0.5, this.scaleConstant = (M == null ? void 0 : M.scaleConstant) ?? 0.4, this.smooth = (M == null ? void 0 : M.smooth) ?? 0.8;
    const x = this.getCurrentTimeInSeconds();
    this.lastThrottleTime = x, this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds()), this.fillRate = this.minFillRate, this.maxCapacity = this.minCapacity;
  }
  getCurrentTimeInSeconds() {
    return Date.now() / 1e3;
  }
  async getSendToken() {
    return this.acquireTokenBucket(1);
  }
  async acquireTokenBucket(M) {
    if (this.enabled) {
      if (this.refillTokenBucket(), M > this.currentCapacity) {
        const x = (M - this.currentCapacity) / this.fillRate * 1e3;
        await new Promise(($) => DefaultRateLimiter.setTimeoutFn($, x));
      }
      this.currentCapacity = this.currentCapacity - M;
    }
  }
  refillTokenBucket() {
    const M = this.getCurrentTimeInSeconds();
    if (!this.lastTimestamp) {
      this.lastTimestamp = M;
      return;
    }
    const x = (M - this.lastTimestamp) * this.fillRate;
    this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + x), this.lastTimestamp = M;
  }
  updateClientSendingRate(M) {
    let x;
    if (this.updateMeasuredRate(), isThrottlingError(M)) {
      const T = this.enabled ? Math.min(this.measuredTxRate, this.fillRate) : this.measuredTxRate;
      this.lastMaxRate = T, this.calculateTimeWindow(), this.lastThrottleTime = this.getCurrentTimeInSeconds(), x = this.cubicThrottle(T), this.enableTokenBucket();
    } else
      this.calculateTimeWindow(), x = this.cubicSuccess(this.getCurrentTimeInSeconds());
    const $ = Math.min(x, 2 * this.measuredTxRate);
    this.updateTokenBucketRate($);
  }
  calculateTimeWindow() {
    this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));
  }
  cubicThrottle(M) {
    return this.getPrecise(M * this.beta);
  }
  cubicSuccess(M) {
    return this.getPrecise(this.scaleConstant * Math.pow(M - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
  }
  enableTokenBucket() {
    this.enabled = !0;
  }
  updateTokenBucketRate(M) {
    this.refillTokenBucket(), this.fillRate = Math.max(M, this.minFillRate), this.maxCapacity = Math.max(M, this.minCapacity), this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
  }
  updateMeasuredRate() {
    const M = this.getCurrentTimeInSeconds(), x = Math.floor(M * 2) / 2;
    if (this.requestCount++, x > this.lastTxRateBucket) {
      const $ = this.requestCount / (x - this.lastTxRateBucket);
      this.measuredTxRate = this.getPrecise($ * this.smooth + this.measuredTxRate * (1 - this.smooth)), this.requestCount = 0, this.lastTxRateBucket = x;
    }
  }
  getPrecise(M) {
    return parseFloat(M.toFixed(8));
  }
}
DefaultRateLimiter.setTimeoutFn = setTimeout;
const DEFAULT_RETRY_DELAY_BASE = 100, MAXIMUM_RETRY_DELAY = 20 * 1e3, THROTTLING_RETRY_DELAY_BASE = 500, INITIAL_RETRY_TOKENS = 500, RETRY_COST = 5, TIMEOUT_RETRY_COST = 10, NO_RETRY_INCREMENT = 1, INVOCATION_ID_HEADER = "amz-sdk-invocation-id", REQUEST_HEADER = "amz-sdk-request", getDefaultRetryBackoffStrategy = () => {
  let w = DEFAULT_RETRY_DELAY_BASE;
  return {
    computeNextBackoffDelay: ($) => Math.floor(Math.min(MAXIMUM_RETRY_DELAY, Math.random() * 2 ** $ * w)),
    setDelayBase: ($) => {
      w = $;
    }
  };
}, createDefaultRetryToken = ({ retryDelay: w, retryCount: M, retryCost: x }) => ({
  getRetryCount: () => M,
  getRetryDelay: () => Math.min(MAXIMUM_RETRY_DELAY, w),
  getRetryCost: () => x
});
class StandardRetryStrategy {
  constructor(M) {
    this.maxAttempts = M, this.mode = RETRY_MODES.STANDARD, this.capacity = INITIAL_RETRY_TOKENS, this.retryBackoffStrategy = getDefaultRetryBackoffStrategy(), this.maxAttemptsProvider = typeof M == "function" ? M : async () => M;
  }
  async acquireInitialRetryToken(M) {
    return createDefaultRetryToken({
      retryDelay: DEFAULT_RETRY_DELAY_BASE,
      retryCount: 0
    });
  }
  async refreshRetryTokenForRetry(M, x) {
    const $ = await this.getMaxAttempts();
    if (this.shouldRetry(M, x, $)) {
      const T = x.errorType;
      this.retryBackoffStrategy.setDelayBase(T === "THROTTLING" ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE);
      const S = this.retryBackoffStrategy.computeNextBackoffDelay(M.getRetryCount()), D = x.retryAfterHint ? Math.max(x.retryAfterHint.getTime() - Date.now() || 0, S) : S, F = this.getCapacityCost(T);
      return this.capacity -= F, createDefaultRetryToken({
        retryDelay: D,
        retryCount: M.getRetryCount() + 1,
        retryCost: F
      });
    }
    throw new Error("No retry token available");
  }
  recordSuccess(M) {
    this.capacity = Math.max(INITIAL_RETRY_TOKENS, this.capacity + (M.getRetryCost() ?? NO_RETRY_INCREMENT));
  }
  getCapacity() {
    return this.capacity;
  }
  async getMaxAttempts() {
    try {
      return await this.maxAttemptsProvider();
    } catch {
      return console.warn(`Max attempts provider could not resolve. Using default of ${DEFAULT_MAX_ATTEMPTS}`), DEFAULT_MAX_ATTEMPTS;
    }
  }
  shouldRetry(M, x, $) {
    return M.getRetryCount() + 1 < $ && this.capacity >= this.getCapacityCost(x.errorType) && this.isRetryableError(x.errorType);
  }
  getCapacityCost(M) {
    return M === "TRANSIENT" ? TIMEOUT_RETRY_COST : RETRY_COST;
  }
  isRetryableError(M) {
    return M === "THROTTLING" || M === "TRANSIENT";
  }
}
class AdaptiveRetryStrategy {
  constructor(M, x) {
    this.maxAttemptsProvider = M, this.mode = RETRY_MODES.ADAPTIVE;
    const { rateLimiter: $ } = x ?? {};
    this.rateLimiter = $ ?? new DefaultRateLimiter(), this.standardRetryStrategy = new StandardRetryStrategy(M);
  }
  async acquireInitialRetryToken(M) {
    return await this.rateLimiter.getSendToken(), this.standardRetryStrategy.acquireInitialRetryToken(M);
  }
  async refreshRetryTokenForRetry(M, x) {
    return this.rateLimiter.updateClientSendingRate(x), this.standardRetryStrategy.refreshRetryTokenForRetry(M, x);
  }
  recordSuccess(M) {
    this.rateLimiter.updateClientSendingRate({}), this.standardRetryStrategy.recordSuccess(M);
  }
}
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues && (getRandomValues = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !getRandomValues))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return getRandomValues(rnds8);
}
const byteToHex = [];
for (let w = 0; w < 256; ++w)
  byteToHex.push((w + 256).toString(16).slice(1));
function unsafeStringify(w, M = 0) {
  return byteToHex[w[M + 0]] + byteToHex[w[M + 1]] + byteToHex[w[M + 2]] + byteToHex[w[M + 3]] + "-" + byteToHex[w[M + 4]] + byteToHex[w[M + 5]] + "-" + byteToHex[w[M + 6]] + byteToHex[w[M + 7]] + "-" + byteToHex[w[M + 8]] + byteToHex[w[M + 9]] + "-" + byteToHex[w[M + 10]] + byteToHex[w[M + 11]] + byteToHex[w[M + 12]] + byteToHex[w[M + 13]] + byteToHex[w[M + 14]] + byteToHex[w[M + 15]];
}
const randomUUID = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), native = {
  randomUUID
};
function v4(w, M, x) {
  if (native.randomUUID && !w)
    return native.randomUUID();
  w = w || {};
  const $ = w.random || (w.rng || rng)();
  return $[6] = $[6] & 15 | 64, $[8] = $[8] & 63 | 128, unsafeStringify($);
}
const asSdkError = (w) => w instanceof Error ? w : w instanceof Object ? Object.assign(new Error(), w) : typeof w == "string" ? new Error(w) : new Error(`AWS SDK error wrapper for ${w}`), resolveRetryConfig = (w) => {
  const { retryStrategy: M, retryMode: x, maxAttempts: $ } = w, T = normalizeProvider$1($ ?? DEFAULT_MAX_ATTEMPTS);
  return Object.assign(w, {
    maxAttempts: T,
    retryStrategy: async () => M || (await normalizeProvider$1(x)() === RETRY_MODES.ADAPTIVE ? new AdaptiveRetryStrategy(T) : new StandardRetryStrategy(T))
  });
}, isStreamingPayload = (w) => (w == null ? void 0 : w.body) instanceof ReadableStream, retryMiddleware = (w) => (M, x) => async ($) => {
  var D;
  let T = await w.retryStrategy();
  const S = await w.maxAttempts();
  if (isRetryStrategyV2(T)) {
    T = T;
    let F = await T.acquireInitialRetryToken(x.partition_id), z = new Error(), Z = 0, H = 0;
    const { request: V } = $, X = HttpRequest.isInstance(V);
    for (X && (V.headers[INVOCATION_ID_HEADER] = v4()); ; )
      try {
        X && (V.headers[REQUEST_HEADER] = `attempt=${Z + 1}; max=${S}`);
        const { response: Q, output: fe } = await M($);
        return T.recordSuccess(F), fe.$metadata.attempts = Z + 1, fe.$metadata.totalRetryDelay = H, { response: Q, output: fe };
      } catch (Q) {
        const fe = getRetryErrorInfo(Q);
        if (z = asSdkError(Q), X && isStreamingPayload(V))
          throw (D = x.logger instanceof NoOpLogger ? console : x.logger) == null || D.warn("An error was encountered in a non-retryable streaming request."), z;
        try {
          F = await T.refreshRetryTokenForRetry(F, fe);
        } catch {
          throw z.$metadata || (z.$metadata = {}), z.$metadata.attempts = Z + 1, z.$metadata.totalRetryDelay = H, z;
        }
        Z = F.getRetryCount();
        const ce = F.getRetryDelay();
        H += ce, await new Promise((me) => setTimeout(me, ce));
      }
  } else
    return T = T, T != null && T.mode && (x.userAgent = [...x.userAgent || [], ["cfg/retry-mode", T.mode]]), T.retry(M, $);
}, isRetryStrategyV2 = (w) => typeof w.acquireInitialRetryToken < "u" && typeof w.refreshRetryTokenForRetry < "u" && typeof w.recordSuccess < "u", getRetryErrorInfo = (w) => {
  const M = {
    error: w,
    errorType: getRetryErrorType(w)
  }, x = getRetryAfterHint(w.$response);
  return x && (M.retryAfterHint = x), M;
}, getRetryErrorType = (w) => isThrottlingError(w) ? "THROTTLING" : isTransientError(w) ? "TRANSIENT" : isServerError(w) ? "SERVER_ERROR" : "CLIENT_ERROR", retryMiddlewareOptions = {
  name: "retryMiddleware",
  tags: ["RETRY"],
  step: "finalizeRequest",
  priority: "high",
  override: !0
}, getRetryPlugin = (w) => ({
  applyToStack: (M) => {
    M.add(retryMiddleware(w), retryMiddlewareOptions);
  }
}), getRetryAfterHint = (w) => {
  if (!HttpResponse.isInstance(w))
    return;
  const M = Object.keys(w.headers).find((S) => S.toLowerCase() === "retry-after");
  if (!M)
    return;
  const x = w.headers[M], $ = Number(x);
  return Number.isNaN($) ? new Date(x) : new Date($ * 1e3);
}, defaultTranslateHttpAuthSchemeParametersProvider = async (w, M, x) => ({
  operation: getSmithyContext(M).operation,
  region: await normalizeProvider$1(w.region)() || (() => {
    throw new Error("expected `region` to be configured for `aws.auth#sigv4`");
  })()
});
function createAwsAuthSigv4HttpAuthOption(w) {
  return {
    schemeId: "aws.auth#sigv4",
    signingProperties: {
      name: "translate",
      region: w.region
    },
    propertiesExtractor: (M, x) => ({
      signingProperties: {
        config: M,
        context: x
      }
    })
  };
}
const defaultTranslateHttpAuthSchemeProvider = (w) => {
  const M = [];
  switch (w.operation) {
    default:
      M.push(createAwsAuthSigv4HttpAuthOption(w));
  }
  return M;
}, resolveHttpAuthSchemeConfig = (w) => {
  const M = resolveAwsSdkSigV4Config(w);
  return Object.assign(M, {
    authSchemePreference: normalizeProvider$1(w.authSchemePreference ?? [])
  });
}, resolveClientEndpointParameters = (w) => Object.assign(w, {
  useDualstackEndpoint: w.useDualstackEndpoint ?? !1,
  useFipsEndpoint: w.useFipsEndpoint ?? !1,
  defaultSigningName: "translate"
}), commonParams = {
  UseFIPS: { type: "builtInParams", name: "useFipsEndpoint" },
  Endpoint: { type: "builtInParams", name: "endpoint" },
  Region: { type: "builtInParams", name: "region" },
  UseDualStack: { type: "builtInParams", name: "useDualstackEndpoint" }
}, version$3 = "3.808.0", packageInfo = {
  version: version$3
}, fromUtf8$1 = (w) => new TextEncoder().encode(w);
var fromUtf8 = typeof Buffer$D < "u" && Buffer$D.from ? function(w) {
  return Buffer$D.from(w, "utf8");
} : fromUtf8$1;
function convertToBuffer(w) {
  return w instanceof Uint8Array ? w : typeof w == "string" ? fromUtf8(w) : ArrayBuffer.isView(w) ? new Uint8Array(w.buffer, w.byteOffset, w.byteLength / Uint8Array.BYTES_PER_ELEMENT) : new Uint8Array(w);
}
function isEmptyData(w) {
  return typeof w == "string" ? w.length === 0 : w.byteLength === 0;
}
var SHA_256_HASH = { name: "SHA-256" }, SHA_256_HMAC_ALGO = {
  name: "HMAC",
  hash: SHA_256_HASH
}, EMPTY_DATA_SHA_256 = new Uint8Array([
  227,
  176,
  196,
  66,
  152,
  252,
  28,
  20,
  154,
  251,
  244,
  200,
  153,
  111,
  185,
  36,
  39,
  174,
  65,
  228,
  100,
  155,
  147,
  76,
  164,
  149,
  153,
  27,
  120,
  82,
  184,
  85
]);
const fallbackWindow = {};
function locateWindow() {
  return typeof window < "u" ? window : typeof self < "u" ? self : fallbackWindow;
}
var Sha256$4 = (
  /** @class */
  function() {
    function w(M) {
      this.toHash = new Uint8Array(0), this.secret = M, this.reset();
    }
    return w.prototype.update = function(M) {
      if (!isEmptyData(M)) {
        var x = convertToBuffer(M), $ = new Uint8Array(this.toHash.byteLength + x.byteLength);
        $.set(this.toHash, 0), $.set(x, this.toHash.byteLength), this.toHash = $;
      }
    }, w.prototype.digest = function() {
      var M = this;
      return this.key ? this.key.then(function(x) {
        return locateWindow().crypto.subtle.sign(SHA_256_HMAC_ALGO, x, M.toHash).then(function($) {
          return new Uint8Array($);
        });
      }) : isEmptyData(this.toHash) ? Promise.resolve(EMPTY_DATA_SHA_256) : Promise.resolve().then(function() {
        return locateWindow().crypto.subtle.digest(SHA_256_HASH, M.toHash);
      }).then(function(x) {
        return Promise.resolve(new Uint8Array(x));
      });
    }, w.prototype.reset = function() {
      var M = this;
      this.toHash = new Uint8Array(0), this.secret && this.secret !== void 0 && (this.key = new Promise(function(x, $) {
        locateWindow().crypto.subtle.importKey("raw", convertToBuffer(M.secret), SHA_256_HMAC_ALGO, !1, ["sign"]).then(x, $);
      }), this.key.catch(function() {
      }));
    }, w;
  }()
);
function __awaiter(w, M, x, $) {
  function T(S) {
    return S instanceof x ? S : new x(function(D) {
      D(S);
    });
  }
  return new (x || (x = Promise))(function(S, D) {
    function F(H) {
      try {
        Z($.next(H));
      } catch (V) {
        D(V);
      }
    }
    function z(H) {
      try {
        Z($.throw(H));
      } catch (V) {
        D(V);
      }
    }
    function Z(H) {
      H.done ? S(H.value) : T(H.value).then(F, z);
    }
    Z(($ = $.apply(w, M || [])).next());
  });
}
function __generator(w, M) {
  var x = { label: 0, sent: function() {
    if (S[0] & 1) throw S[1];
    return S[1];
  }, trys: [], ops: [] }, $, T, S, D = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
  return D.next = F(0), D.throw = F(1), D.return = F(2), typeof Symbol == "function" && (D[Symbol.iterator] = function() {
    return this;
  }), D;
  function F(Z) {
    return function(H) {
      return z([Z, H]);
    };
  }
  function z(Z) {
    if ($) throw new TypeError("Generator is already executing.");
    for (; D && (D = 0, Z[0] && (x = 0)), x; ) try {
      if ($ = 1, T && (S = Z[0] & 2 ? T.return : Z[0] ? T.throw || ((S = T.return) && S.call(T), 0) : T.next) && !(S = S.call(T, Z[1])).done) return S;
      switch (T = 0, S && (Z = [Z[0] & 2, S.value]), Z[0]) {
        case 0:
        case 1:
          S = Z;
          break;
        case 4:
          return x.label++, { value: Z[1], done: !1 };
        case 5:
          x.label++, T = Z[1], Z = [0];
          continue;
        case 7:
          Z = x.ops.pop(), x.trys.pop();
          continue;
        default:
          if (S = x.trys, !(S = S.length > 0 && S[S.length - 1]) && (Z[0] === 6 || Z[0] === 2)) {
            x = 0;
            continue;
          }
          if (Z[0] === 3 && (!S || Z[1] > S[0] && Z[1] < S[3])) {
            x.label = Z[1];
            break;
          }
          if (Z[0] === 6 && x.label < S[1]) {
            x.label = S[1], S = Z;
            break;
          }
          if (S && x.label < S[2]) {
            x.label = S[2], x.ops.push(Z);
            break;
          }
          S[2] && x.ops.pop(), x.trys.pop();
          continue;
      }
      Z = M.call(w, x);
    } catch (H) {
      Z = [6, H], T = 0;
    } finally {
      $ = S = 0;
    }
    if (Z[0] & 5) throw Z[1];
    return { value: Z[0] ? Z[1] : void 0, done: !0 };
  }
}
typeof SuppressedError == "function" && SuppressedError;
var BLOCK_SIZE = 64, DIGEST_LENGTH = 32, KEY = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), INIT = [
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
], MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1, RawSha256 = (
  /** @class */
  function() {
    function w() {
      this.state = Int32Array.from(INIT), this.temp = new Int32Array(64), this.buffer = new Uint8Array(64), this.bufferLength = 0, this.bytesHashed = 0, this.finished = !1;
    }
    return w.prototype.update = function(M) {
      if (this.finished)
        throw new Error("Attempted to update an already finished hash.");
      var x = 0, $ = M.byteLength;
      if (this.bytesHashed += $, this.bytesHashed * 8 > MAX_HASHABLE_LENGTH)
        throw new Error("Cannot hash more than 2^53 - 1 bits");
      for (; $ > 0; )
        this.buffer[this.bufferLength++] = M[x++], $--, this.bufferLength === BLOCK_SIZE && (this.hashBuffer(), this.bufferLength = 0);
    }, w.prototype.digest = function() {
      if (!this.finished) {
        var M = this.bytesHashed * 8, x = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength), $ = this.bufferLength;
        if (x.setUint8(this.bufferLength++, 128), $ % BLOCK_SIZE >= BLOCK_SIZE - 8) {
          for (var T = this.bufferLength; T < BLOCK_SIZE; T++)
            x.setUint8(T, 0);
          this.hashBuffer(), this.bufferLength = 0;
        }
        for (var T = this.bufferLength; T < BLOCK_SIZE - 8; T++)
          x.setUint8(T, 0);
        x.setUint32(BLOCK_SIZE - 8, Math.floor(M / 4294967296), !0), x.setUint32(BLOCK_SIZE - 4, M), this.hashBuffer(), this.finished = !0;
      }
      for (var S = new Uint8Array(DIGEST_LENGTH), T = 0; T < 8; T++)
        S[T * 4] = this.state[T] >>> 24 & 255, S[T * 4 + 1] = this.state[T] >>> 16 & 255, S[T * 4 + 2] = this.state[T] >>> 8 & 255, S[T * 4 + 3] = this.state[T] >>> 0 & 255;
      return S;
    }, w.prototype.hashBuffer = function() {
      for (var M = this, x = M.buffer, $ = M.state, T = $[0], S = $[1], D = $[2], F = $[3], z = $[4], Z = $[5], H = $[6], V = $[7], X = 0; X < BLOCK_SIZE; X++) {
        if (X < 16)
          this.temp[X] = (x[X * 4] & 255) << 24 | (x[X * 4 + 1] & 255) << 16 | (x[X * 4 + 2] & 255) << 8 | x[X * 4 + 3] & 255;
        else {
          var Q = this.temp[X - 2], fe = (Q >>> 17 | Q << 15) ^ (Q >>> 19 | Q << 13) ^ Q >>> 10;
          Q = this.temp[X - 15];
          var ce = (Q >>> 7 | Q << 25) ^ (Q >>> 18 | Q << 14) ^ Q >>> 3;
          this.temp[X] = (fe + this.temp[X - 7] | 0) + (ce + this.temp[X - 16] | 0);
        }
        var me = (((z >>> 6 | z << 26) ^ (z >>> 11 | z << 21) ^ (z >>> 25 | z << 7)) + (z & Z ^ ~z & H) | 0) + (V + (KEY[X] + this.temp[X] | 0) | 0) | 0, de = ((T >>> 2 | T << 30) ^ (T >>> 13 | T << 19) ^ (T >>> 22 | T << 10)) + (T & S ^ T & D ^ S & D) | 0;
        V = H, H = Z, Z = z, z = F + me | 0, F = D, D = S, S = T, T = me + de | 0;
      }
      $[0] += T, $[1] += S, $[2] += D, $[3] += F, $[4] += z, $[5] += Z, $[6] += H, $[7] += V;
    }, w;
  }()
), Sha256$3 = (
  /** @class */
  function() {
    function w(M) {
      this.secret = M, this.hash = new RawSha256(), this.reset();
    }
    return w.prototype.update = function(M) {
      if (!(isEmptyData(M) || this.error))
        try {
          this.hash.update(convertToBuffer(M));
        } catch (x) {
          this.error = x;
        }
    }, w.prototype.digestSync = function() {
      if (this.error)
        throw this.error;
      return this.outer ? (this.outer.finished || this.outer.update(this.hash.digest()), this.outer.digest()) : this.hash.digest();
    }, w.prototype.digest = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(M) {
          return [2, this.digestSync()];
        });
      });
    }, w.prototype.reset = function() {
      if (this.hash = new RawSha256(), this.secret) {
        this.outer = new RawSha256();
        var M = bufferFromSecret(this.secret), x = new Uint8Array(BLOCK_SIZE);
        x.set(M);
        for (var $ = 0; $ < BLOCK_SIZE; $++)
          M[$] ^= 54, x[$] ^= 92;
        this.hash.update(M), this.outer.update(x);
        for (var $ = 0; $ < M.byteLength; $++)
          M[$] = 0;
      }
    }, w;
  }()
);
function bufferFromSecret(w) {
  var M = convertToBuffer(w);
  if (M.byteLength > BLOCK_SIZE) {
    var x = new RawSha256();
    x.update(M), M = x.digest();
  }
  var $ = new Uint8Array(BLOCK_SIZE);
  return $.set(M), $;
}
var subtleCryptoMethods = [
  "decrypt",
  "digest",
  "encrypt",
  "exportKey",
  "generateKey",
  "importKey",
  "sign",
  "verify"
];
function supportsWebCrypto(w) {
  if (supportsSecureRandom(w) && typeof w.crypto.subtle == "object") {
    var M = w.crypto.subtle;
    return supportsSubtleCrypto(M);
  }
  return !1;
}
function supportsSecureRandom(w) {
  if (typeof w == "object" && typeof w.crypto == "object") {
    var M = w.crypto.getRandomValues;
    return typeof M == "function";
  }
  return !1;
}
function supportsSubtleCrypto(w) {
  return w && subtleCryptoMethods.every(function(M) {
    return typeof w[M] == "function";
  });
}
var Sha256$2 = (
  /** @class */
  function() {
    function w(M) {
      supportsWebCrypto(locateWindow()) ? this.hash = new Sha256$4(M) : this.hash = new Sha256$3(M);
    }
    return w.prototype.update = function(M, x) {
      this.hash.update(convertToBuffer(M));
    }, w.prototype.digest = function() {
      return this.hash.digest();
    }, w.prototype.reset = function() {
      this.hash.reset();
    }, w;
  }()
);
const BROWSER_ALIASES_MAP = {
  "Amazon Silk": "amazon_silk",
  "Android Browser": "android",
  Bada: "bada",
  BlackBerry: "blackberry",
  Chrome: "chrome",
  Chromium: "chromium",
  Electron: "electron",
  Epiphany: "epiphany",
  Firefox: "firefox",
  Focus: "focus",
  Generic: "generic",
  "Google Search": "google_search",
  Googlebot: "googlebot",
  "Internet Explorer": "ie",
  "K-Meleon": "k_meleon",
  Maxthon: "maxthon",
  "Microsoft Edge": "edge",
  "MZ Browser": "mz",
  "NAVER Whale Browser": "naver",
  Opera: "opera",
  "Opera Coast": "opera_coast",
  PhantomJS: "phantomjs",
  Puffin: "puffin",
  QupZilla: "qupzilla",
  QQ: "qq",
  QQLite: "qqlite",
  Safari: "safari",
  Sailfish: "sailfish",
  "Samsung Internet for Android": "samsung_internet",
  SeaMonkey: "seamonkey",
  Sleipnir: "sleipnir",
  Swing: "swing",
  Tizen: "tizen",
  "UC Browser": "uc",
  Vivaldi: "vivaldi",
  "WebOS Browser": "webos",
  WeChat: "wechat",
  "Yandex Browser": "yandex",
  Roku: "roku"
}, BROWSER_MAP = {
  amazon_silk: "Amazon Silk",
  android: "Android Browser",
  bada: "Bada",
  blackberry: "BlackBerry",
  chrome: "Chrome",
  chromium: "Chromium",
  electron: "Electron",
  epiphany: "Epiphany",
  firefox: "Firefox",
  focus: "Focus",
  generic: "Generic",
  googlebot: "Googlebot",
  google_search: "Google Search",
  ie: "Internet Explorer",
  k_meleon: "K-Meleon",
  maxthon: "Maxthon",
  edge: "Microsoft Edge",
  mz: "MZ Browser",
  naver: "NAVER Whale Browser",
  opera: "Opera",
  opera_coast: "Opera Coast",
  phantomjs: "PhantomJS",
  puffin: "Puffin",
  qupzilla: "QupZilla",
  qq: "QQ Browser",
  qqlite: "QQ Browser Lite",
  safari: "Safari",
  sailfish: "Sailfish",
  samsung_internet: "Samsung Internet for Android",
  seamonkey: "SeaMonkey",
  sleipnir: "Sleipnir",
  swing: "Swing",
  tizen: "Tizen",
  uc: "UC Browser",
  vivaldi: "Vivaldi",
  webos: "WebOS Browser",
  wechat: "WeChat",
  yandex: "Yandex Browser"
}, PLATFORMS_MAP = {
  tablet: "tablet",
  mobile: "mobile",
  desktop: "desktop",
  tv: "tv"
}, OS_MAP = {
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MacOS: "macOS",
  iOS: "iOS",
  Android: "Android",
  WebOS: "WebOS",
  BlackBerry: "BlackBerry",
  Bada: "Bada",
  Tizen: "Tizen",
  Linux: "Linux",
  ChromeOS: "Chrome OS",
  PlayStation4: "PlayStation 4",
  Roku: "Roku"
}, ENGINE_MAP = {
  EdgeHTML: "EdgeHTML",
  Blink: "Blink",
  Trident: "Trident",
  Presto: "Presto",
  Gecko: "Gecko",
  WebKit: "WebKit"
};
class Utils {
  /**
   * Get first matched item for a string
   * @param {RegExp} regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getFirstMatch(M, x) {
    const $ = x.match(M);
    return $ && $.length > 0 && $[1] || "";
  }
  /**
   * Get second matched item for a string
   * @param regexp
   * @param {String} ua
   * @return {Array|{index: number, input: string}|*|boolean|string}
   */
  static getSecondMatch(M, x) {
    const $ = x.match(M);
    return $ && $.length > 1 && $[2] || "";
  }
  /**
   * Match a regexp and return a constant or undefined
   * @param {RegExp} regexp
   * @param {String} ua
   * @param {*} _const Any const that will be returned if regexp matches the string
   * @return {*}
   */
  static matchAndReturnConst(M, x, $) {
    if (M.test(x))
      return $;
  }
  static getWindowsVersionName(M) {
    switch (M) {
      case "NT":
        return "NT";
      case "XP":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.1":
        return "XP";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return;
    }
  }
  /**
   * Get macOS version name
   *    10.5 - Leopard
   *    10.6 - Snow Leopard
   *    10.7 - Lion
   *    10.8 - Mountain Lion
   *    10.9 - Mavericks
   *    10.10 - Yosemite
   *    10.11 - El Capitan
   *    10.12 - Sierra
   *    10.13 - High Sierra
   *    10.14 - Mojave
   *    10.15 - Catalina
   *
   * @example
   *   getMacOSVersionName("10.14") // 'Mojave'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getMacOSVersionName(M) {
    const x = M.split(".").splice(0, 2).map(($) => parseInt($, 10) || 0);
    if (x.push(0), x[0] === 10)
      switch (x[1]) {
        case 5:
          return "Leopard";
        case 6:
          return "Snow Leopard";
        case 7:
          return "Lion";
        case 8:
          return "Mountain Lion";
        case 9:
          return "Mavericks";
        case 10:
          return "Yosemite";
        case 11:
          return "El Capitan";
        case 12:
          return "Sierra";
        case 13:
          return "High Sierra";
        case 14:
          return "Mojave";
        case 15:
          return "Catalina";
        default:
          return;
      }
  }
  /**
   * Get Android version name
   *    1.5 - Cupcake
   *    1.6 - Donut
   *    2.0 - Eclair
   *    2.1 - Eclair
   *    2.2 - Froyo
   *    2.x - Gingerbread
   *    3.x - Honeycomb
   *    4.0 - Ice Cream Sandwich
   *    4.1 - Jelly Bean
   *    4.4 - KitKat
   *    5.x - Lollipop
   *    6.x - Marshmallow
   *    7.x - Nougat
   *    8.x - Oreo
   *    9.x - Pie
   *
   * @example
   *   getAndroidVersionName("7.0") // 'Nougat'
   *
   * @param  {string} version
   * @return {string} versionName
   */
  static getAndroidVersionName(M) {
    const x = M.split(".").splice(0, 2).map(($) => parseInt($, 10) || 0);
    if (x.push(0), !(x[0] === 1 && x[1] < 5)) {
      if (x[0] === 1 && x[1] < 6) return "Cupcake";
      if (x[0] === 1 && x[1] >= 6) return "Donut";
      if (x[0] === 2 && x[1] < 2) return "Eclair";
      if (x[0] === 2 && x[1] === 2) return "Froyo";
      if (x[0] === 2 && x[1] > 2) return "Gingerbread";
      if (x[0] === 3) return "Honeycomb";
      if (x[0] === 4 && x[1] < 1) return "Ice Cream Sandwich";
      if (x[0] === 4 && x[1] < 4) return "Jelly Bean";
      if (x[0] === 4 && x[1] >= 4) return "KitKat";
      if (x[0] === 5) return "Lollipop";
      if (x[0] === 6) return "Marshmallow";
      if (x[0] === 7) return "Nougat";
      if (x[0] === 8) return "Oreo";
      if (x[0] === 9) return "Pie";
    }
  }
  /**
   * Get version precisions count
   *
   * @example
   *   getVersionPrecision("1.10.3") // 3
   *
   * @param  {string} version
   * @return {number}
   */
  static getVersionPrecision(M) {
    return M.split(".").length;
  }
  /**
   * Calculate browser version weight
   *
   * @example
   *   compareVersions('1.10.2.1',  '1.8.2.1.90')    // 1
   *   compareVersions('1.010.2.1', '1.09.2.1.90');  // 1
   *   compareVersions('1.10.2.1',  '1.10.2.1');     // 0
   *   compareVersions('1.10.2.1',  '1.0800.2');     // -1
   *   compareVersions('1.10.2.1',  '1.10',  true);  // 0
   *
   * @param {String} versionA versions versions to compare
   * @param {String} versionB versions versions to compare
   * @param {boolean} [isLoose] enable loose comparison
   * @return {Number} comparison result: -1 when versionA is lower,
   * 1 when versionA is bigger, 0 when both equal
   */
  /* eslint consistent-return: 1 */
  static compareVersions(M, x, $ = !1) {
    const T = Utils.getVersionPrecision(M), S = Utils.getVersionPrecision(x);
    let D = Math.max(T, S), F = 0;
    const z = Utils.map([M, x], (Z) => {
      const H = D - Utils.getVersionPrecision(Z), V = Z + new Array(H + 1).join(".0");
      return Utils.map(V.split("."), (X) => new Array(20 - X.length).join("0") + X).reverse();
    });
    for ($ && (F = D - Math.min(T, S)), D -= 1; D >= F; ) {
      if (z[0][D] > z[1][D])
        return 1;
      if (z[0][D] === z[1][D]) {
        if (D === F)
          return 0;
        D -= 1;
      } else if (z[0][D] < z[1][D])
        return -1;
    }
  }
  /**
   * Array::map polyfill
   *
   * @param  {Array} arr
   * @param  {Function} iterator
   * @return {Array}
   */
  static map(M, x) {
    const $ = [];
    let T;
    if (Array.prototype.map)
      return Array.prototype.map.call(M, x);
    for (T = 0; T < M.length; T += 1)
      $.push(x(M[T]));
    return $;
  }
  /**
   * Array::find polyfill
   *
   * @param  {Array} arr
   * @param  {Function} predicate
   * @return {Array}
   */
  static find(M, x) {
    let $, T;
    if (Array.prototype.find)
      return Array.prototype.find.call(M, x);
    for ($ = 0, T = M.length; $ < T; $ += 1) {
      const S = M[$];
      if (x(S, $))
        return S;
    }
  }
  /**
   * Object::assign polyfill
   *
   * @param  {Object} obj
   * @param  {Object} ...objs
   * @return {Object}
   */
  static assign(M, ...x) {
    const $ = M;
    let T, S;
    if (Object.assign)
      return Object.assign(M, ...x);
    for (T = 0, S = x.length; T < S; T += 1) {
      const D = x[T];
      typeof D == "object" && D !== null && Object.keys(D).forEach((z) => {
        $[z] = D[z];
      });
    }
    return M;
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('Microsoft Edge') // edge
   *
   * @param  {string} browserName
   * @return {string}
   */
  static getBrowserAlias(M) {
    return BROWSER_ALIASES_MAP[M];
  }
  /**
   * Get short version/alias for a browser name
   *
   * @example
   *   getBrowserAlias('edge') // Microsoft Edge
   *
   * @param  {string} browserAlias
   * @return {string}
   */
  static getBrowserTypeByAlias(M) {
    return BROWSER_MAP[M] || "";
  }
}
const commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i, browsersList = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe(w) {
      const M = {
        name: "Googlebot"
      }, x = Utils.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, w) || Utils.getFirstMatch(commonVersionIdentifier, w);
      return x && (M.version = x), M;
    }
  },
  /* Opera < 13.0 */
  {
    test: [/opera/i],
    describe(w) {
      const M = {
        name: "Opera"
      }, x = Utils.getFirstMatch(commonVersionIdentifier, w) || Utils.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, w);
      return x && (M.version = x), M;
    }
  },
  /* Opera > 13.0 */
  {
    test: [/opr\/|opios/i],
    describe(w) {
      const M = {
        name: "Opera"
      }, x = Utils.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, w) || Utils.getFirstMatch(commonVersionIdentifier, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/SamsungBrowser/i],
    describe(w) {
      const M = {
        name: "Samsung Internet for Android"
      }, x = Utils.getFirstMatch(commonVersionIdentifier, w) || Utils.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/Whale/i],
    describe(w) {
      const M = {
        name: "NAVER Whale Browser"
      }, x = Utils.getFirstMatch(commonVersionIdentifier, w) || Utils.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/MZBrowser/i],
    describe(w) {
      const M = {
        name: "MZ Browser"
      }, x = Utils.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, w) || Utils.getFirstMatch(commonVersionIdentifier, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/focus/i],
    describe(w) {
      const M = {
        name: "Focus"
      }, x = Utils.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, w) || Utils.getFirstMatch(commonVersionIdentifier, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/swing/i],
    describe(w) {
      const M = {
        name: "Swing"
      }, x = Utils.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, w) || Utils.getFirstMatch(commonVersionIdentifier, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/coast/i],
    describe(w) {
      const M = {
        name: "Opera Coast"
      }, x = Utils.getFirstMatch(commonVersionIdentifier, w) || Utils.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/opt\/\d+(?:.?_?\d+)+/i],
    describe(w) {
      const M = {
        name: "Opera Touch"
      }, x = Utils.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, w) || Utils.getFirstMatch(commonVersionIdentifier, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/yabrowser/i],
    describe(w) {
      const M = {
        name: "Yandex Browser"
      }, x = Utils.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, w) || Utils.getFirstMatch(commonVersionIdentifier, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/ucbrowser/i],
    describe(w) {
      const M = {
        name: "UC Browser"
      }, x = Utils.getFirstMatch(commonVersionIdentifier, w) || Utils.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/Maxthon|mxios/i],
    describe(w) {
      const M = {
        name: "Maxthon"
      }, x = Utils.getFirstMatch(commonVersionIdentifier, w) || Utils.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/epiphany/i],
    describe(w) {
      const M = {
        name: "Epiphany"
      }, x = Utils.getFirstMatch(commonVersionIdentifier, w) || Utils.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/puffin/i],
    describe(w) {
      const M = {
        name: "Puffin"
      }, x = Utils.getFirstMatch(commonVersionIdentifier, w) || Utils.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/sleipnir/i],
    describe(w) {
      const M = {
        name: "Sleipnir"
      }, x = Utils.getFirstMatch(commonVersionIdentifier, w) || Utils.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/k-meleon/i],
    describe(w) {
      const M = {
        name: "K-Meleon"
      }, x = Utils.getFirstMatch(commonVersionIdentifier, w) || Utils.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/micromessenger/i],
    describe(w) {
      const M = {
        name: "WeChat"
      }, x = Utils.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, w) || Utils.getFirstMatch(commonVersionIdentifier, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/qqbrowser/i],
    describe(w) {
      const M = {
        name: /qqbrowserlite/i.test(w) ? "QQ Browser Lite" : "QQ Browser"
      }, x = Utils.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, w) || Utils.getFirstMatch(commonVersionIdentifier, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/msie|trident/i],
    describe(w) {
      const M = {
        name: "Internet Explorer"
      }, x = Utils.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/\sedg\//i],
    describe(w) {
      const M = {
        name: "Microsoft Edge"
      }, x = Utils.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/edg([ea]|ios)/i],
    describe(w) {
      const M = {
        name: "Microsoft Edge"
      }, x = Utils.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/vivaldi/i],
    describe(w) {
      const M = {
        name: "Vivaldi"
      }, x = Utils.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/seamonkey/i],
    describe(w) {
      const M = {
        name: "SeaMonkey"
      }, x = Utils.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/sailfish/i],
    describe(w) {
      const M = {
        name: "Sailfish"
      }, x = Utils.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/silk/i],
    describe(w) {
      const M = {
        name: "Amazon Silk"
      }, x = Utils.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/phantom/i],
    describe(w) {
      const M = {
        name: "PhantomJS"
      }, x = Utils.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/slimerjs/i],
    describe(w) {
      const M = {
        name: "SlimerJS"
      }, x = Utils.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(w) {
      const M = {
        name: "BlackBerry"
      }, x = Utils.getFirstMatch(commonVersionIdentifier, w) || Utils.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(w) {
      const M = {
        name: "WebOS Browser"
      }, x = Utils.getFirstMatch(commonVersionIdentifier, w) || Utils.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/bada/i],
    describe(w) {
      const M = {
        name: "Bada"
      }, x = Utils.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/tizen/i],
    describe(w) {
      const M = {
        name: "Tizen"
      }, x = Utils.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, w) || Utils.getFirstMatch(commonVersionIdentifier, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/qupzilla/i],
    describe(w) {
      const M = {
        name: "QupZilla"
      }, x = Utils.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, w) || Utils.getFirstMatch(commonVersionIdentifier, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/firefox|iceweasel|fxios/i],
    describe(w) {
      const M = {
        name: "Firefox"
      }, x = Utils.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/electron/i],
    describe(w) {
      const M = {
        name: "Electron"
      }, x = Utils.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/MiuiBrowser/i],
    describe(w) {
      const M = {
        name: "Miui"
      }, x = Utils.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/chromium/i],
    describe(w) {
      const M = {
        name: "Chromium"
      }, x = Utils.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, w) || Utils.getFirstMatch(commonVersionIdentifier, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/chrome|crios|crmo/i],
    describe(w) {
      const M = {
        name: "Chrome"
      }, x = Utils.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, w);
      return x && (M.version = x), M;
    }
  },
  {
    test: [/GSA/i],
    describe(w) {
      const M = {
        name: "Google Search"
      }, x = Utils.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, w);
      return x && (M.version = x), M;
    }
  },
  /* Android Browser */
  {
    test(w) {
      const M = !w.test(/like android/i), x = w.test(/android/i);
      return M && x;
    },
    describe(w) {
      const M = {
        name: "Android Browser"
      }, x = Utils.getFirstMatch(commonVersionIdentifier, w);
      return x && (M.version = x), M;
    }
  },
  /* PlayStation 4 */
  {
    test: [/playstation 4/i],
    describe(w) {
      const M = {
        name: "PlayStation 4"
      }, x = Utils.getFirstMatch(commonVersionIdentifier, w);
      return x && (M.version = x), M;
    }
  },
  /* Safari */
  {
    test: [/safari|applewebkit/i],
    describe(w) {
      const M = {
        name: "Safari"
      }, x = Utils.getFirstMatch(commonVersionIdentifier, w);
      return x && (M.version = x), M;
    }
  },
  /* Something else */
  {
    test: [/.*/i],
    describe(w) {
      const M = /^(.*)\/(.*) /, x = /^(.*)\/(.*)[ \t]\((.*)/, T = w.search("\\(") !== -1 ? x : M;
      return {
        name: Utils.getFirstMatch(T, w),
        version: Utils.getSecondMatch(T, w)
      };
    }
  }
], osParsersList = [
  /* Roku */
  {
    test: [/Roku\/DVP/],
    describe(w) {
      const M = Utils.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, w);
      return {
        name: OS_MAP.Roku,
        version: M
      };
    }
  },
  /* Windows Phone */
  {
    test: [/windows phone/i],
    describe(w) {
      const M = Utils.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, w);
      return {
        name: OS_MAP.WindowsPhone,
        version: M
      };
    }
  },
  /* Windows */
  {
    test: [/windows /i],
    describe(w) {
      const M = Utils.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, w), x = Utils.getWindowsVersionName(M);
      return {
        name: OS_MAP.Windows,
        version: M,
        versionName: x
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe(w) {
      const M = {
        name: OS_MAP.iOS
      }, x = Utils.getSecondMatch(/(Version\/)(\d[\d.]+)/, w);
      return x && (M.version = x), M;
    }
  },
  /* macOS */
  {
    test: [/macintosh/i],
    describe(w) {
      const M = Utils.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, w).replace(/[_\s]/g, "."), x = Utils.getMacOSVersionName(M), $ = {
        name: OS_MAP.MacOS,
        version: M
      };
      return x && ($.versionName = x), $;
    }
  },
  /* iOS */
  {
    test: [/(ipod|iphone|ipad)/i],
    describe(w) {
      const M = Utils.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, w).replace(/[_\s]/g, ".");
      return {
        name: OS_MAP.iOS,
        version: M
      };
    }
  },
  /* Android */
  {
    test(w) {
      const M = !w.test(/like android/i), x = w.test(/android/i);
      return M && x;
    },
    describe(w) {
      const M = Utils.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, w), x = Utils.getAndroidVersionName(M), $ = {
        name: OS_MAP.Android,
        version: M
      };
      return x && ($.versionName = x), $;
    }
  },
  /* WebOS */
  {
    test: [/(web|hpw)[o0]s/i],
    describe(w) {
      const M = Utils.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, w), x = {
        name: OS_MAP.WebOS
      };
      return M && M.length && (x.version = M), x;
    }
  },
  /* BlackBerry */
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(w) {
      const M = Utils.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, w) || Utils.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, w) || Utils.getFirstMatch(/\bbb(\d+)/i, w);
      return {
        name: OS_MAP.BlackBerry,
        version: M
      };
    }
  },
  /* Bada */
  {
    test: [/bada/i],
    describe(w) {
      const M = Utils.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, w);
      return {
        name: OS_MAP.Bada,
        version: M
      };
    }
  },
  /* Tizen */
  {
    test: [/tizen/i],
    describe(w) {
      const M = Utils.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, w);
      return {
        name: OS_MAP.Tizen,
        version: M
      };
    }
  },
  /* Linux */
  {
    test: [/linux/i],
    describe() {
      return {
        name: OS_MAP.Linux
      };
    }
  },
  /* Chrome OS */
  {
    test: [/CrOS/],
    describe() {
      return {
        name: OS_MAP.ChromeOS
      };
    }
  },
  /* Playstation 4 */
  {
    test: [/PlayStation 4/],
    describe(w) {
      const M = Utils.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, w);
      return {
        name: OS_MAP.PlayStation4,
        version: M
      };
    }
  }
], platformParsersList = [
  /* Googlebot */
  {
    test: [/googlebot/i],
    describe() {
      return {
        type: "bot",
        vendor: "Google"
      };
    }
  },
  /* Huawei */
  {
    test: [/huawei/i],
    describe(w) {
      const M = Utils.getFirstMatch(/(can-l01)/i, w) && "Nova", x = {
        type: PLATFORMS_MAP.mobile,
        vendor: "Huawei"
      };
      return M && (x.model = M), x;
    }
  },
  /* Nexus Tablet */
  {
    test: [/nexus\s*(?:7|8|9|10).*/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Nexus"
      };
    }
  },
  /* iPad */
  {
    test: [/ipad/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Firefox on iPad */
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  /* Amazon Kindle Fire */
  {
    test: [/kftt build/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon",
        model: "Kindle Fire HD 7"
      };
    }
  },
  /* Another Amazon Tablet with Silk */
  {
    test: [/silk/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon"
      };
    }
  },
  /* Tablet */
  {
    test: [/tablet(?! pc)/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  /* iPod/iPhone */
  {
    test(w) {
      const M = w.test(/ipod|iphone/i), x = w.test(/like (ipod|iphone)/i);
      return M && !x;
    },
    describe(w) {
      const M = Utils.getFirstMatch(/(ipod|iphone)/i, w);
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Apple",
        model: M
      };
    }
  },
  /* Nexus Mobile */
  {
    test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Nexus"
      };
    }
  },
  /* Mobile */
  {
    test: [/[^-]mobi/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* BlackBerry */
  {
    test(w) {
      return w.getBrowserName(!0) === "blackberry";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "BlackBerry"
      };
    }
  },
  /* Bada */
  {
    test(w) {
      return w.getBrowserName(!0) === "bada";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* Windows Phone */
  {
    test(w) {
      return w.getBrowserName() === "windows phone";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Microsoft"
      };
    }
  },
  /* Android Tablet */
  {
    test(w) {
      const M = Number(String(w.getOSVersion()).split(".")[0]);
      return w.getOSName(!0) === "android" && M >= 3;
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  /* Android Mobile */
  {
    test(w) {
      return w.getOSName(!0) === "android";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  /* desktop */
  {
    test(w) {
      return w.getOSName(!0) === "macos";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop,
        vendor: "Apple"
      };
    }
  },
  /* Windows */
  {
    test(w) {
      return w.getOSName(!0) === "windows";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  /* Linux */
  {
    test(w) {
      return w.getOSName(!0) === "linux";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  /* PlayStation 4 */
  {
    test(w) {
      return w.getOSName(!0) === "playstation 4";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  },
  /* Roku */
  {
    test(w) {
      return w.getOSName(!0) === "roku";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  }
], enginesParsersList = [
  /* EdgeHTML */
  {
    test(w) {
      return w.getBrowserName(!0) === "microsoft edge";
    },
    describe(w) {
      if (/\sedg\//i.test(w))
        return {
          name: ENGINE_MAP.Blink
        };
      const x = Utils.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, w);
      return {
        name: ENGINE_MAP.EdgeHTML,
        version: x
      };
    }
  },
  /* Trident */
  {
    test: [/trident/i],
    describe(w) {
      const M = {
        name: ENGINE_MAP.Trident
      }, x = Utils.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, w);
      return x && (M.version = x), M;
    }
  },
  /* Presto */
  {
    test(w) {
      return w.test(/presto/i);
    },
    describe(w) {
      const M = {
        name: ENGINE_MAP.Presto
      }, x = Utils.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, w);
      return x && (M.version = x), M;
    }
  },
  /* Gecko */
  {
    test(w) {
      const M = w.test(/gecko/i), x = w.test(/like gecko/i);
      return M && !x;
    },
    describe(w) {
      const M = {
        name: ENGINE_MAP.Gecko
      }, x = Utils.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, w);
      return x && (M.version = x), M;
    }
  },
  /* Blink */
  {
    test: [/(apple)?webkit\/537\.36/i],
    describe() {
      return {
        name: ENGINE_MAP.Blink
      };
    }
  },
  /* WebKit */
  {
    test: [/(apple)?webkit/i],
    describe(w) {
      const M = {
        name: ENGINE_MAP.WebKit
      }, x = Utils.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, w);
      return x && (M.version = x), M;
    }
  }
];
class Parser {
  /**
   * Create instance of Parser
   *
   * @param {String} UA User-Agent string
   * @param {Boolean} [skipParsing=false] parser can skip parsing in purpose of performance
   * improvements if you need to make a more particular parsing
   * like {@link Parser#parseBrowser} or {@link Parser#parsePlatform}
   *
   * @throw {Error} in case of empty UA String
   *
   * @constructor
   */
  constructor(M, x = !1) {
    if (M == null || M === "")
      throw new Error("UserAgent parameter can't be empty");
    this._ua = M, this.parsedResult = {}, x !== !0 && this.parse();
  }
  /**
   * Get UserAgent string of current Parser instance
   * @return {String} User-Agent String of the current <Parser> object
   *
   * @public
   */
  getUA() {
    return this._ua;
  }
  /**
   * Test a UA string for a regexp
   * @param {RegExp} regex
   * @return {Boolean}
   */
  test(M) {
    return M.test(this._ua);
  }
  /**
   * Get parsed browser object
   * @return {Object}
   */
  parseBrowser() {
    this.parsedResult.browser = {};
    const M = Utils.find(browsersList, (x) => {
      if (typeof x.test == "function")
        return x.test(this);
      if (x.test instanceof Array)
        return x.test.some(($) => this.test($));
      throw new Error("Browser's test function is not valid");
    });
    return M && (this.parsedResult.browser = M.describe(this.getUA())), this.parsedResult.browser;
  }
  /**
   * Get parsed browser object
   * @return {Object}
   *
   * @public
   */
  getBrowser() {
    return this.parsedResult.browser ? this.parsedResult.browser : this.parseBrowser();
  }
  /**
   * Get browser's name
   * @return {String} Browser's name or an empty string
   *
   * @public
   */
  getBrowserName(M) {
    return M ? String(this.getBrowser().name).toLowerCase() || "" : this.getBrowser().name || "";
  }
  /**
   * Get browser's version
   * @return {String} version of browser
   *
   * @public
   */
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  /**
   * Get OS
   * @return {Object}
   *
   * @example
   * this.getOS();
   * {
   *   name: 'macOS',
   *   version: '10.11.12'
   * }
   */
  getOS() {
    return this.parsedResult.os ? this.parsedResult.os : this.parseOS();
  }
  /**
   * Parse OS and save it to this.parsedResult.os
   * @return {*|{}}
   */
  parseOS() {
    this.parsedResult.os = {};
    const M = Utils.find(osParsersList, (x) => {
      if (typeof x.test == "function")
        return x.test(this);
      if (x.test instanceof Array)
        return x.test.some(($) => this.test($));
      throw new Error("Browser's test function is not valid");
    });
    return M && (this.parsedResult.os = M.describe(this.getUA())), this.parsedResult.os;
  }
  /**
   * Get OS name
   * @param {Boolean} [toLowerCase] return lower-cased value
   * @return {String} name of the OS  macOS, Windows, Linux, etc.
   */
  getOSName(M) {
    const { name: x } = this.getOS();
    return M ? String(x).toLowerCase() || "" : x || "";
  }
  /**
   * Get OS version
   * @return {String} full version with dots ('10.11.12', '5.6', etc)
   */
  getOSVersion() {
    return this.getOS().version;
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  getPlatform() {
    return this.parsedResult.platform ? this.parsedResult.platform : this.parsePlatform();
  }
  /**
   * Get platform name
   * @param {Boolean} [toLowerCase=false]
   * @return {*}
   */
  getPlatformType(M = !1) {
    const { type: x } = this.getPlatform();
    return M ? String(x).toLowerCase() || "" : x || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parsePlatform() {
    this.parsedResult.platform = {};
    const M = Utils.find(platformParsersList, (x) => {
      if (typeof x.test == "function")
        return x.test(this);
      if (x.test instanceof Array)
        return x.test.some(($) => this.test($));
      throw new Error("Browser's test function is not valid");
    });
    return M && (this.parsedResult.platform = M.describe(this.getUA())), this.parsedResult.platform;
  }
  /**
   * Get parsed engine
   * @return {{}}
   */
  getEngine() {
    return this.parsedResult.engine ? this.parsedResult.engine : this.parseEngine();
  }
  /**
   * Get engines's name
   * @return {String} Engines's name or an empty string
   *
   * @public
   */
  getEngineName(M) {
    return M ? String(this.getEngine().name).toLowerCase() || "" : this.getEngine().name || "";
  }
  /**
   * Get parsed platform
   * @return {{}}
   */
  parseEngine() {
    this.parsedResult.engine = {};
    const M = Utils.find(enginesParsersList, (x) => {
      if (typeof x.test == "function")
        return x.test(this);
      if (x.test instanceof Array)
        return x.test.some(($) => this.test($));
      throw new Error("Browser's test function is not valid");
    });
    return M && (this.parsedResult.engine = M.describe(this.getUA())), this.parsedResult.engine;
  }
  /**
   * Parse full information about the browser
   * @returns {Parser}
   */
  parse() {
    return this.parseBrowser(), this.parseOS(), this.parsePlatform(), this.parseEngine(), this;
  }
  /**
   * Get parsed result
   * @return {ParsedResult}
   */
  getResult() {
    return Utils.assign({}, this.parsedResult);
  }
  /**
   * Check if parsed browser matches certain conditions
   *
   * @param {Object} checkTree It's one or two layered object,
   * which can include a platform or an OS on the first layer
   * and should have browsers specs on the bottom-laying layer
   *
   * @returns {Boolean|undefined} Whether the browser satisfies the set conditions or not.
   * Returns `undefined` when the browser is no described in the checkTree object.
   *
   * @example
   * const browser = Bowser.getParser(window.navigator.userAgent);
   * if (browser.satisfies({chrome: '>118.01.1322' }))
   * // or with os
   * if (browser.satisfies({windows: { chrome: '>118.01.1322' } }))
   * // or with platforms
   * if (browser.satisfies({desktop: { chrome: '>118.01.1322' } }))
   */
  satisfies(M) {
    const x = {};
    let $ = 0;
    const T = {};
    let S = 0;
    if (Object.keys(M).forEach((F) => {
      const z = M[F];
      typeof z == "string" ? (T[F] = z, S += 1) : typeof z == "object" && (x[F] = z, $ += 1);
    }), $ > 0) {
      const F = Object.keys(x), z = Utils.find(F, (H) => this.isOS(H));
      if (z) {
        const H = this.satisfies(x[z]);
        if (H !== void 0)
          return H;
      }
      const Z = Utils.find(
        F,
        (H) => this.isPlatform(H)
      );
      if (Z) {
        const H = this.satisfies(x[Z]);
        if (H !== void 0)
          return H;
      }
    }
    if (S > 0) {
      const F = Object.keys(T), z = Utils.find(F, (Z) => this.isBrowser(Z, !0));
      if (z !== void 0)
        return this.compareVersion(T[z]);
    }
  }
  /**
   * Check if the browser name equals the passed string
   * @param browserName The string to compare with the browser name
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {boolean}
   */
  isBrowser(M, x = !1) {
    const $ = this.getBrowserName().toLowerCase();
    let T = M.toLowerCase();
    const S = Utils.getBrowserTypeByAlias(T);
    return x && S && (T = S.toLowerCase()), T === $;
  }
  compareVersion(M) {
    let x = [0], $ = M, T = !1;
    const S = this.getBrowserVersion();
    if (typeof S == "string")
      return M[0] === ">" || M[0] === "<" ? ($ = M.substr(1), M[1] === "=" ? (T = !0, $ = M.substr(2)) : x = [], M[0] === ">" ? x.push(1) : x.push(-1)) : M[0] === "=" ? $ = M.substr(1) : M[0] === "~" && (T = !0, $ = M.substr(1)), x.indexOf(
        Utils.compareVersions(S, $, T)
      ) > -1;
  }
  isOS(M) {
    return this.getOSName(!0) === String(M).toLowerCase();
  }
  isPlatform(M) {
    return this.getPlatformType(!0) === String(M).toLowerCase();
  }
  isEngine(M) {
    return this.getEngineName(!0) === String(M).toLowerCase();
  }
  /**
   * Is anything? Check if the browser is called "anything",
   * the OS called "anything" or the platform called "anything"
   * @param {String} anything
   * @param [includingAlias=false] The flag showing whether alias will be included into comparison
   * @returns {Boolean}
   */
  is(M, x = !1) {
    return this.isBrowser(M, x) || this.isOS(M) || this.isPlatform(M);
  }
  /**
   * Check if any of the given values satisfies this.is(anything)
   * @param {String[]} anythings
   * @returns {Boolean}
   */
  some(M = []) {
    return M.some((x) => this.is(x));
  }
}
/*!
 * Bowser - a browser detector
 * https://github.com/lancedikson/bowser
 * MIT License | (c) Dustin Diaz 2012-2015
 * MIT License | (c) Denis Demchenko 2015-2019
 */
class Bowser {
  /**
   * Creates a {@link Parser} instance
   *
   * @param {String} UA UserAgent string
   * @param {Boolean} [skipParsing=false] Will make the Parser postpone parsing until you ask it
   * explicitly. Same as `skipParsing` for {@link Parser}.
   * @returns {Parser}
   * @throws {Error} when UA is not a String
   *
   * @example
   * const parser = Bowser.getParser(window.navigator.userAgent);
   * const result = parser.getResult();
   */
  static getParser(M, x = !1) {
    if (typeof M != "string")
      throw new Error("UserAgent should be a string");
    return new Parser(M, x);
  }
  /**
   * Creates a {@link Parser} instance and runs {@link Parser.getResult} immediately
   *
   * @param UA
   * @return {ParsedResult}
   *
   * @example
   * const result = Bowser.parse(window.navigator.userAgent);
   */
  static parse(M) {
    return new Parser(M).getResult();
  }
  static get BROWSER_MAP() {
    return BROWSER_MAP;
  }
  static get ENGINE_MAP() {
    return ENGINE_MAP;
  }
  static get OS_MAP() {
    return OS_MAP;
  }
  static get PLATFORMS_MAP() {
    return PLATFORMS_MAP;
  }
}
const createDefaultUserAgentProvider = ({ serviceId: w, clientVersion: M }) => async (x) => {
  var D, F, z, Z, H, V;
  const $ = typeof window < "u" && ((D = window == null ? void 0 : window.navigator) != null && D.userAgent) ? Bowser.parse(window.navigator.userAgent) : void 0, T = [
    ["aws-sdk-js", M],
    ["ua", "2.1"],
    [`os/${((F = $ == null ? void 0 : $.os) == null ? void 0 : F.name) || "other"}`, (z = $ == null ? void 0 : $.os) == null ? void 0 : z.version],
    ["lang/js"],
    ["md/browser", `${((Z = $ == null ? void 0 : $.browser) == null ? void 0 : Z.name) ?? "unknown"}_${((H = $ == null ? void 0 : $.browser) == null ? void 0 : H.version) ?? "unknown"}`]
  ];
  w && T.push([`api/${w}`, M]);
  const S = await ((V = x == null ? void 0 : x.userAgentAppId) == null ? void 0 : V.call(x));
  return S && T.push([`app/${S}`]), T;
}, invalidProvider = (w) => () => Promise.reject(w), TEXT_ENCODER = typeof TextEncoder == "function" ? new TextEncoder() : null, calculateBodyLength = (w) => {
  if (typeof w == "string") {
    if (TEXT_ENCODER)
      return TEXT_ENCODER.encode(w).byteLength;
    let M = w.length;
    for (let x = M - 1; x >= 0; x--) {
      const $ = w.charCodeAt(x);
      $ > 127 && $ <= 2047 ? M++ : $ > 2047 && $ <= 65535 && (M += 2), $ >= 56320 && $ <= 57343 && x--;
    }
    return M;
  } else {
    if (typeof w.byteLength == "number")
      return w.byteLength;
    if (typeof w.size == "number")
      return w.size;
  }
  throw new Error(`Body Length computation failed for ${w}`);
}, s$1 = "required", t = "fn", u = "argv", v = "ref", a = !0, b = "isSet", c = "booleanEquals", d = "error", e = "endpoint", f$1 = "tree", g = "PartitionResult", h = { [s$1]: !1, type: "String" }, i = { [s$1]: !0, default: !1, type: "Boolean" }, j = { [v]: "Endpoint" }, k = { [t]: c, [u]: [{ [v]: "UseFIPS" }, !0] }, l = { [t]: c, [u]: [{ [v]: "UseDualStack" }, !0] }, m = {}, n = { [t]: "getAttr", [u]: [{ [v]: g }, "supportsFIPS"] }, o = { [t]: c, [u]: [!0, { [t]: "getAttr", [u]: [{ [v]: g }, "supportsDualStack"] }] }, p = [k], q = [l], r$1 = [{ [v]: "Region" }], _data = { parameters: { Region: h, UseDualStack: i, UseFIPS: i, Endpoint: h }, rules: [{ conditions: [{ [t]: b, [u]: [j] }], rules: [{ conditions: p, error: "Invalid Configuration: FIPS and custom endpoint are not supported", type: d }, { conditions: q, error: "Invalid Configuration: Dualstack and custom endpoint are not supported", type: d }, { endpoint: { url: j, properties: m, headers: m }, type: e }], type: f$1 }, { conditions: [{ [t]: b, [u]: r$1 }], rules: [{ conditions: [{ [t]: "aws.partition", [u]: r$1, assign: g }], rules: [{ conditions: [k, l], rules: [{ conditions: [{ [t]: c, [u]: [a, n] }, o], rules: [{ endpoint: { url: "https://translate-fips.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: m, headers: m }, type: e }], type: f$1 }, { error: "FIPS and DualStack are enabled, but this partition does not support one or both", type: d }], type: f$1 }, { conditions: p, rules: [{ conditions: [{ [t]: c, [u]: [n, a] }], rules: [{ endpoint: { url: "https://translate-fips.{Region}.{PartitionResult#dnsSuffix}", properties: m, headers: m }, type: e }], type: f$1 }, { error: "FIPS is enabled but this partition does not support FIPS", type: d }], type: f$1 }, { conditions: q, rules: [{ conditions: [o], rules: [{ endpoint: { url: "https://translate.{Region}.{PartitionResult#dualStackDnsSuffix}", properties: m, headers: m }, type: e }], type: f$1 }, { error: "DualStack is enabled but this partition does not support DualStack", type: d }], type: f$1 }, { endpoint: { url: "https://translate.{Region}.{PartitionResult#dnsSuffix}", properties: m, headers: m }, type: e }], type: f$1 }], type: f$1 }, { error: "Invalid Configuration: Missing Region", type: d }] }, ruleSet = _data, cache = new EndpointCache({
  size: 50,
  params: ["Endpoint", "Region", "UseDualStack", "UseFIPS"]
}), defaultEndpointResolver = (w, M = {}) => cache.get(w, () => resolveEndpoint(ruleSet, {
  endpointParams: w,
  logger: M.logger
}));
customEndpointFunctions.aws = awsEndpointFunctions;
const getRuntimeConfig$1 = (w) => ({
  apiVersion: "2017-07-01",
  base64Decoder: (w == null ? void 0 : w.base64Decoder) ?? fromBase64,
  base64Encoder: (w == null ? void 0 : w.base64Encoder) ?? toBase64,
  disableHostPrefix: (w == null ? void 0 : w.disableHostPrefix) ?? !1,
  endpointProvider: (w == null ? void 0 : w.endpointProvider) ?? defaultEndpointResolver,
  extensions: (w == null ? void 0 : w.extensions) ?? [],
  httpAuthSchemeProvider: (w == null ? void 0 : w.httpAuthSchemeProvider) ?? defaultTranslateHttpAuthSchemeProvider,
  httpAuthSchemes: (w == null ? void 0 : w.httpAuthSchemes) ?? [
    {
      schemeId: "aws.auth#sigv4",
      identityProvider: (M) => M.getIdentityProvider("aws.auth#sigv4"),
      signer: new AwsSdkSigV4Signer()
    }
  ],
  logger: (w == null ? void 0 : w.logger) ?? new NoOpLogger(),
  serviceId: (w == null ? void 0 : w.serviceId) ?? "Translate",
  urlParser: (w == null ? void 0 : w.urlParser) ?? parseUrl,
  utf8Decoder: (w == null ? void 0 : w.utf8Decoder) ?? fromUtf8$2,
  utf8Encoder: (w == null ? void 0 : w.utf8Encoder) ?? toUtf8
}), DEFAULTS_MODE_OPTIONS = ["in-region", "cross-region", "mobile", "standard", "legacy"], resolveDefaultsModeConfig = ({ defaultsMode: w } = {}) => memoize(async () => {
  const M = typeof w == "function" ? await w() : w;
  switch (M == null ? void 0 : M.toLowerCase()) {
    case "auto":
      return Promise.resolve(isMobileBrowser() ? "mobile" : "standard");
    case "mobile":
    case "in-region":
    case "cross-region":
    case "standard":
    case "legacy":
      return Promise.resolve(M == null ? void 0 : M.toLocaleLowerCase());
    case void 0:
      return Promise.resolve("legacy");
    default:
      throw new Error(`Invalid parameter for "defaultsMode", expect ${DEFAULTS_MODE_OPTIONS.join(", ")}, got ${M}`);
  }
}), isMobileBrowser = () => {
  var x, $;
  const w = typeof window < "u" && ((x = window == null ? void 0 : window.navigator) != null && x.userAgent) ? Bowser.parse(window.navigator.userAgent) : void 0, M = ($ = w == null ? void 0 : w.platform) == null ? void 0 : $.type;
  return M === "tablet" || M === "mobile";
}, getRuntimeConfig = (w) => {
  const M = resolveDefaultsModeConfig(w), x = () => M().then(loadConfigsForDefaultMode), $ = getRuntimeConfig$1(w);
  return {
    ...$,
    ...w,
    runtime: "browser",
    defaultsMode: M,
    bodyLengthChecker: (w == null ? void 0 : w.bodyLengthChecker) ?? calculateBodyLength,
    credentialDefaultProvider: (w == null ? void 0 : w.credentialDefaultProvider) ?? ((T) => () => Promise.reject(new Error("Credential is missing"))),
    defaultUserAgentProvider: (w == null ? void 0 : w.defaultUserAgentProvider) ?? createDefaultUserAgentProvider({ serviceId: $.serviceId, clientVersion: packageInfo.version }),
    maxAttempts: (w == null ? void 0 : w.maxAttempts) ?? DEFAULT_MAX_ATTEMPTS,
    region: (w == null ? void 0 : w.region) ?? invalidProvider("Region is missing"),
    requestHandler: FetchHttpHandler.create((w == null ? void 0 : w.requestHandler) ?? x),
    retryMode: (w == null ? void 0 : w.retryMode) ?? (async () => (await x()).retryMode || DEFAULT_RETRY_MODE),
    sha256: (w == null ? void 0 : w.sha256) ?? Sha256$2,
    streamCollector: (w == null ? void 0 : w.streamCollector) ?? streamCollector,
    useDualstackEndpoint: (w == null ? void 0 : w.useDualstackEndpoint) ?? (() => Promise.resolve(DEFAULT_USE_DUALSTACK_ENDPOINT)),
    useFipsEndpoint: (w == null ? void 0 : w.useFipsEndpoint) ?? (() => Promise.resolve(DEFAULT_USE_FIPS_ENDPOINT))
  };
}, getAwsRegionExtensionConfiguration = (w) => ({
  setRegion(M) {
    w.region = M;
  },
  region() {
    return w.region;
  }
}), resolveAwsRegionExtensionConfiguration = (w) => ({
  region: w.region()
}), getHttpAuthExtensionConfiguration = (w) => {
  const M = w.httpAuthSchemes;
  let x = w.httpAuthSchemeProvider, $ = w.credentials;
  return {
    setHttpAuthScheme(T) {
      const S = M.findIndex((D) => D.schemeId === T.schemeId);
      S === -1 ? M.push(T) : M.splice(S, 1, T);
    },
    httpAuthSchemes() {
      return M;
    },
    setHttpAuthSchemeProvider(T) {
      x = T;
    },
    httpAuthSchemeProvider() {
      return x;
    },
    setCredentials(T) {
      $ = T;
    },
    credentials() {
      return $;
    }
  };
}, resolveHttpAuthRuntimeConfig = (w) => ({
  httpAuthSchemes: w.httpAuthSchemes(),
  httpAuthSchemeProvider: w.httpAuthSchemeProvider(),
  credentials: w.credentials()
}), resolveRuntimeExtensions = (w, M) => {
  const x = Object.assign(getAwsRegionExtensionConfiguration(w), getDefaultExtensionConfiguration(w), getHttpHandlerExtensionConfiguration(w), getHttpAuthExtensionConfiguration(w));
  return M.forEach(($) => $.configure(x)), Object.assign(w, resolveAwsRegionExtensionConfiguration(x), resolveDefaultRuntimeConfig(x), resolveHttpHandlerRuntimeConfig(x), resolveHttpAuthRuntimeConfig(x));
};
class TranslateClient extends Client {
  constructor(...[x]) {
    const $ = getRuntimeConfig(x || {});
    super($);
    ct(this, "config");
    this.initConfig = $;
    const T = resolveClientEndpointParameters($), S = resolveUserAgentConfig(T), D = resolveRetryConfig(S), F = resolveRegionConfig(D), z = F, Z = resolveEndpointConfig(z), H = resolveHttpAuthSchemeConfig(Z), V = resolveRuntimeExtensions(H, (x == null ? void 0 : x.extensions) || []);
    this.config = V, this.middlewareStack.use(getUserAgentPlugin(this.config)), this.middlewareStack.use(getRetryPlugin(this.config)), this.middlewareStack.use(getContentLengthPlugin(this.config)), this.middlewareStack.use(getHostHeaderPlugin(this.config)), this.middlewareStack.use(getLoggerPlugin(this.config)), this.middlewareStack.use(getRecursionDetectionPlugin(this.config)), this.middlewareStack.use(getHttpAuthSchemeEndpointRuleSetPlugin(this.config, {
      httpAuthSchemeParametersProvider: defaultTranslateHttpAuthSchemeParametersProvider,
      identityProviderConfigProvider: async (X) => new DefaultIdentityProviderConfig({
        "aws.auth#sigv4": X.credentials
      })
    })), this.middlewareStack.use(getHttpSigningPlugin(this.config));
  }
  destroy() {
    super.destroy();
  }
}
class TranslateServiceException extends ServiceException {
  constructor(M) {
    super(M), Object.setPrototypeOf(this, TranslateServiceException.prototype);
  }
}
class ConcurrentModificationException extends TranslateServiceException {
  constructor(x) {
    super({
      name: "ConcurrentModificationException",
      $fault: "client",
      ...x
    });
    ct(this, "name", "ConcurrentModificationException");
    ct(this, "$fault", "client");
    ct(this, "Message");
    Object.setPrototypeOf(this, ConcurrentModificationException.prototype), this.Message = x.Message;
  }
}
class ConflictException extends TranslateServiceException {
  constructor(x) {
    super({
      name: "ConflictException",
      $fault: "client",
      ...x
    });
    ct(this, "name", "ConflictException");
    ct(this, "$fault", "client");
    ct(this, "Message");
    Object.setPrototypeOf(this, ConflictException.prototype), this.Message = x.Message;
  }
}
class InternalServerException extends TranslateServiceException {
  constructor(x) {
    super({
      name: "InternalServerException",
      $fault: "server",
      ...x
    });
    ct(this, "name", "InternalServerException");
    ct(this, "$fault", "server");
    ct(this, "Message");
    Object.setPrototypeOf(this, InternalServerException.prototype), this.Message = x.Message;
  }
}
class InvalidParameterValueException extends TranslateServiceException {
  constructor(x) {
    super({
      name: "InvalidParameterValueException",
      $fault: "client",
      ...x
    });
    ct(this, "name", "InvalidParameterValueException");
    ct(this, "$fault", "client");
    ct(this, "Message");
    Object.setPrototypeOf(this, InvalidParameterValueException.prototype), this.Message = x.Message;
  }
}
class InvalidRequestException extends TranslateServiceException {
  constructor(x) {
    super({
      name: "InvalidRequestException",
      $fault: "client",
      ...x
    });
    ct(this, "name", "InvalidRequestException");
    ct(this, "$fault", "client");
    ct(this, "Message");
    Object.setPrototypeOf(this, InvalidRequestException.prototype), this.Message = x.Message;
  }
}
class LimitExceededException extends TranslateServiceException {
  constructor(x) {
    super({
      name: "LimitExceededException",
      $fault: "client",
      ...x
    });
    ct(this, "name", "LimitExceededException");
    ct(this, "$fault", "client");
    ct(this, "Message");
    Object.setPrototypeOf(this, LimitExceededException.prototype), this.Message = x.Message;
  }
}
class TooManyRequestsException extends TranslateServiceException {
  constructor(x) {
    super({
      name: "TooManyRequestsException",
      $fault: "client",
      ...x
    });
    ct(this, "name", "TooManyRequestsException");
    ct(this, "$fault", "client");
    ct(this, "Message");
    Object.setPrototypeOf(this, TooManyRequestsException.prototype), this.Message = x.Message;
  }
}
class TooManyTagsException extends TranslateServiceException {
  constructor(x) {
    super({
      name: "TooManyTagsException",
      $fault: "client",
      ...x
    });
    ct(this, "name", "TooManyTagsException");
    ct(this, "$fault", "client");
    ct(this, "ResourceArn");
    Object.setPrototypeOf(this, TooManyTagsException.prototype), this.ResourceArn = x.ResourceArn;
  }
}
class ResourceNotFoundException extends TranslateServiceException {
  constructor(x) {
    super({
      name: "ResourceNotFoundException",
      $fault: "client",
      ...x
    });
    ct(this, "name", "ResourceNotFoundException");
    ct(this, "$fault", "client");
    ct(this, "Message");
    Object.setPrototypeOf(this, ResourceNotFoundException.prototype), this.Message = x.Message;
  }
}
const Profanity = {
  MASK: "MASK"
};
class UnsupportedDisplayLanguageCodeException extends TranslateServiceException {
  constructor(x) {
    super({
      name: "UnsupportedDisplayLanguageCodeException",
      $fault: "client",
      ...x
    });
    ct(this, "name", "UnsupportedDisplayLanguageCodeException");
    ct(this, "$fault", "client");
    ct(this, "Message");
    ct(this, "DisplayLanguageCode");
    Object.setPrototypeOf(this, UnsupportedDisplayLanguageCodeException.prototype), this.Message = x.Message, this.DisplayLanguageCode = x.DisplayLanguageCode;
  }
}
class InvalidFilterException extends TranslateServiceException {
  constructor(x) {
    super({
      name: "InvalidFilterException",
      $fault: "client",
      ...x
    });
    ct(this, "name", "InvalidFilterException");
    ct(this, "$fault", "client");
    ct(this, "Message");
    Object.setPrototypeOf(this, InvalidFilterException.prototype), this.Message = x.Message;
  }
}
class UnsupportedLanguagePairException extends TranslateServiceException {
  constructor(x) {
    super({
      name: "UnsupportedLanguagePairException",
      $fault: "client",
      ...x
    });
    ct(this, "name", "UnsupportedLanguagePairException");
    ct(this, "$fault", "client");
    ct(this, "Message");
    ct(this, "SourceLanguageCode");
    ct(this, "TargetLanguageCode");
    Object.setPrototypeOf(this, UnsupportedLanguagePairException.prototype), this.Message = x.Message, this.SourceLanguageCode = x.SourceLanguageCode, this.TargetLanguageCode = x.TargetLanguageCode;
  }
}
class ServiceUnavailableException extends TranslateServiceException {
  constructor(x) {
    super({
      name: "ServiceUnavailableException",
      $fault: "server",
      ...x
    });
    ct(this, "name", "ServiceUnavailableException");
    ct(this, "$fault", "server");
    ct(this, "Message");
    Object.setPrototypeOf(this, ServiceUnavailableException.prototype), this.Message = x.Message;
  }
}
class DetectedLanguageLowConfidenceException extends TranslateServiceException {
  constructor(x) {
    super({
      name: "DetectedLanguageLowConfidenceException",
      $fault: "client",
      ...x
    });
    ct(this, "name", "DetectedLanguageLowConfidenceException");
    ct(this, "$fault", "client");
    ct(this, "Message");
    ct(this, "DetectedLanguageCode");
    Object.setPrototypeOf(this, DetectedLanguageLowConfidenceException.prototype), this.Message = x.Message, this.DetectedLanguageCode = x.DetectedLanguageCode;
  }
}
class TextSizeLimitExceededException extends TranslateServiceException {
  constructor(x) {
    super({
      name: "TextSizeLimitExceededException",
      $fault: "client",
      ...x
    });
    ct(this, "name", "TextSizeLimitExceededException");
    ct(this, "$fault", "client");
    ct(this, "Message");
    Object.setPrototypeOf(this, TextSizeLimitExceededException.prototype), this.Message = x.Message;
  }
}
const se_ListLanguagesCommand = async (w, M) => {
  const x = sharedHeaders("ListLanguages");
  let $;
  return $ = JSON.stringify(_json(w)), buildHttpRpcRequest(M, x, "/", void 0, $);
}, se_TranslateTextCommand = async (w, M) => {
  const x = sharedHeaders("TranslateText");
  let $;
  return $ = JSON.stringify(_json(w)), buildHttpRpcRequest(M, x, "/", void 0, $);
}, de_ListLanguagesCommand = async (w, M) => {
  if (w.statusCode >= 300)
    return de_CommandError(w, M);
  const x = await parseJsonBody(w.body, M);
  let $ = {};
  return $ = _json(x), {
    $metadata: deserializeMetadata(w),
    ...$
  };
}, de_TranslateTextCommand = async (w, M) => {
  if (w.statusCode >= 300)
    return de_CommandError(w, M);
  const x = await parseJsonBody(w.body, M);
  let $ = {};
  return $ = _json(x), {
    $metadata: deserializeMetadata(w),
    ...$
  };
}, de_CommandError = async (w, M) => {
  const x = {
    ...w,
    body: await parseJsonErrorBody(w.body, M)
  }, $ = loadRestJsonErrorCode(w, x.body);
  switch ($) {
    case "ConcurrentModificationException":
    case "com.amazonaws.translate#ConcurrentModificationException":
      throw await de_ConcurrentModificationExceptionRes(x);
    case "ConflictException":
    case "com.amazonaws.translate#ConflictException":
      throw await de_ConflictExceptionRes(x);
    case "InternalServerException":
    case "com.amazonaws.translate#InternalServerException":
      throw await de_InternalServerExceptionRes(x);
    case "InvalidParameterValueException":
    case "com.amazonaws.translate#InvalidParameterValueException":
      throw await de_InvalidParameterValueExceptionRes(x);
    case "InvalidRequestException":
    case "com.amazonaws.translate#InvalidRequestException":
      throw await de_InvalidRequestExceptionRes(x);
    case "LimitExceededException":
    case "com.amazonaws.translate#LimitExceededException":
      throw await de_LimitExceededExceptionRes(x);
    case "TooManyRequestsException":
    case "com.amazonaws.translate#TooManyRequestsException":
      throw await de_TooManyRequestsExceptionRes(x);
    case "TooManyTagsException":
    case "com.amazonaws.translate#TooManyTagsException":
      throw await de_TooManyTagsExceptionRes(x);
    case "ResourceNotFoundException":
    case "com.amazonaws.translate#ResourceNotFoundException":
      throw await de_ResourceNotFoundExceptionRes(x);
    case "UnsupportedDisplayLanguageCodeException":
    case "com.amazonaws.translate#UnsupportedDisplayLanguageCodeException":
      throw await de_UnsupportedDisplayLanguageCodeExceptionRes(x);
    case "InvalidFilterException":
    case "com.amazonaws.translate#InvalidFilterException":
      throw await de_InvalidFilterExceptionRes(x);
    case "UnsupportedLanguagePairException":
    case "com.amazonaws.translate#UnsupportedLanguagePairException":
      throw await de_UnsupportedLanguagePairExceptionRes(x);
    case "ServiceUnavailableException":
    case "com.amazonaws.translate#ServiceUnavailableException":
      throw await de_ServiceUnavailableExceptionRes(x);
    case "DetectedLanguageLowConfidenceException":
    case "com.amazonaws.translate#DetectedLanguageLowConfidenceException":
      throw await de_DetectedLanguageLowConfidenceExceptionRes(x);
    case "TextSizeLimitExceededException":
    case "com.amazonaws.translate#TextSizeLimitExceededException":
      throw await de_TextSizeLimitExceededExceptionRes(x);
    default:
      const T = x.body;
      return throwDefaultError({
        output: w,
        parsedBody: T,
        errorCode: $
      });
  }
}, de_ConcurrentModificationExceptionRes = async (w, M) => {
  const x = w.body, $ = _json(x), T = new ConcurrentModificationException({
    $metadata: deserializeMetadata(w),
    ...$
  });
  return decorateServiceException(T, x);
}, de_ConflictExceptionRes = async (w, M) => {
  const x = w.body, $ = _json(x), T = new ConflictException({
    $metadata: deserializeMetadata(w),
    ...$
  });
  return decorateServiceException(T, x);
}, de_DetectedLanguageLowConfidenceExceptionRes = async (w, M) => {
  const x = w.body, $ = _json(x), T = new DetectedLanguageLowConfidenceException({
    $metadata: deserializeMetadata(w),
    ...$
  });
  return decorateServiceException(T, x);
}, de_InternalServerExceptionRes = async (w, M) => {
  const x = w.body, $ = _json(x), T = new InternalServerException({
    $metadata: deserializeMetadata(w),
    ...$
  });
  return decorateServiceException(T, x);
}, de_InvalidFilterExceptionRes = async (w, M) => {
  const x = w.body, $ = _json(x), T = new InvalidFilterException({
    $metadata: deserializeMetadata(w),
    ...$
  });
  return decorateServiceException(T, x);
}, de_InvalidParameterValueExceptionRes = async (w, M) => {
  const x = w.body, $ = _json(x), T = new InvalidParameterValueException({
    $metadata: deserializeMetadata(w),
    ...$
  });
  return decorateServiceException(T, x);
}, de_InvalidRequestExceptionRes = async (w, M) => {
  const x = w.body, $ = _json(x), T = new InvalidRequestException({
    $metadata: deserializeMetadata(w),
    ...$
  });
  return decorateServiceException(T, x);
}, de_LimitExceededExceptionRes = async (w, M) => {
  const x = w.body, $ = _json(x), T = new LimitExceededException({
    $metadata: deserializeMetadata(w),
    ...$
  });
  return decorateServiceException(T, x);
}, de_ResourceNotFoundExceptionRes = async (w, M) => {
  const x = w.body, $ = _json(x), T = new ResourceNotFoundException({
    $metadata: deserializeMetadata(w),
    ...$
  });
  return decorateServiceException(T, x);
}, de_ServiceUnavailableExceptionRes = async (w, M) => {
  const x = w.body, $ = _json(x), T = new ServiceUnavailableException({
    $metadata: deserializeMetadata(w),
    ...$
  });
  return decorateServiceException(T, x);
}, de_TextSizeLimitExceededExceptionRes = async (w, M) => {
  const x = w.body, $ = _json(x), T = new TextSizeLimitExceededException({
    $metadata: deserializeMetadata(w),
    ...$
  });
  return decorateServiceException(T, x);
}, de_TooManyRequestsExceptionRes = async (w, M) => {
  const x = w.body, $ = _json(x), T = new TooManyRequestsException({
    $metadata: deserializeMetadata(w),
    ...$
  });
  return decorateServiceException(T, x);
}, de_TooManyTagsExceptionRes = async (w, M) => {
  const x = w.body, $ = _json(x), T = new TooManyTagsException({
    $metadata: deserializeMetadata(w),
    ...$
  });
  return decorateServiceException(T, x);
}, de_UnsupportedDisplayLanguageCodeExceptionRes = async (w, M) => {
  const x = w.body, $ = _json(x), T = new UnsupportedDisplayLanguageCodeException({
    $metadata: deserializeMetadata(w),
    ...$
  });
  return decorateServiceException(T, x);
}, de_UnsupportedLanguagePairExceptionRes = async (w, M) => {
  const x = w.body, $ = _json(x), T = new UnsupportedLanguagePairException({
    $metadata: deserializeMetadata(w),
    ...$
  });
  return decorateServiceException(T, x);
}, deserializeMetadata = (w) => ({
  httpStatusCode: w.statusCode,
  requestId: w.headers["x-amzn-requestid"] ?? w.headers["x-amzn-request-id"] ?? w.headers["x-amz-request-id"],
  extendedRequestId: w.headers["x-amz-id-2"],
  cfId: w.headers["x-amz-cf-id"]
}), throwDefaultError = withBaseException(TranslateServiceException), buildHttpRpcRequest = async (w, M, x, $, T) => {
  const { hostname: S, protocol: D = "https", port: F, path: z } = await w.endpoint(), Z = {
    protocol: D,
    hostname: S,
    port: F,
    method: "POST",
    path: z.endsWith("/") ? z.slice(0, -1) + x : z + x,
    headers: M
  };
  return T !== void 0 && (Z.body = T), new HttpRequest(Z);
};
function sharedHeaders(w) {
  return {
    "content-type": "application/x-amz-json-1.1",
    "x-amz-target": `AWSShineFrontendService_20170701.${w}`
  };
}
class ListLanguagesCommand extends Command.classBuilder().ep(commonParams).m(function(M, x, $, T) {
  return [
    getSerdePlugin($, this.serialize, this.deserialize),
    getEndpointPlugin($, M.getEndpointParameterInstructions())
  ];
}).s("AWSShineFrontendService_20170701", "ListLanguages", {}).n("TranslateClient", "ListLanguagesCommand").f(void 0, void 0).ser(se_ListLanguagesCommand).de(de_ListLanguagesCommand).build() {
}
class TranslateTextCommand extends Command.classBuilder().ep(commonParams).m(function(M, x, $, T) {
  return [
    getSerdePlugin($, this.serialize, this.deserialize),
    getEndpointPlugin($, M.getEndpointParameterInstructions())
  ];
}).s("AWSShineFrontendService_20170701", "TranslateText", {}).n("TranslateClient", "TranslateTextCommand").f(void 0, void 0).ser(se_TranslateTextCommand).de(de_TranslateTextCommand).build() {
}
function resolveLogins(w) {
  return Promise.all(Object.keys(w).reduce((M, x) => {
    const $ = w[x];
    return typeof $ == "string" ? M.push([x, $]) : M.push($().then((T) => [x, T])), M;
  }, [])).then((M) => M.reduce((x, [$, T]) => (x[$] = T, x), {}));
}
function fromCognitoIdentity(w) {
  return async (M) => {
    var Z;
    (Z = w.logger) == null || Z.debug("@aws-sdk/credential-provider-cognito-identity - fromCognitoIdentity");
    const { GetCredentialsForIdentityCommand: x, CognitoIdentityClient: $ } = await import("./loadCognitoIdentity-DWMWBvLV.mjs"), T = (H) => {
      var V, X, Q;
      return ((V = w.clientConfig) == null ? void 0 : V[H]) ?? ((X = w.parentClientConfig) == null ? void 0 : X[H]) ?? ((Q = M == null ? void 0 : M.callerClientConfig) == null ? void 0 : Q[H]);
    }, { Credentials: { AccessKeyId: S = throwOnMissingAccessKeyId(w.logger), Expiration: D, SecretKey: F = throwOnMissingSecretKey(w.logger), SessionToken: z } = throwOnMissingCredentials(w.logger) } = await (w.client ?? new $(Object.assign({}, w.clientConfig ?? {}, {
      region: T("region"),
      profile: T("profile")
    }))).send(new x({
      CustomRoleArn: w.customRoleArn,
      IdentityId: w.identityId,
      Logins: w.logins ? await resolveLogins(w.logins) : void 0
    }));
    return {
      identityId: w.identityId,
      accessKeyId: S,
      secretAccessKey: F,
      sessionToken: z,
      expiration: D
    };
  };
}
function throwOnMissingAccessKeyId(w) {
  throw new CredentialsProviderError("Response from Amazon Cognito contained no access key ID", { logger: w });
}
function throwOnMissingCredentials(w) {
  throw new CredentialsProviderError("Response from Amazon Cognito contained no credentials", { logger: w });
}
function throwOnMissingSecretKey(w) {
  throw new CredentialsProviderError("Response from Amazon Cognito contained no secret key", { logger: w });
}
const STORE_NAME = "IdentityIds";
class IndexedDbStorage {
  constructor(M = "aws:cognito-identity-ids") {
    ct(this, "dbName");
    this.dbName = M;
  }
  getItem(M) {
    return this.withObjectStore("readonly", (x) => {
      const $ = x.get(M);
      return new Promise((T) => {
        $.onerror = () => T(null), $.onsuccess = () => T($.result ? $.result.value : null);
      });
    }).catch(() => null);
  }
  removeItem(M) {
    return this.withObjectStore("readwrite", (x) => {
      const $ = x.delete(M);
      return new Promise((T, S) => {
        $.onerror = () => S($.error), $.onsuccess = () => T();
      });
    });
  }
  setItem(M, x) {
    return this.withObjectStore("readwrite", ($) => {
      const T = $.put({ id: M, value: x });
      return new Promise((S, D) => {
        T.onerror = () => D(T.error), T.onsuccess = () => S();
      });
    });
  }
  getDb() {
    const M = self.indexedDB.open(this.dbName, 1);
    return new Promise((x, $) => {
      M.onsuccess = () => {
        x(M.result);
      }, M.onerror = () => {
        $(M.error);
      }, M.onblocked = () => {
        $(new Error("Unable to access DB"));
      }, M.onupgradeneeded = () => {
        const T = M.result;
        T.onerror = () => {
          $(new Error("Failed to create object store"));
        }, T.createObjectStore(STORE_NAME, { keyPath: "id" });
      };
    });
  }
  withObjectStore(M, x) {
    return this.getDb().then(($) => {
      const T = $.transaction(STORE_NAME, M);
      return T.oncomplete = () => $.close(), new Promise((S, D) => {
        T.onerror = () => D(T.error), S(x(T.objectStore(STORE_NAME)));
      }).catch((S) => {
        throw $.close(), S;
      });
    });
  }
}
class InMemoryStorage {
  constructor(M = {}) {
    ct(this, "store");
    this.store = M;
  }
  getItem(M) {
    return M in this.store ? this.store[M] : null;
  }
  removeItem(M) {
    delete this.store[M];
  }
  setItem(M, x) {
    this.store[M] = x;
  }
}
const inMemoryStorage = new InMemoryStorage();
function localStorage() {
  return typeof self == "object" && self.indexedDB ? new IndexedDbStorage() : typeof window == "object" && window.localStorage ? window.localStorage : inMemoryStorage;
}
function fromCognitoIdentityPool$1({ accountId: w, cache: M = localStorage(), client: x, clientConfig: $, customRoleArn: T, identityPoolId: S, logins: D, userIdentifier: F = !D || Object.keys(D).length === 0 ? "ANONYMOUS" : void 0, logger: z, parentClientConfig: Z }) {
  z == null || z.debug("@aws-sdk/credential-provider-cognito-identity - fromCognitoIdentity");
  const H = F ? `aws:cognito-identity-credentials:${S}:${F}` : void 0;
  let V = async (X) => {
    const { GetIdCommand: Q, CognitoIdentityClient: fe } = await import("./loadCognitoIdentity-DWMWBvLV.mjs"), ce = (ne) => {
      var ge;
      return ($ == null ? void 0 : $[ne]) ?? (Z == null ? void 0 : Z[ne]) ?? ((ge = X == null ? void 0 : X.callerClientConfig) == null ? void 0 : ge[ne]);
    }, me = x ?? new fe(Object.assign({}, $ ?? {}, {
      region: ce("region"),
      profile: ce("profile")
    }));
    let de = H && await M.getItem(H);
    if (!de) {
      const { IdentityId: ne = throwOnMissingId(z) } = await me.send(new Q({
        AccountId: w,
        IdentityPoolId: S,
        Logins: D ? await resolveLogins(D) : void 0
      }));
      de = ne, H && Promise.resolve(M.setItem(H, de)).catch(() => {
      });
    }
    return V = fromCognitoIdentity({
      client: me,
      customRoleArn: T,
      logins: D,
      identityId: de
    }), V(X);
  };
  return (X) => V(X).catch(async (Q) => {
    throw H && Promise.resolve(M.removeItem(H)).catch(() => {
    }), Q;
  });
}
function throwOnMissingId(w) {
  throw new CredentialsProviderError("Response from Amazon Cognito contained no identity ID", { logger: w });
}
const fromCognitoIdentityPool = (w) => fromCognitoIdentityPool$1({
  ...w
});
var main = { exports: {} }, browser$c = {};
browser$c.endianness = function() {
  return "LE";
};
browser$c.hostname = function() {
  return typeof location < "u" ? location.hostname : "";
};
browser$c.loadavg = function() {
  return [];
};
browser$c.uptime = function() {
  return 0;
};
browser$c.freemem = function() {
  return Number.MAX_VALUE;
};
browser$c.totalmem = function() {
  return Number.MAX_VALUE;
};
browser$c.cpus = function() {
  return [];
};
browser$c.type = function() {
  return "Browser";
};
browser$c.release = function() {
  return typeof navigator < "u" ? navigator.appVersion : "";
};
browser$c.networkInterfaces = browser$c.getNetworkInterfaces = function() {
  return {};
};
browser$c.arch = function() {
  return "javascript";
};
browser$c.platform = function() {
  return "browser";
};
browser$c.tmpdir = browser$c.tmpDir = function() {
  return "/tmp";
};
browser$c.EOL = `
`;
browser$c.homedir = function() {
  return "/";
};
var cryptoBrowserify = {}, browser$b = { exports: {} }, safeBuffer$3 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(w, M) {
  var x = dist, $ = x.Buffer;
  function T(D, F) {
    for (var z in D)
      F[z] = D[z];
  }
  $.from && $.alloc && $.allocUnsafe && $.allocUnsafeSlow ? w.exports = x : (T(x, M), M.Buffer = S);
  function S(D, F, z) {
    return $(D, F, z);
  }
  S.prototype = Object.create($.prototype), T($, S), S.from = function(D, F, z) {
    if (typeof D == "number")
      throw new TypeError("Argument must not be a number");
    return $(D, F, z);
  }, S.alloc = function(D, F, z) {
    if (typeof D != "number")
      throw new TypeError("Argument must be a number");
    var Z = $(D);
    return F !== void 0 ? typeof z == "string" ? Z.fill(F, z) : Z.fill(F) : Z.fill(0), Z;
  }, S.allocUnsafe = function(D) {
    if (typeof D != "number")
      throw new TypeError("Argument must be a number");
    return $(D);
  }, S.allocUnsafeSlow = function(D) {
    if (typeof D != "number")
      throw new TypeError("Argument must be a number");
    return x.SlowBuffer(D);
  };
})(safeBuffer$3, safeBuffer$3.exports);
var safeBufferExports$2 = safeBuffer$3.exports, MAX_BYTES = 65536, MAX_UINT32 = 4294967295;
function oldBrowser$1() {
  throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
}
var Buffer$C = safeBufferExports$2.Buffer, crypto$3 = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
crypto$3 && crypto$3.getRandomValues ? browser$b.exports = randomBytes$2 : browser$b.exports = oldBrowser$1;
function randomBytes$2(w, M) {
  if (w > MAX_UINT32) throw new RangeError("requested too many random bytes");
  var x = Buffer$C.allocUnsafe(w);
  if (w > 0)
    if (w > MAX_BYTES)
      for (var $ = 0; $ < w; $ += MAX_BYTES)
        crypto$3.getRandomValues(x.slice($, $ + MAX_BYTES));
    else
      crypto$3.getRandomValues(x);
  return typeof M == "function" ? process$1.nextTick(function() {
    M(null, x);
  }) : x;
}
var browserExports = browser$b.exports, events = { exports: {} }, R = typeof Reflect == "object" ? Reflect : null, ReflectApply = R && typeof R.apply == "function" ? R.apply : function(M, x, $) {
  return Function.prototype.apply.call(M, x, $);
}, ReflectOwnKeys;
R && typeof R.ownKeys == "function" ? ReflectOwnKeys = R.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys = function(M) {
  return Object.getOwnPropertyNames(M).concat(Object.getOwnPropertySymbols(M));
} : ReflectOwnKeys = function(M) {
  return Object.getOwnPropertyNames(M);
};
function ProcessEmitWarning(w) {
  console && console.warn && console.warn(w);
}
var NumberIsNaN = Number.isNaN || function(M) {
  return M !== M;
};
function EventEmitter() {
  EventEmitter.init.call(this);
}
events.exports = EventEmitter;
events.exports.once = once;
EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = void 0;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(w) {
  if (typeof w != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof w);
}
Object.defineProperty(EventEmitter, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(w) {
    if (typeof w != "number" || w < 0 || NumberIsNaN(w))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + w + ".");
    defaultMaxListeners = w;
  }
});
EventEmitter.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
EventEmitter.prototype.setMaxListeners = function(M) {
  if (typeof M != "number" || M < 0 || NumberIsNaN(M))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + M + ".");
  return this._maxListeners = M, this;
};
function _getMaxListeners(w) {
  return w._maxListeners === void 0 ? EventEmitter.defaultMaxListeners : w._maxListeners;
}
EventEmitter.prototype.getMaxListeners = function() {
  return _getMaxListeners(this);
};
EventEmitter.prototype.emit = function(M) {
  for (var x = [], $ = 1; $ < arguments.length; $++) x.push(arguments[$]);
  var T = M === "error", S = this._events;
  if (S !== void 0)
    T = T && S.error === void 0;
  else if (!T)
    return !1;
  if (T) {
    var D;
    if (x.length > 0 && (D = x[0]), D instanceof Error)
      throw D;
    var F = new Error("Unhandled error." + (D ? " (" + D.message + ")" : ""));
    throw F.context = D, F;
  }
  var z = S[M];
  if (z === void 0)
    return !1;
  if (typeof z == "function")
    ReflectApply(z, this, x);
  else
    for (var Z = z.length, H = arrayClone(z, Z), $ = 0; $ < Z; ++$)
      ReflectApply(H[$], this, x);
  return !0;
};
function _addListener(w, M, x, $) {
  var T, S, D;
  if (checkListener(x), S = w._events, S === void 0 ? (S = w._events = /* @__PURE__ */ Object.create(null), w._eventsCount = 0) : (S.newListener !== void 0 && (w.emit(
    "newListener",
    M,
    x.listener ? x.listener : x
  ), S = w._events), D = S[M]), D === void 0)
    D = S[M] = x, ++w._eventsCount;
  else if (typeof D == "function" ? D = S[M] = $ ? [x, D] : [D, x] : $ ? D.unshift(x) : D.push(x), T = _getMaxListeners(w), T > 0 && D.length > T && !D.warned) {
    D.warned = !0;
    var F = new Error("Possible EventEmitter memory leak detected. " + D.length + " " + String(M) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    F.name = "MaxListenersExceededWarning", F.emitter = w, F.type = M, F.count = D.length, ProcessEmitWarning(F);
  }
  return w;
}
EventEmitter.prototype.addListener = function(M, x) {
  return _addListener(this, M, x, !1);
};
EventEmitter.prototype.on = EventEmitter.prototype.addListener;
EventEmitter.prototype.prependListener = function(M, x) {
  return _addListener(this, M, x, !0);
};
function onceWrapper() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _onceWrap(w, M, x) {
  var $ = { fired: !1, wrapFn: void 0, target: w, type: M, listener: x }, T = onceWrapper.bind($);
  return T.listener = x, $.wrapFn = T, T;
}
EventEmitter.prototype.once = function(M, x) {
  return checkListener(x), this.on(M, _onceWrap(this, M, x)), this;
};
EventEmitter.prototype.prependOnceListener = function(M, x) {
  return checkListener(x), this.prependListener(M, _onceWrap(this, M, x)), this;
};
EventEmitter.prototype.removeListener = function(M, x) {
  var $, T, S, D, F;
  if (checkListener(x), T = this._events, T === void 0)
    return this;
  if ($ = T[M], $ === void 0)
    return this;
  if ($ === x || $.listener === x)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete T[M], T.removeListener && this.emit("removeListener", M, $.listener || x));
  else if (typeof $ != "function") {
    for (S = -1, D = $.length - 1; D >= 0; D--)
      if ($[D] === x || $[D].listener === x) {
        F = $[D].listener, S = D;
        break;
      }
    if (S < 0)
      return this;
    S === 0 ? $.shift() : spliceOne($, S), $.length === 1 && (T[M] = $[0]), T.removeListener !== void 0 && this.emit("removeListener", M, F || x);
  }
  return this;
};
EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
EventEmitter.prototype.removeAllListeners = function(M) {
  var x, $, T;
  if ($ = this._events, $ === void 0)
    return this;
  if ($.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : $[M] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete $[M]), this;
  if (arguments.length === 0) {
    var S = Object.keys($), D;
    for (T = 0; T < S.length; ++T)
      D = S[T], D !== "removeListener" && this.removeAllListeners(D);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (x = $[M], typeof x == "function")
    this.removeListener(M, x);
  else if (x !== void 0)
    for (T = x.length - 1; T >= 0; T--)
      this.removeListener(M, x[T]);
  return this;
};
function _listeners(w, M, x) {
  var $ = w._events;
  if ($ === void 0)
    return [];
  var T = $[M];
  return T === void 0 ? [] : typeof T == "function" ? x ? [T.listener || T] : [T] : x ? unwrapListeners(T) : arrayClone(T, T.length);
}
EventEmitter.prototype.listeners = function(M) {
  return _listeners(this, M, !0);
};
EventEmitter.prototype.rawListeners = function(M) {
  return _listeners(this, M, !1);
};
EventEmitter.listenerCount = function(w, M) {
  return typeof w.listenerCount == "function" ? w.listenerCount(M) : listenerCount.call(w, M);
};
EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(w) {
  var M = this._events;
  if (M !== void 0) {
    var x = M[w];
    if (typeof x == "function")
      return 1;
    if (x !== void 0)
      return x.length;
  }
  return 0;
}
EventEmitter.prototype.eventNames = function() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone(w, M) {
  for (var x = new Array(M), $ = 0; $ < M; ++$)
    x[$] = w[$];
  return x;
}
function spliceOne(w, M) {
  for (; M + 1 < w.length; M++)
    w[M] = w[M + 1];
  w.pop();
}
function unwrapListeners(w) {
  for (var M = new Array(w.length), x = 0; x < M.length; ++x)
    M[x] = w[x].listener || w[x];
  return M;
}
function once(w, M) {
  return new Promise(function(x, $) {
    function T(D) {
      w.removeListener(M, S), $(D);
    }
    function S() {
      typeof w.removeListener == "function" && w.removeListener("error", T), x([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(w, M, S, { once: !0 }), M !== "error" && addErrorHandlerIfEventEmitter(w, T, { once: !0 });
  });
}
function addErrorHandlerIfEventEmitter(w, M, x) {
  typeof w.on == "function" && eventTargetAgnosticAddListener(w, "error", M, x);
}
function eventTargetAgnosticAddListener(w, M, x, $) {
  if (typeof w.on == "function")
    $.once ? w.once(M, x) : w.on(M, x);
  else if (typeof w.addEventListener == "function")
    w.addEventListener(M, function T(S) {
      $.once && w.removeEventListener(M, T), x(S);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof w);
}
var eventsExports = events.exports, streamBrowser$1, hasRequiredStreamBrowser;
function requireStreamBrowser() {
  return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1, streamBrowser$1 = eventsExports.EventEmitter), streamBrowser$1;
}
var buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list) return buffer_list;
  hasRequiredBuffer_list = 1;
  function w(fe, ce) {
    var me = Object.keys(fe);
    if (Object.getOwnPropertySymbols) {
      var de = Object.getOwnPropertySymbols(fe);
      ce && (de = de.filter(function(ne) {
        return Object.getOwnPropertyDescriptor(fe, ne).enumerable;
      })), me.push.apply(me, de);
    }
    return me;
  }
  function M(fe) {
    for (var ce = 1; ce < arguments.length; ce++) {
      var me = arguments[ce] != null ? arguments[ce] : {};
      ce % 2 ? w(Object(me), !0).forEach(function(de) {
        x(fe, de, me[de]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(fe, Object.getOwnPropertyDescriptors(me)) : w(Object(me)).forEach(function(de) {
        Object.defineProperty(fe, de, Object.getOwnPropertyDescriptor(me, de));
      });
    }
    return fe;
  }
  function x(fe, ce, me) {
    return ce = D(ce), ce in fe ? Object.defineProperty(fe, ce, { value: me, enumerable: !0, configurable: !0, writable: !0 }) : fe[ce] = me, fe;
  }
  function $(fe, ce) {
    if (!(fe instanceof ce))
      throw new TypeError("Cannot call a class as a function");
  }
  function T(fe, ce) {
    for (var me = 0; me < ce.length; me++) {
      var de = ce[me];
      de.enumerable = de.enumerable || !1, de.configurable = !0, "value" in de && (de.writable = !0), Object.defineProperty(fe, D(de.key), de);
    }
  }
  function S(fe, ce, me) {
    return ce && T(fe.prototype, ce), Object.defineProperty(fe, "prototype", { writable: !1 }), fe;
  }
  function D(fe) {
    var ce = F(fe, "string");
    return typeof ce == "symbol" ? ce : String(ce);
  }
  function F(fe, ce) {
    if (typeof fe != "object" || fe === null) return fe;
    var me = fe[Symbol.toPrimitive];
    if (me !== void 0) {
      var de = me.call(fe, ce);
      if (typeof de != "object") return de;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return String(fe);
  }
  var z = dist, Z = z.Buffer, H = util$3, V = H.inspect, X = V && V.custom || "inspect";
  function Q(fe, ce, me) {
    Z.prototype.copy.call(fe, ce, me);
  }
  return buffer_list = /* @__PURE__ */ function() {
    function fe() {
      $(this, fe), this.head = null, this.tail = null, this.length = 0;
    }
    return S(fe, [{
      key: "push",
      value: function(me) {
        var de = {
          data: me,
          next: null
        };
        this.length > 0 ? this.tail.next = de : this.head = de, this.tail = de, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(me) {
        var de = {
          data: me,
          next: this.head
        };
        this.length === 0 && (this.tail = de), this.head = de, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var me = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, me;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(me) {
        if (this.length === 0) return "";
        for (var de = this.head, ne = "" + de.data; de = de.next; ) ne += me + de.data;
        return ne;
      }
    }, {
      key: "concat",
      value: function(me) {
        if (this.length === 0) return Z.alloc(0);
        for (var de = Z.allocUnsafe(me >>> 0), ne = this.head, ge = 0; ne; )
          Q(ne.data, de, ge), ge += ne.data.length, ne = ne.next;
        return de;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(me, de) {
        var ne;
        return me < this.head.data.length ? (ne = this.head.data.slice(0, me), this.head.data = this.head.data.slice(me)) : me === this.head.data.length ? ne = this.shift() : ne = de ? this._getString(me) : this._getBuffer(me), ne;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(me) {
        var de = this.head, ne = 1, ge = de.data;
        for (me -= ge.length; de = de.next; ) {
          var pe = de.data, $e = me > pe.length ? pe.length : me;
          if ($e === pe.length ? ge += pe : ge += pe.slice(0, me), me -= $e, me === 0) {
            $e === pe.length ? (++ne, de.next ? this.head = de.next : this.head = this.tail = null) : (this.head = de, de.data = pe.slice($e));
            break;
          }
          ++ne;
        }
        return this.length -= ne, ge;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(me) {
        var de = Z.allocUnsafe(me), ne = this.head, ge = 1;
        for (ne.data.copy(de), me -= ne.data.length; ne = ne.next; ) {
          var pe = ne.data, $e = me > pe.length ? pe.length : me;
          if (pe.copy(de, de.length - me, 0, $e), me -= $e, me === 0) {
            $e === pe.length ? (++ge, ne.next ? this.head = ne.next : this.head = this.tail = null) : (this.head = ne, ne.data = pe.slice($e));
            break;
          }
          ++ge;
        }
        return this.length -= ge, de;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: X,
      value: function(me, de) {
        return V(this, M(M({}, de), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), fe;
  }(), buffer_list;
}
var destroy_1$1, hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy) return destroy_1$1;
  hasRequiredDestroy = 1;
  function w(D, F) {
    var z = this, Z = this._readableState && this._readableState.destroyed, H = this._writableState && this._writableState.destroyed;
    return Z || H ? (F ? F(D) : D && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(T, this, D)) : process$1.nextTick(T, this, D)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(D || null, function(V) {
      !F && V ? z._writableState ? z._writableState.errorEmitted ? process$1.nextTick(x, z) : (z._writableState.errorEmitted = !0, process$1.nextTick(M, z, V)) : process$1.nextTick(M, z, V) : F ? (process$1.nextTick(x, z), F(V)) : process$1.nextTick(x, z);
    }), this);
  }
  function M(D, F) {
    T(D, F), x(D);
  }
  function x(D) {
    D._writableState && !D._writableState.emitClose || D._readableState && !D._readableState.emitClose || D.emit("close");
  }
  function $() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function T(D, F) {
    D.emit("error", F);
  }
  function S(D, F) {
    var z = D._readableState, Z = D._writableState;
    z && z.autoDestroy || Z && Z.autoDestroy ? D.destroy(F) : D.emit("error", F);
  }
  return destroy_1$1 = {
    destroy: w,
    undestroy: $,
    errorOrDestroy: S
  }, destroy_1$1;
}
var errorsBrowser = {}, hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser) return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  function w(F, z) {
    F.prototype = Object.create(z.prototype), F.prototype.constructor = F, F.__proto__ = z;
  }
  var M = {};
  function x(F, z, Z) {
    Z || (Z = Error);
    function H(X, Q, fe) {
      return typeof z == "string" ? z : z(X, Q, fe);
    }
    var V = /* @__PURE__ */ function(X) {
      w(Q, X);
      function Q(fe, ce, me) {
        return X.call(this, H(fe, ce, me)) || this;
      }
      return Q;
    }(Z);
    V.prototype.name = Z.name, V.prototype.code = F, M[F] = V;
  }
  function $(F, z) {
    if (Array.isArray(F)) {
      var Z = F.length;
      return F = F.map(function(H) {
        return String(H);
      }), Z > 2 ? "one of ".concat(z, " ").concat(F.slice(0, Z - 1).join(", "), ", or ") + F[Z - 1] : Z === 2 ? "one of ".concat(z, " ").concat(F[0], " or ").concat(F[1]) : "of ".concat(z, " ").concat(F[0]);
    } else
      return "of ".concat(z, " ").concat(String(F));
  }
  function T(F, z, Z) {
    return F.substr(0, z.length) === z;
  }
  function S(F, z, Z) {
    return (Z === void 0 || Z > F.length) && (Z = F.length), F.substring(Z - z.length, Z) === z;
  }
  function D(F, z, Z) {
    return typeof Z != "number" && (Z = 0), Z + z.length > F.length ? !1 : F.indexOf(z, Z) !== -1;
  }
  return x("ERR_INVALID_OPT_VALUE", function(F, z) {
    return 'The value "' + z + '" is invalid for option "' + F + '"';
  }, TypeError), x("ERR_INVALID_ARG_TYPE", function(F, z, Z) {
    var H;
    typeof z == "string" && T(z, "not ") ? (H = "must not be", z = z.replace(/^not /, "")) : H = "must be";
    var V;
    if (S(F, " argument"))
      V = "The ".concat(F, " ").concat(H, " ").concat($(z, "type"));
    else {
      var X = D(F, ".") ? "property" : "argument";
      V = 'The "'.concat(F, '" ').concat(X, " ").concat(H, " ").concat($(z, "type"));
    }
    return V += ". Received type ".concat(typeof Z), V;
  }, TypeError), x("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), x("ERR_METHOD_NOT_IMPLEMENTED", function(F) {
    return "The " + F + " method is not implemented";
  }), x("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), x("ERR_STREAM_DESTROYED", function(F) {
    return "Cannot call " + F + " after a stream was destroyed";
  }), x("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), x("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), x("ERR_STREAM_WRITE_AFTER_END", "write after end"), x("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), x("ERR_UNKNOWN_ENCODING", function(F) {
    return "Unknown encoding: " + F;
  }, TypeError), x("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), errorsBrowser.codes = M, errorsBrowser;
}
var state, hasRequiredState;
function requireState() {
  if (hasRequiredState) return state;
  hasRequiredState = 1;
  var w = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function M($, T, S) {
    return $.highWaterMark != null ? $.highWaterMark : T ? $[S] : null;
  }
  function x($, T, S, D) {
    var F = M(T, D, S);
    if (F != null) {
      if (!(isFinite(F) && Math.floor(F) === F) || F < 0) {
        var z = D ? S : "highWaterMark";
        throw new w(z, F);
      }
      return Math.floor(F);
    }
    return $.objectMode ? 16 : 16 * 1024;
  }
  return state = {
    getHighWaterMark: x
  }, state;
}
var browser$a = deprecate;
function deprecate(w, M) {
  if (config$1("noDeprecation"))
    return w;
  var x = !1;
  function $() {
    if (!x) {
      if (config$1("throwDeprecation"))
        throw new Error(M);
      config$1("traceDeprecation") ? console.trace(M) : console.warn(M), x = !0;
    }
    return w.apply(this, arguments);
  }
  return $;
}
function config$1(w) {
  try {
    if (!commonjsGlobal.localStorage) return !1;
  } catch {
    return !1;
  }
  var M = commonjsGlobal.localStorage[w];
  return M == null ? !1 : String(M).toLowerCase() === "true";
}
var _stream_writable$1, hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1) return _stream_writable$1;
  hasRequired_stream_writable$1 = 1, _stream_writable$1 = Oe;
  function w(re) {
    var ee = this;
    this.next = null, this.entry = null, this.finish = function() {
      oe(ee, re);
    };
  }
  var M;
  Oe.WritableState = Re;
  var x = {
    deprecate: browser$a
  }, $ = requireStreamBrowser(), T = dist.Buffer, S = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function D(re) {
    return T.from(re);
  }
  function F(re) {
    return T.isBuffer(re) || re instanceof S;
  }
  var z = requireDestroy(), Z = requireState(), H = Z.getHighWaterMark, V = requireErrorsBrowser().codes, X = V.ERR_INVALID_ARG_TYPE, Q = V.ERR_METHOD_NOT_IMPLEMENTED, fe = V.ERR_MULTIPLE_CALLBACK, ce = V.ERR_STREAM_CANNOT_PIPE, me = V.ERR_STREAM_DESTROYED, de = V.ERR_STREAM_NULL_VALUES, ne = V.ERR_STREAM_WRITE_AFTER_END, ge = V.ERR_UNKNOWN_ENCODING, pe = z.errorOrDestroy;
  inherits_browserExports(Oe, $);
  function $e() {
  }
  function Re(re, ee, ae) {
    M = M || require_stream_duplex$1(), re = re || {}, typeof ae != "boolean" && (ae = ee instanceof M), this.objectMode = !!re.objectMode, ae && (this.objectMode = this.objectMode || !!re.writableObjectMode), this.highWaterMark = H(this, re, "writableHighWaterMark", ae), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var ue = re.decodeStrings === !1;
    this.decodeStrings = !ue, this.defaultEncoding = re.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(ye) {
      O(ee, ye);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = re.emitClose !== !1, this.autoDestroy = !!re.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new w(this);
  }
  Re.prototype.getBuffer = function() {
    for (var ee = this.bufferedRequest, ae = []; ee; )
      ae.push(ee), ee = ee.next;
    return ae;
  }, function() {
    try {
      Object.defineProperty(Re.prototype, "buffer", {
        get: x.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var Pe;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (Pe = Function.prototype[Symbol.hasInstance], Object.defineProperty(Oe, Symbol.hasInstance, {
    value: function(ee) {
      return Pe.call(this, ee) ? !0 : this !== Oe ? !1 : ee && ee._writableState instanceof Re;
    }
  })) : Pe = function(ee) {
    return ee instanceof this;
  };
  function Oe(re) {
    M = M || require_stream_duplex$1();
    var ee = this instanceof M;
    if (!ee && !Pe.call(Oe, this)) return new Oe(re);
    this._writableState = new Re(re, this, ee), this.writable = !0, re && (typeof re.write == "function" && (this._write = re.write), typeof re.writev == "function" && (this._writev = re.writev), typeof re.destroy == "function" && (this._destroy = re.destroy), typeof re.final == "function" && (this._final = re.final)), $.call(this);
  }
  Oe.prototype.pipe = function() {
    pe(this, new ce());
  };
  function xe(re, ee) {
    var ae = new ne();
    pe(re, ae), process$1.nextTick(ee, ae);
  }
  function rt(re, ee, ae, ue) {
    var ye;
    return ae === null ? ye = new de() : typeof ae != "string" && !ee.objectMode && (ye = new X("chunk", ["string", "Buffer"], ae)), ye ? (pe(re, ye), process$1.nextTick(ue, ye), !1) : !0;
  }
  Oe.prototype.write = function(re, ee, ae) {
    var ue = this._writableState, ye = !1, ve = !ue.objectMode && F(re);
    return ve && !T.isBuffer(re) && (re = D(re)), typeof ee == "function" && (ae = ee, ee = null), ve ? ee = "buffer" : ee || (ee = ue.defaultEncoding), typeof ae != "function" && (ae = $e), ue.ending ? xe(this, ae) : (ve || rt(this, ue, re, ae)) && (ue.pendingcb++, ye = y(this, ue, ve, re, ee, ae)), ye;
  }, Oe.prototype.cork = function() {
    this._writableState.corked++;
  }, Oe.prototype.uncork = function() {
    var re = this._writableState;
    re.corked && (re.corked--, !re.writing && !re.corked && !re.bufferProcessing && re.bufferedRequest && P(this, re));
  }, Oe.prototype.setDefaultEncoding = function(ee) {
    if (typeof ee == "string" && (ee = ee.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((ee + "").toLowerCase()) > -1)) throw new ge(ee);
    return this._writableState.defaultEncoding = ee, this;
  }, Object.defineProperty(Oe.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function N(re, ee, ae) {
    return !re.objectMode && re.decodeStrings !== !1 && typeof ee == "string" && (ee = T.from(ee, ae)), ee;
  }
  Object.defineProperty(Oe.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function y(re, ee, ae, ue, ye, ve) {
    if (!ae) {
      var he = N(ee, ue, ye);
      ue !== he && (ae = !0, ye = "buffer", ue = he);
    }
    var Me = ee.objectMode ? 1 : ue.length;
    ee.length += Me;
    var Qe = ee.length < ee.highWaterMark;
    if (Qe || (ee.needDrain = !0), ee.writing || ee.corked) {
      var Ie = ee.lastBufferedRequest;
      ee.lastBufferedRequest = {
        chunk: ue,
        encoding: ye,
        isBuf: ae,
        callback: ve,
        next: null
      }, Ie ? Ie.next = ee.lastBufferedRequest : ee.bufferedRequest = ee.lastBufferedRequest, ee.bufferedRequestCount += 1;
    } else
      E(re, ee, !1, Me, ue, ye, ve);
    return Qe;
  }
  function E(re, ee, ae, ue, ye, ve, he) {
    ee.writelen = ue, ee.writecb = he, ee.writing = !0, ee.sync = !0, ee.destroyed ? ee.onwrite(new me("write")) : ae ? re._writev(ye, ee.onwrite) : re._write(ye, ve, ee.onwrite), ee.sync = !1;
  }
  function A(re, ee, ae, ue, ye) {
    --ee.pendingcb, ae ? (process$1.nextTick(ye, ue), process$1.nextTick(Y, re, ee), re._writableState.errorEmitted = !0, pe(re, ue)) : (ye(ue), re._writableState.errorEmitted = !0, pe(re, ue), Y(re, ee));
  }
  function B(re) {
    re.writing = !1, re.writecb = null, re.length -= re.writelen, re.writelen = 0;
  }
  function O(re, ee) {
    var ae = re._writableState, ue = ae.sync, ye = ae.writecb;
    if (typeof ye != "function") throw new fe();
    if (B(ae), ee) A(re, ae, ue, ee, ye);
    else {
      var ve = _(ae) || re.destroyed;
      !ve && !ae.corked && !ae.bufferProcessing && ae.bufferedRequest && P(re, ae), ue ? process$1.nextTick(C, re, ae, ve, ye) : C(re, ae, ve, ye);
    }
  }
  function C(re, ee, ae, ue) {
    ae || L(re, ee), ee.pendingcb--, ue(), Y(re, ee);
  }
  function L(re, ee) {
    ee.length === 0 && ee.needDrain && (ee.needDrain = !1, re.emit("drain"));
  }
  function P(re, ee) {
    ee.bufferProcessing = !0;
    var ae = ee.bufferedRequest;
    if (re._writev && ae && ae.next) {
      var ue = ee.bufferedRequestCount, ye = new Array(ue), ve = ee.corkedRequestsFree;
      ve.entry = ae;
      for (var he = 0, Me = !0; ae; )
        ye[he] = ae, ae.isBuf || (Me = !1), ae = ae.next, he += 1;
      ye.allBuffers = Me, E(re, ee, !0, ee.length, ye, "", ve.finish), ee.pendingcb++, ee.lastBufferedRequest = null, ve.next ? (ee.corkedRequestsFree = ve.next, ve.next = null) : ee.corkedRequestsFree = new w(ee), ee.bufferedRequestCount = 0;
    } else {
      for (; ae; ) {
        var Qe = ae.chunk, Ie = ae.encoding, De = ae.callback, at = ee.objectMode ? 1 : Qe.length;
        if (E(re, ee, !1, at, Qe, Ie, De), ae = ae.next, ee.bufferedRequestCount--, ee.writing)
          break;
      }
      ae === null && (ee.lastBufferedRequest = null);
    }
    ee.bufferedRequest = ae, ee.bufferProcessing = !1;
  }
  Oe.prototype._write = function(re, ee, ae) {
    ae(new Q("_write()"));
  }, Oe.prototype._writev = null, Oe.prototype.end = function(re, ee, ae) {
    var ue = this._writableState;
    return typeof re == "function" ? (ae = re, re = null, ee = null) : typeof ee == "function" && (ae = ee, ee = null), re != null && this.write(re, ee), ue.corked && (ue.corked = 1, this.uncork()), ue.ending || te(this, ue, ae), this;
  }, Object.defineProperty(Oe.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function _(re) {
    return re.ending && re.length === 0 && re.bufferedRequest === null && !re.finished && !re.writing;
  }
  function I(re, ee) {
    re._final(function(ae) {
      ee.pendingcb--, ae && pe(re, ae), ee.prefinished = !0, re.emit("prefinish"), Y(re, ee);
    });
  }
  function U(re, ee) {
    !ee.prefinished && !ee.finalCalled && (typeof re._final == "function" && !ee.destroyed ? (ee.pendingcb++, ee.finalCalled = !0, process$1.nextTick(I, re, ee)) : (ee.prefinished = !0, re.emit("prefinish")));
  }
  function Y(re, ee) {
    var ae = _(ee);
    if (ae && (U(re, ee), ee.pendingcb === 0 && (ee.finished = !0, re.emit("finish"), ee.autoDestroy))) {
      var ue = re._readableState;
      (!ue || ue.autoDestroy && ue.endEmitted) && re.destroy();
    }
    return ae;
  }
  function te(re, ee, ae) {
    ee.ending = !0, Y(re, ee), ae && (ee.finished ? process$1.nextTick(ae) : re.once("finish", ae)), ee.ended = !0, re.writable = !1;
  }
  function oe(re, ee, ae) {
    var ue = re.entry;
    for (re.entry = null; ue; ) {
      var ye = ue.callback;
      ee.pendingcb--, ye(ae), ue = ue.next;
    }
    ee.corkedRequestsFree.next = re;
  }
  return Object.defineProperty(Oe.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(ee) {
      this._writableState && (this._writableState.destroyed = ee);
    }
  }), Oe.prototype.destroy = z.destroy, Oe.prototype._undestroy = z.undestroy, Oe.prototype._destroy = function(re, ee) {
    ee(re);
  }, _stream_writable$1;
}
var _stream_duplex$1, hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1) return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var w = Object.keys || function(Z) {
    var H = [];
    for (var V in Z) H.push(V);
    return H;
  };
  _stream_duplex$1 = D;
  var M = require_stream_readable$1(), x = require_stream_writable$1();
  inherits_browserExports(D, M);
  for (var $ = w(x.prototype), T = 0; T < $.length; T++) {
    var S = $[T];
    D.prototype[S] || (D.prototype[S] = x.prototype[S]);
  }
  function D(Z) {
    if (!(this instanceof D)) return new D(Z);
    M.call(this, Z), x.call(this, Z), this.allowHalfOpen = !0, Z && (Z.readable === !1 && (this.readable = !1), Z.writable === !1 && (this.writable = !1), Z.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", F)));
  }
  Object.defineProperty(D.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(D.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(D.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function F() {
    this._writableState.ended || process$1.nextTick(z, this);
  }
  function z(Z) {
    Z.end();
  }
  return Object.defineProperty(D.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(H) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = H, this._writableState.destroyed = H);
    }
  }), _stream_duplex$1;
}
var string_decoder = {}, safeBuffer$2 = { exports: {} };
(function(w, M) {
  var x = dist, $ = x.Buffer;
  function T(D, F) {
    for (var z in D)
      F[z] = D[z];
  }
  $.from && $.alloc && $.allocUnsafe && $.allocUnsafeSlow ? w.exports = x : (T(x, M), M.Buffer = S);
  function S(D, F, z) {
    return $(D, F, z);
  }
  T($, S), S.from = function(D, F, z) {
    if (typeof D == "number")
      throw new TypeError("Argument must not be a number");
    return $(D, F, z);
  }, S.alloc = function(D, F, z) {
    if (typeof D != "number")
      throw new TypeError("Argument must be a number");
    var Z = $(D);
    return F !== void 0 ? typeof z == "string" ? Z.fill(F, z) : Z.fill(F) : Z.fill(0), Z;
  }, S.allocUnsafe = function(D) {
    if (typeof D != "number")
      throw new TypeError("Argument must be a number");
    return $(D);
  }, S.allocUnsafeSlow = function(D) {
    if (typeof D != "number")
      throw new TypeError("Argument must be a number");
    return x.SlowBuffer(D);
  };
})(safeBuffer$2, safeBuffer$2.exports);
var safeBufferExports$1 = safeBuffer$2.exports, Buffer$B = safeBufferExports$1.Buffer, isEncoding = Buffer$B.isEncoding || function(w) {
  switch (w = "" + w, w && w.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return !0;
    default:
      return !1;
  }
};
function _normalizeEncoding(w) {
  if (!w) return "utf8";
  for (var M; ; )
    switch (w) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return w;
      default:
        if (M) return;
        w = ("" + w).toLowerCase(), M = !0;
    }
}
function normalizeEncoding(w) {
  var M = _normalizeEncoding(w);
  if (typeof M != "string" && (Buffer$B.isEncoding === isEncoding || !isEncoding(w))) throw new Error("Unknown encoding: " + w);
  return M || w;
}
string_decoder.StringDecoder = StringDecoder$1;
function StringDecoder$1(w) {
  this.encoding = normalizeEncoding(w);
  var M;
  switch (this.encoding) {
    case "utf16le":
      this.text = utf16Text, this.end = utf16End, M = 4;
      break;
    case "utf8":
      this.fillLast = utf8FillLast, M = 4;
      break;
    case "base64":
      this.text = base64Text, this.end = base64End, M = 3;
      break;
    default:
      this.write = simpleWrite, this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Buffer$B.allocUnsafe(M);
}
StringDecoder$1.prototype.write = function(w) {
  if (w.length === 0) return "";
  var M, x;
  if (this.lastNeed) {
    if (M = this.fillLast(w), M === void 0) return "";
    x = this.lastNeed, this.lastNeed = 0;
  } else
    x = 0;
  return x < w.length ? M ? M + this.text(w, x) : this.text(w, x) : M || "";
};
StringDecoder$1.prototype.end = utf8End;
StringDecoder$1.prototype.text = utf8Text;
StringDecoder$1.prototype.fillLast = function(w) {
  if (this.lastNeed <= w.length)
    return w.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  w.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, w.length), this.lastNeed -= w.length;
};
function utf8CheckByte(w) {
  return w <= 127 ? 0 : w >> 5 === 6 ? 2 : w >> 4 === 14 ? 3 : w >> 3 === 30 ? 4 : w >> 6 === 2 ? -1 : -2;
}
function utf8CheckIncomplete(w, M, x) {
  var $ = M.length - 1;
  if ($ < x) return 0;
  var T = utf8CheckByte(M[$]);
  return T >= 0 ? (T > 0 && (w.lastNeed = T - 1), T) : --$ < x || T === -2 ? 0 : (T = utf8CheckByte(M[$]), T >= 0 ? (T > 0 && (w.lastNeed = T - 2), T) : --$ < x || T === -2 ? 0 : (T = utf8CheckByte(M[$]), T >= 0 ? (T > 0 && (T === 2 ? T = 0 : w.lastNeed = T - 3), T) : 0));
}
function utf8CheckExtraBytes(w, M, x) {
  if ((M[0] & 192) !== 128)
    return w.lastNeed = 0, "";
  if (w.lastNeed > 1 && M.length > 1) {
    if ((M[1] & 192) !== 128)
      return w.lastNeed = 1, "";
    if (w.lastNeed > 2 && M.length > 2 && (M[2] & 192) !== 128)
      return w.lastNeed = 2, "";
  }
}
function utf8FillLast(w) {
  var M = this.lastTotal - this.lastNeed, x = utf8CheckExtraBytes(this, w);
  if (x !== void 0) return x;
  if (this.lastNeed <= w.length)
    return w.copy(this.lastChar, M, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  w.copy(this.lastChar, M, 0, w.length), this.lastNeed -= w.length;
}
function utf8Text(w, M) {
  var x = utf8CheckIncomplete(this, w, M);
  if (!this.lastNeed) return w.toString("utf8", M);
  this.lastTotal = x;
  var $ = w.length - (x - this.lastNeed);
  return w.copy(this.lastChar, 0, $), w.toString("utf8", M, $);
}
function utf8End(w) {
  var M = w && w.length ? this.write(w) : "";
  return this.lastNeed ? M + "" : M;
}
function utf16Text(w, M) {
  if ((w.length - M) % 2 === 0) {
    var x = w.toString("utf16le", M);
    if (x) {
      var $ = x.charCodeAt(x.length - 1);
      if ($ >= 55296 && $ <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = w[w.length - 2], this.lastChar[1] = w[w.length - 1], x.slice(0, -1);
    }
    return x;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = w[w.length - 1], w.toString("utf16le", M, w.length - 1);
}
function utf16End(w) {
  var M = w && w.length ? this.write(w) : "";
  if (this.lastNeed) {
    var x = this.lastTotal - this.lastNeed;
    return M + this.lastChar.toString("utf16le", 0, x);
  }
  return M;
}
function base64Text(w, M) {
  var x = (w.length - M) % 3;
  return x === 0 ? w.toString("base64", M) : (this.lastNeed = 3 - x, this.lastTotal = 3, x === 1 ? this.lastChar[0] = w[w.length - 1] : (this.lastChar[0] = w[w.length - 2], this.lastChar[1] = w[w.length - 1]), w.toString("base64", M, w.length - x));
}
function base64End(w) {
  var M = w && w.length ? this.write(w) : "";
  return this.lastNeed ? M + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : M;
}
function simpleWrite(w) {
  return w.toString(this.encoding);
}
function simpleEnd(w) {
  return w && w.length ? this.write(w) : "";
}
var endOfStream, hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream) return endOfStream;
  hasRequiredEndOfStream = 1;
  var w = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function M(S) {
    var D = !1;
    return function() {
      if (!D) {
        D = !0;
        for (var F = arguments.length, z = new Array(F), Z = 0; Z < F; Z++)
          z[Z] = arguments[Z];
        S.apply(this, z);
      }
    };
  }
  function x() {
  }
  function $(S) {
    return S.setHeader && typeof S.abort == "function";
  }
  function T(S, D, F) {
    if (typeof D == "function") return T(S, null, D);
    D || (D = {}), F = M(F || x);
    var z = D.readable || D.readable !== !1 && S.readable, Z = D.writable || D.writable !== !1 && S.writable, H = function() {
      S.writable || X();
    }, V = S._writableState && S._writableState.finished, X = function() {
      Z = !1, V = !0, z || F.call(S);
    }, Q = S._readableState && S._readableState.endEmitted, fe = function() {
      z = !1, Q = !0, Z || F.call(S);
    }, ce = function(ge) {
      F.call(S, ge);
    }, me = function() {
      var ge;
      if (z && !Q)
        return (!S._readableState || !S._readableState.ended) && (ge = new w()), F.call(S, ge);
      if (Z && !V)
        return (!S._writableState || !S._writableState.ended) && (ge = new w()), F.call(S, ge);
    }, de = function() {
      S.req.on("finish", X);
    };
    return $(S) ? (S.on("complete", X), S.on("abort", me), S.req ? de() : S.on("request", de)) : Z && !S._writableState && (S.on("end", H), S.on("close", H)), S.on("end", fe), S.on("finish", X), D.error !== !1 && S.on("error", ce), S.on("close", me), function() {
      S.removeListener("complete", X), S.removeListener("abort", me), S.removeListener("request", de), S.req && S.req.removeListener("finish", X), S.removeListener("end", H), S.removeListener("close", H), S.removeListener("finish", X), S.removeListener("end", fe), S.removeListener("error", ce), S.removeListener("close", me);
    };
  }
  return endOfStream = T, endOfStream;
}
var async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator) return async_iterator;
  hasRequiredAsync_iterator = 1;
  var w;
  function M(ge, pe, $e) {
    return pe = x(pe), pe in ge ? Object.defineProperty(ge, pe, { value: $e, enumerable: !0, configurable: !0, writable: !0 }) : ge[pe] = $e, ge;
  }
  function x(ge) {
    var pe = $(ge, "string");
    return typeof pe == "symbol" ? pe : String(pe);
  }
  function $(ge, pe) {
    if (typeof ge != "object" || ge === null) return ge;
    var $e = ge[Symbol.toPrimitive];
    if ($e !== void 0) {
      var Re = $e.call(ge, pe);
      if (typeof Re != "object") return Re;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (pe === "string" ? String : Number)(ge);
  }
  var T = requireEndOfStream(), S = Symbol("lastResolve"), D = Symbol("lastReject"), F = Symbol("error"), z = Symbol("ended"), Z = Symbol("lastPromise"), H = Symbol("handlePromise"), V = Symbol("stream");
  function X(ge, pe) {
    return {
      value: ge,
      done: pe
    };
  }
  function Q(ge) {
    var pe = ge[S];
    if (pe !== null) {
      var $e = ge[V].read();
      $e !== null && (ge[Z] = null, ge[S] = null, ge[D] = null, pe(X($e, !1)));
    }
  }
  function fe(ge) {
    process$1.nextTick(Q, ge);
  }
  function ce(ge, pe) {
    return function($e, Re) {
      ge.then(function() {
        if (pe[z]) {
          $e(X(void 0, !0));
          return;
        }
        pe[H]($e, Re);
      }, Re);
    };
  }
  var me = Object.getPrototypeOf(function() {
  }), de = Object.setPrototypeOf((w = {
    get stream() {
      return this[V];
    },
    next: function() {
      var pe = this, $e = this[F];
      if ($e !== null)
        return Promise.reject($e);
      if (this[z])
        return Promise.resolve(X(void 0, !0));
      if (this[V].destroyed)
        return new Promise(function(xe, rt) {
          process$1.nextTick(function() {
            pe[F] ? rt(pe[F]) : xe(X(void 0, !0));
          });
        });
      var Re = this[Z], Pe;
      if (Re)
        Pe = new Promise(ce(Re, this));
      else {
        var Oe = this[V].read();
        if (Oe !== null)
          return Promise.resolve(X(Oe, !1));
        Pe = new Promise(this[H]);
      }
      return this[Z] = Pe, Pe;
    }
  }, M(w, Symbol.asyncIterator, function() {
    return this;
  }), M(w, "return", function() {
    var pe = this;
    return new Promise(function($e, Re) {
      pe[V].destroy(null, function(Pe) {
        if (Pe) {
          Re(Pe);
          return;
        }
        $e(X(void 0, !0));
      });
    });
  }), w), me), ne = function(pe) {
    var $e, Re = Object.create(de, ($e = {}, M($e, V, {
      value: pe,
      writable: !0
    }), M($e, S, {
      value: null,
      writable: !0
    }), M($e, D, {
      value: null,
      writable: !0
    }), M($e, F, {
      value: null,
      writable: !0
    }), M($e, z, {
      value: pe._readableState.endEmitted,
      writable: !0
    }), M($e, H, {
      value: function(Oe, xe) {
        var rt = Re[V].read();
        rt ? (Re[Z] = null, Re[S] = null, Re[D] = null, Oe(X(rt, !1))) : (Re[S] = Oe, Re[D] = xe);
      },
      writable: !0
    }), $e));
    return Re[Z] = null, T(pe, function(Pe) {
      if (Pe && Pe.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var Oe = Re[D];
        Oe !== null && (Re[Z] = null, Re[S] = null, Re[D] = null, Oe(Pe)), Re[F] = Pe;
        return;
      }
      var xe = Re[S];
      xe !== null && (Re[Z] = null, Re[S] = null, Re[D] = null, xe(X(void 0, !0))), Re[z] = !0;
    }), pe.on("readable", fe.bind(null, Re)), Re;
  };
  return async_iterator = ne, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable$1, hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1) return _stream_readable$1;
  hasRequired_stream_readable$1 = 1, _stream_readable$1 = xe;
  var w;
  xe.ReadableState = Oe, eventsExports.EventEmitter;
  var M = function(he, Me) {
    return he.listeners(Me).length;
  }, x = requireStreamBrowser(), $ = dist.Buffer, T = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function S(ve) {
    return $.from(ve);
  }
  function D(ve) {
    return $.isBuffer(ve) || ve instanceof T;
  }
  var F = util$3, z;
  F && F.debuglog ? z = F.debuglog("stream") : z = function() {
  };
  var Z = requireBuffer_list(), H = requireDestroy(), V = requireState(), X = V.getHighWaterMark, Q = requireErrorsBrowser().codes, fe = Q.ERR_INVALID_ARG_TYPE, ce = Q.ERR_STREAM_PUSH_AFTER_EOF, me = Q.ERR_METHOD_NOT_IMPLEMENTED, de = Q.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, ne, ge, pe;
  inherits_browserExports(xe, x);
  var $e = H.errorOrDestroy, Re = ["error", "close", "destroy", "pause", "resume"];
  function Pe(ve, he, Me) {
    if (typeof ve.prependListener == "function") return ve.prependListener(he, Me);
    !ve._events || !ve._events[he] ? ve.on(he, Me) : Array.isArray(ve._events[he]) ? ve._events[he].unshift(Me) : ve._events[he] = [Me, ve._events[he]];
  }
  function Oe(ve, he, Me) {
    w = w || require_stream_duplex$1(), ve = ve || {}, typeof Me != "boolean" && (Me = he instanceof w), this.objectMode = !!ve.objectMode, Me && (this.objectMode = this.objectMode || !!ve.readableObjectMode), this.highWaterMark = X(this, ve, "readableHighWaterMark", Me), this.buffer = new Z(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = ve.emitClose !== !1, this.autoDestroy = !!ve.autoDestroy, this.destroyed = !1, this.defaultEncoding = ve.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, ve.encoding && (ne || (ne = string_decoder.StringDecoder), this.decoder = new ne(ve.encoding), this.encoding = ve.encoding);
  }
  function xe(ve) {
    if (w = w || require_stream_duplex$1(), !(this instanceof xe)) return new xe(ve);
    var he = this instanceof w;
    this._readableState = new Oe(ve, this, he), this.readable = !0, ve && (typeof ve.read == "function" && (this._read = ve.read), typeof ve.destroy == "function" && (this._destroy = ve.destroy)), x.call(this);
  }
  Object.defineProperty(xe.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(he) {
      this._readableState && (this._readableState.destroyed = he);
    }
  }), xe.prototype.destroy = H.destroy, xe.prototype._undestroy = H.undestroy, xe.prototype._destroy = function(ve, he) {
    he(ve);
  }, xe.prototype.push = function(ve, he) {
    var Me = this._readableState, Qe;
    return Me.objectMode ? Qe = !0 : typeof ve == "string" && (he = he || Me.defaultEncoding, he !== Me.encoding && (ve = $.from(ve, he), he = ""), Qe = !0), rt(this, ve, he, !1, Qe);
  }, xe.prototype.unshift = function(ve) {
    return rt(this, ve, null, !0, !1);
  };
  function rt(ve, he, Me, Qe, Ie) {
    z("readableAddChunk", he);
    var De = ve._readableState;
    if (he === null)
      De.reading = !1, O(ve, De);
    else {
      var at;
      if (Ie || (at = y(De, he)), at)
        $e(ve, at);
      else if (De.objectMode || he && he.length > 0)
        if (typeof he != "string" && !De.objectMode && Object.getPrototypeOf(he) !== $.prototype && (he = S(he)), Qe)
          De.endEmitted ? $e(ve, new de()) : N(ve, De, he, !0);
        else if (De.ended)
          $e(ve, new ce());
        else {
          if (De.destroyed)
            return !1;
          De.reading = !1, De.decoder && !Me ? (he = De.decoder.write(he), De.objectMode || he.length !== 0 ? N(ve, De, he, !1) : P(ve, De)) : N(ve, De, he, !1);
        }
      else Qe || (De.reading = !1, P(ve, De));
    }
    return !De.ended && (De.length < De.highWaterMark || De.length === 0);
  }
  function N(ve, he, Me, Qe) {
    he.flowing && he.length === 0 && !he.sync ? (he.awaitDrain = 0, ve.emit("data", Me)) : (he.length += he.objectMode ? 1 : Me.length, Qe ? he.buffer.unshift(Me) : he.buffer.push(Me), he.needReadable && C(ve)), P(ve, he);
  }
  function y(ve, he) {
    var Me;
    return !D(he) && typeof he != "string" && he !== void 0 && !ve.objectMode && (Me = new fe("chunk", ["string", "Buffer", "Uint8Array"], he)), Me;
  }
  xe.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, xe.prototype.setEncoding = function(ve) {
    ne || (ne = string_decoder.StringDecoder);
    var he = new ne(ve);
    this._readableState.decoder = he, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var Me = this._readableState.buffer.head, Qe = ""; Me !== null; )
      Qe += he.write(Me.data), Me = Me.next;
    return this._readableState.buffer.clear(), Qe !== "" && this._readableState.buffer.push(Qe), this._readableState.length = Qe.length, this;
  };
  var E = 1073741824;
  function A(ve) {
    return ve >= E ? ve = E : (ve--, ve |= ve >>> 1, ve |= ve >>> 2, ve |= ve >>> 4, ve |= ve >>> 8, ve |= ve >>> 16, ve++), ve;
  }
  function B(ve, he) {
    return ve <= 0 || he.length === 0 && he.ended ? 0 : he.objectMode ? 1 : ve !== ve ? he.flowing && he.length ? he.buffer.head.data.length : he.length : (ve > he.highWaterMark && (he.highWaterMark = A(ve)), ve <= he.length ? ve : he.ended ? he.length : (he.needReadable = !0, 0));
  }
  xe.prototype.read = function(ve) {
    z("read", ve), ve = parseInt(ve, 10);
    var he = this._readableState, Me = ve;
    if (ve !== 0 && (he.emittedReadable = !1), ve === 0 && he.needReadable && ((he.highWaterMark !== 0 ? he.length >= he.highWaterMark : he.length > 0) || he.ended))
      return z("read: emitReadable", he.length, he.ended), he.length === 0 && he.ended ? ae(this) : C(this), null;
    if (ve = B(ve, he), ve === 0 && he.ended)
      return he.length === 0 && ae(this), null;
    var Qe = he.needReadable;
    z("need readable", Qe), (he.length === 0 || he.length - ve < he.highWaterMark) && (Qe = !0, z("length less than watermark", Qe)), he.ended || he.reading ? (Qe = !1, z("reading or ended", Qe)) : Qe && (z("do read"), he.reading = !0, he.sync = !0, he.length === 0 && (he.needReadable = !0), this._read(he.highWaterMark), he.sync = !1, he.reading || (ve = B(Me, he)));
    var Ie;
    return ve > 0 ? Ie = ee(ve, he) : Ie = null, Ie === null ? (he.needReadable = he.length <= he.highWaterMark, ve = 0) : (he.length -= ve, he.awaitDrain = 0), he.length === 0 && (he.ended || (he.needReadable = !0), Me !== ve && he.ended && ae(this)), Ie !== null && this.emit("data", Ie), Ie;
  };
  function O(ve, he) {
    if (z("onEofChunk"), !he.ended) {
      if (he.decoder) {
        var Me = he.decoder.end();
        Me && Me.length && (he.buffer.push(Me), he.length += he.objectMode ? 1 : Me.length);
      }
      he.ended = !0, he.sync ? C(ve) : (he.needReadable = !1, he.emittedReadable || (he.emittedReadable = !0, L(ve)));
    }
  }
  function C(ve) {
    var he = ve._readableState;
    z("emitReadable", he.needReadable, he.emittedReadable), he.needReadable = !1, he.emittedReadable || (z("emitReadable", he.flowing), he.emittedReadable = !0, process$1.nextTick(L, ve));
  }
  function L(ve) {
    var he = ve._readableState;
    z("emitReadable_", he.destroyed, he.length, he.ended), !he.destroyed && (he.length || he.ended) && (ve.emit("readable"), he.emittedReadable = !1), he.needReadable = !he.flowing && !he.ended && he.length <= he.highWaterMark, re(ve);
  }
  function P(ve, he) {
    he.readingMore || (he.readingMore = !0, process$1.nextTick(_, ve, he));
  }
  function _(ve, he) {
    for (; !he.reading && !he.ended && (he.length < he.highWaterMark || he.flowing && he.length === 0); ) {
      var Me = he.length;
      if (z("maybeReadMore read 0"), ve.read(0), Me === he.length)
        break;
    }
    he.readingMore = !1;
  }
  xe.prototype._read = function(ve) {
    $e(this, new me("_read()"));
  }, xe.prototype.pipe = function(ve, he) {
    var Me = this, Qe = this._readableState;
    switch (Qe.pipesCount) {
      case 0:
        Qe.pipes = ve;
        break;
      case 1:
        Qe.pipes = [Qe.pipes, ve];
        break;
      default:
        Qe.pipes.push(ve);
        break;
    }
    Qe.pipesCount += 1, z("pipe count=%d opts=%j", Qe.pipesCount, he);
    var Ie = (!he || he.end !== !1) && ve !== process$1.stdout && ve !== process$1.stderr, De = Ie ? ke : it;
    Qe.endEmitted ? process$1.nextTick(De) : Me.once("end", De), ve.on("unpipe", at);
    function at(Ae, Be) {
      z("onunpipe"), Ae === Me && Be && Be.hasUnpiped === !1 && (Be.hasUnpiped = !0, qe());
    }
    function ke() {
      z("onend"), ve.end();
    }
    var Se = I(Me);
    ve.on("drain", Se);
    var lt = !1;
    function qe() {
      z("cleanup"), ve.removeListener("close", be), ve.removeListener("finish", _e), ve.removeListener("drain", Se), ve.removeListener("error", ot), ve.removeListener("unpipe", at), Me.removeListener("end", ke), Me.removeListener("end", it), Me.removeListener("data", He), lt = !0, Qe.awaitDrain && (!ve._writableState || ve._writableState.needDrain) && Se();
    }
    Me.on("data", He);
    function He(Ae) {
      z("ondata");
      var Be = ve.write(Ae);
      z("dest.write", Be), Be === !1 && ((Qe.pipesCount === 1 && Qe.pipes === ve || Qe.pipesCount > 1 && ye(Qe.pipes, ve) !== -1) && !lt && (z("false write response, pause", Qe.awaitDrain), Qe.awaitDrain++), Me.pause());
    }
    function ot(Ae) {
      z("onerror", Ae), it(), ve.removeListener("error", ot), M(ve, "error") === 0 && $e(ve, Ae);
    }
    Pe(ve, "error", ot);
    function be() {
      ve.removeListener("finish", _e), it();
    }
    ve.once("close", be);
    function _e() {
      z("onfinish"), ve.removeListener("close", be), it();
    }
    ve.once("finish", _e);
    function it() {
      z("unpipe"), Me.unpipe(ve);
    }
    return ve.emit("pipe", Me), Qe.flowing || (z("pipe resume"), Me.resume()), ve;
  };
  function I(ve) {
    return function() {
      var Me = ve._readableState;
      z("pipeOnDrain", Me.awaitDrain), Me.awaitDrain && Me.awaitDrain--, Me.awaitDrain === 0 && M(ve, "data") && (Me.flowing = !0, re(ve));
    };
  }
  xe.prototype.unpipe = function(ve) {
    var he = this._readableState, Me = {
      hasUnpiped: !1
    };
    if (he.pipesCount === 0) return this;
    if (he.pipesCount === 1)
      return ve && ve !== he.pipes ? this : (ve || (ve = he.pipes), he.pipes = null, he.pipesCount = 0, he.flowing = !1, ve && ve.emit("unpipe", this, Me), this);
    if (!ve) {
      var Qe = he.pipes, Ie = he.pipesCount;
      he.pipes = null, he.pipesCount = 0, he.flowing = !1;
      for (var De = 0; De < Ie; De++) Qe[De].emit("unpipe", this, {
        hasUnpiped: !1
      });
      return this;
    }
    var at = ye(he.pipes, ve);
    return at === -1 ? this : (he.pipes.splice(at, 1), he.pipesCount -= 1, he.pipesCount === 1 && (he.pipes = he.pipes[0]), ve.emit("unpipe", this, Me), this);
  }, xe.prototype.on = function(ve, he) {
    var Me = x.prototype.on.call(this, ve, he), Qe = this._readableState;
    return ve === "data" ? (Qe.readableListening = this.listenerCount("readable") > 0, Qe.flowing !== !1 && this.resume()) : ve === "readable" && !Qe.endEmitted && !Qe.readableListening && (Qe.readableListening = Qe.needReadable = !0, Qe.flowing = !1, Qe.emittedReadable = !1, z("on readable", Qe.length, Qe.reading), Qe.length ? C(this) : Qe.reading || process$1.nextTick(Y, this)), Me;
  }, xe.prototype.addListener = xe.prototype.on, xe.prototype.removeListener = function(ve, he) {
    var Me = x.prototype.removeListener.call(this, ve, he);
    return ve === "readable" && process$1.nextTick(U, this), Me;
  }, xe.prototype.removeAllListeners = function(ve) {
    var he = x.prototype.removeAllListeners.apply(this, arguments);
    return (ve === "readable" || ve === void 0) && process$1.nextTick(U, this), he;
  };
  function U(ve) {
    var he = ve._readableState;
    he.readableListening = ve.listenerCount("readable") > 0, he.resumeScheduled && !he.paused ? he.flowing = !0 : ve.listenerCount("data") > 0 && ve.resume();
  }
  function Y(ve) {
    z("readable nexttick read 0"), ve.read(0);
  }
  xe.prototype.resume = function() {
    var ve = this._readableState;
    return ve.flowing || (z("resume"), ve.flowing = !ve.readableListening, te(this, ve)), ve.paused = !1, this;
  };
  function te(ve, he) {
    he.resumeScheduled || (he.resumeScheduled = !0, process$1.nextTick(oe, ve, he));
  }
  function oe(ve, he) {
    z("resume", he.reading), he.reading || ve.read(0), he.resumeScheduled = !1, ve.emit("resume"), re(ve), he.flowing && !he.reading && ve.read(0);
  }
  xe.prototype.pause = function() {
    return z("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (z("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function re(ve) {
    var he = ve._readableState;
    for (z("flow", he.flowing); he.flowing && ve.read() !== null; ) ;
  }
  xe.prototype.wrap = function(ve) {
    var he = this, Me = this._readableState, Qe = !1;
    ve.on("end", function() {
      if (z("wrapped end"), Me.decoder && !Me.ended) {
        var at = Me.decoder.end();
        at && at.length && he.push(at);
      }
      he.push(null);
    }), ve.on("data", function(at) {
      if (z("wrapped data"), Me.decoder && (at = Me.decoder.write(at)), !(Me.objectMode && at == null) && !(!Me.objectMode && (!at || !at.length))) {
        var ke = he.push(at);
        ke || (Qe = !0, ve.pause());
      }
    });
    for (var Ie in ve)
      this[Ie] === void 0 && typeof ve[Ie] == "function" && (this[Ie] = /* @__PURE__ */ function(ke) {
        return function() {
          return ve[ke].apply(ve, arguments);
        };
      }(Ie));
    for (var De = 0; De < Re.length; De++)
      ve.on(Re[De], this.emit.bind(this, Re[De]));
    return this._read = function(at) {
      z("wrapped _read", at), Qe && (Qe = !1, ve.resume());
    }, this;
  }, typeof Symbol == "function" && (xe.prototype[Symbol.asyncIterator] = function() {
    return ge === void 0 && (ge = requireAsync_iterator()), ge(this);
  }), Object.defineProperty(xe.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(xe.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(xe.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(he) {
      this._readableState && (this._readableState.flowing = he);
    }
  }), xe._fromList = ee, Object.defineProperty(xe.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function ee(ve, he) {
    if (he.length === 0) return null;
    var Me;
    return he.objectMode ? Me = he.buffer.shift() : !ve || ve >= he.length ? (he.decoder ? Me = he.buffer.join("") : he.buffer.length === 1 ? Me = he.buffer.first() : Me = he.buffer.concat(he.length), he.buffer.clear()) : Me = he.buffer.consume(ve, he.decoder), Me;
  }
  function ae(ve) {
    var he = ve._readableState;
    z("endReadable", he.endEmitted), he.endEmitted || (he.ended = !0, process$1.nextTick(ue, he, ve));
  }
  function ue(ve, he) {
    if (z("endReadableNT", ve.endEmitted, ve.length), !ve.endEmitted && ve.length === 0 && (ve.endEmitted = !0, he.readable = !1, he.emit("end"), ve.autoDestroy)) {
      var Me = he._writableState;
      (!Me || Me.autoDestroy && Me.finished) && he.destroy();
    }
  }
  typeof Symbol == "function" && (xe.from = function(ve, he) {
    return pe === void 0 && (pe = requireFromBrowser()), pe(xe, ve, he);
  });
  function ye(ve, he) {
    for (var Me = 0, Qe = ve.length; Me < Qe; Me++)
      if (ve[Me] === he) return Me;
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1, hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform) return _stream_transform$1;
  hasRequired_stream_transform = 1, _stream_transform$1 = F;
  var w = requireErrorsBrowser().codes, M = w.ERR_METHOD_NOT_IMPLEMENTED, x = w.ERR_MULTIPLE_CALLBACK, $ = w.ERR_TRANSFORM_ALREADY_TRANSFORMING, T = w.ERR_TRANSFORM_WITH_LENGTH_0, S = require_stream_duplex$1();
  inherits_browserExports(F, S);
  function D(H, V) {
    var X = this._transformState;
    X.transforming = !1;
    var Q = X.writecb;
    if (Q === null)
      return this.emit("error", new x());
    X.writechunk = null, X.writecb = null, V != null && this.push(V), Q(H);
    var fe = this._readableState;
    fe.reading = !1, (fe.needReadable || fe.length < fe.highWaterMark) && this._read(fe.highWaterMark);
  }
  function F(H) {
    if (!(this instanceof F)) return new F(H);
    S.call(this, H), this._transformState = {
      afterTransform: D.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, H && (typeof H.transform == "function" && (this._transform = H.transform), typeof H.flush == "function" && (this._flush = H.flush)), this.on("prefinish", z);
  }
  function z() {
    var H = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(V, X) {
      Z(H, V, X);
    }) : Z(this, null, null);
  }
  F.prototype.push = function(H, V) {
    return this._transformState.needTransform = !1, S.prototype.push.call(this, H, V);
  }, F.prototype._transform = function(H, V, X) {
    X(new M("_transform()"));
  }, F.prototype._write = function(H, V, X) {
    var Q = this._transformState;
    if (Q.writecb = X, Q.writechunk = H, Q.writeencoding = V, !Q.transforming) {
      var fe = this._readableState;
      (Q.needTransform || fe.needReadable || fe.length < fe.highWaterMark) && this._read(fe.highWaterMark);
    }
  }, F.prototype._read = function(H) {
    var V = this._transformState;
    V.writechunk !== null && !V.transforming ? (V.transforming = !0, this._transform(V.writechunk, V.writeencoding, V.afterTransform)) : V.needTransform = !0;
  }, F.prototype._destroy = function(H, V) {
    S.prototype._destroy.call(this, H, function(X) {
      V(X);
    });
  };
  function Z(H, V, X) {
    if (V) return H.emit("error", V);
    if (X != null && H.push(X), H._writableState.length) throw new T();
    if (H._transformState.transforming) throw new $();
    return H.push(null);
  }
  return _stream_transform$1;
}
var _stream_passthrough$1, hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough) return _stream_passthrough$1;
  hasRequired_stream_passthrough = 1, _stream_passthrough$1 = M;
  var w = require_stream_transform();
  inherits_browserExports(M, w);
  function M(x) {
    if (!(this instanceof M)) return new M(x);
    w.call(this, x);
  }
  return M.prototype._transform = function(x, $, T) {
    T(null, x);
  }, _stream_passthrough$1;
}
var pipeline_1, hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline) return pipeline_1;
  hasRequiredPipeline = 1;
  var w;
  function M(X) {
    var Q = !1;
    return function() {
      Q || (Q = !0, X.apply(void 0, arguments));
    };
  }
  var x = requireErrorsBrowser().codes, $ = x.ERR_MISSING_ARGS, T = x.ERR_STREAM_DESTROYED;
  function S(X) {
    if (X) throw X;
  }
  function D(X) {
    return X.setHeader && typeof X.abort == "function";
  }
  function F(X, Q, fe, ce) {
    ce = M(ce);
    var me = !1;
    X.on("close", function() {
      me = !0;
    }), w === void 0 && (w = requireEndOfStream()), w(X, {
      readable: Q,
      writable: fe
    }, function(ne) {
      if (ne) return ce(ne);
      me = !0, ce();
    });
    var de = !1;
    return function(ne) {
      if (!me && !de) {
        if (de = !0, D(X)) return X.abort();
        if (typeof X.destroy == "function") return X.destroy();
        ce(ne || new T("pipe"));
      }
    };
  }
  function z(X) {
    X();
  }
  function Z(X, Q) {
    return X.pipe(Q);
  }
  function H(X) {
    return !X.length || typeof X[X.length - 1] != "function" ? S : X.pop();
  }
  function V() {
    for (var X = arguments.length, Q = new Array(X), fe = 0; fe < X; fe++)
      Q[fe] = arguments[fe];
    var ce = H(Q);
    if (Array.isArray(Q[0]) && (Q = Q[0]), Q.length < 2)
      throw new $("streams");
    var me, de = Q.map(function(ne, ge) {
      var pe = ge < Q.length - 1, $e = ge > 0;
      return F(ne, pe, $e, function(Re) {
        me || (me = Re), Re && de.forEach(z), !pe && (de.forEach(z), ce(me));
      });
    });
    return Q.reduce(Z);
  }
  return pipeline_1 = V, pipeline_1;
}
var streamBrowserify = Stream, EE = eventsExports.EventEmitter, inherits$s = inherits_browserExports;
inherits$s(Stream, EE);
Stream.Readable = require_stream_readable$1();
Stream.Writable = require_stream_writable$1();
Stream.Duplex = require_stream_duplex$1();
Stream.Transform = require_stream_transform();
Stream.PassThrough = require_stream_passthrough();
Stream.finished = requireEndOfStream();
Stream.pipeline = requirePipeline();
Stream.Stream = Stream;
function Stream() {
  EE.call(this);
}
Stream.prototype.pipe = function(w, M) {
  var x = this;
  function $(H) {
    w.writable && w.write(H) === !1 && x.pause && x.pause();
  }
  x.on("data", $);
  function T() {
    x.readable && x.resume && x.resume();
  }
  w.on("drain", T), !w._isStdio && (!M || M.end !== !1) && (x.on("end", D), x.on("close", F));
  var S = !1;
  function D() {
    S || (S = !0, w.end());
  }
  function F() {
    S || (S = !0, typeof w.destroy == "function" && w.destroy());
  }
  function z(H) {
    if (Z(), EE.listenerCount(this, "error") === 0)
      throw H;
  }
  x.on("error", z), w.on("error", z);
  function Z() {
    x.removeListener("data", $), w.removeListener("drain", T), x.removeListener("end", D), x.removeListener("close", F), x.removeListener("error", z), w.removeListener("error", z), x.removeListener("end", Z), x.removeListener("close", Z), w.removeListener("close", Z);
  }
  return x.on("end", Z), x.on("close", Z), w.on("close", Z), w.emit("pipe", x), w;
};
var Buffer$A = safeBufferExports$2.Buffer, Transform$8 = streamBrowserify.Transform, inherits$r = inherits_browserExports;
function HashBase$4(w) {
  Transform$8.call(this), this._block = Buffer$A.allocUnsafe(w), this._blockSize = w, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
}
inherits$r(HashBase$4, Transform$8);
HashBase$4.prototype._transform = function(w, M, x) {
  var $ = null;
  try {
    this.update(w, M);
  } catch (T) {
    $ = T;
  }
  x($);
};
HashBase$4.prototype._flush = function(w) {
  var M = null;
  try {
    this.push(this.digest());
  } catch (x) {
    M = x;
  }
  w(M);
};
var useUint8Array$3 = typeof Uint8Array < "u", useArrayBuffer$3 = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && ArrayBuffer.isView && (Buffer$A.prototype instanceof Uint8Array || Buffer$A.TYPED_ARRAY_SUPPORT);
function toBuffer$6(w, M) {
  if (w instanceof Buffer$A) return w;
  if (typeof w == "string") return Buffer$A.from(w, M);
  if (useArrayBuffer$3 && ArrayBuffer.isView(w)) {
    if (w.byteLength === 0) return Buffer$A.alloc(0);
    var x = Buffer$A.from(w.buffer, w.byteOffset, w.byteLength);
    if (x.byteLength === w.byteLength) return x;
  }
  if (useUint8Array$3 && w instanceof Uint8Array || Buffer$A.isBuffer(w) && w.constructor && typeof w.constructor.isBuffer == "function" && w.constructor.isBuffer(w))
    return Buffer$A.from(w);
  throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
}
HashBase$4.prototype.update = function(w, M) {
  if (this._finalized) throw new Error("Digest already called");
  w = toBuffer$6(w, M);
  for (var x = this._block, $ = 0; this._blockOffset + w.length - $ >= this._blockSize; ) {
    for (var T = this._blockOffset; T < this._blockSize; ) x[T++] = w[$++];
    this._update(), this._blockOffset = 0;
  }
  for (; $ < w.length; ) x[this._blockOffset++] = w[$++];
  for (var S = 0, D = w.length * 8; D > 0; ++S)
    this._length[S] += D, D = this._length[S] / 4294967296 | 0, D > 0 && (this._length[S] -= 4294967296 * D);
  return this;
};
HashBase$4.prototype._update = function() {
  throw new Error("_update is not implemented");
};
HashBase$4.prototype.digest = function(w) {
  if (this._finalized) throw new Error("Digest already called");
  this._finalized = !0;
  var M = this._digest();
  w !== void 0 && (M = M.toString(w)), this._block.fill(0), this._blockOffset = 0;
  for (var x = 0; x < 4; ++x) this._length[x] = 0;
  return M;
};
HashBase$4.prototype._digest = function() {
  throw new Error("_digest is not implemented");
};
var hashBase$1 = HashBase$4, inherits$q = inherits_browserExports, HashBase$3 = hashBase$1, Buffer$z = safeBufferExports$2.Buffer, ARRAY16$1 = new Array(16);
function MD5$3() {
  HashBase$3.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
}
inherits$q(MD5$3, HashBase$3);
MD5$3.prototype._update = function() {
  for (var w = ARRAY16$1, M = 0; M < 16; ++M) w[M] = this._block.readInt32LE(M * 4);
  var x = this._a, $ = this._b, T = this._c, S = this._d;
  x = fnF(x, $, T, S, w[0], 3614090360, 7), S = fnF(S, x, $, T, w[1], 3905402710, 12), T = fnF(T, S, x, $, w[2], 606105819, 17), $ = fnF($, T, S, x, w[3], 3250441966, 22), x = fnF(x, $, T, S, w[4], 4118548399, 7), S = fnF(S, x, $, T, w[5], 1200080426, 12), T = fnF(T, S, x, $, w[6], 2821735955, 17), $ = fnF($, T, S, x, w[7], 4249261313, 22), x = fnF(x, $, T, S, w[8], 1770035416, 7), S = fnF(S, x, $, T, w[9], 2336552879, 12), T = fnF(T, S, x, $, w[10], 4294925233, 17), $ = fnF($, T, S, x, w[11], 2304563134, 22), x = fnF(x, $, T, S, w[12], 1804603682, 7), S = fnF(S, x, $, T, w[13], 4254626195, 12), T = fnF(T, S, x, $, w[14], 2792965006, 17), $ = fnF($, T, S, x, w[15], 1236535329, 22), x = fnG(x, $, T, S, w[1], 4129170786, 5), S = fnG(S, x, $, T, w[6], 3225465664, 9), T = fnG(T, S, x, $, w[11], 643717713, 14), $ = fnG($, T, S, x, w[0], 3921069994, 20), x = fnG(x, $, T, S, w[5], 3593408605, 5), S = fnG(S, x, $, T, w[10], 38016083, 9), T = fnG(T, S, x, $, w[15], 3634488961, 14), $ = fnG($, T, S, x, w[4], 3889429448, 20), x = fnG(x, $, T, S, w[9], 568446438, 5), S = fnG(S, x, $, T, w[14], 3275163606, 9), T = fnG(T, S, x, $, w[3], 4107603335, 14), $ = fnG($, T, S, x, w[8], 1163531501, 20), x = fnG(x, $, T, S, w[13], 2850285829, 5), S = fnG(S, x, $, T, w[2], 4243563512, 9), T = fnG(T, S, x, $, w[7], 1735328473, 14), $ = fnG($, T, S, x, w[12], 2368359562, 20), x = fnH(x, $, T, S, w[5], 4294588738, 4), S = fnH(S, x, $, T, w[8], 2272392833, 11), T = fnH(T, S, x, $, w[11], 1839030562, 16), $ = fnH($, T, S, x, w[14], 4259657740, 23), x = fnH(x, $, T, S, w[1], 2763975236, 4), S = fnH(S, x, $, T, w[4], 1272893353, 11), T = fnH(T, S, x, $, w[7], 4139469664, 16), $ = fnH($, T, S, x, w[10], 3200236656, 23), x = fnH(x, $, T, S, w[13], 681279174, 4), S = fnH(S, x, $, T, w[0], 3936430074, 11), T = fnH(T, S, x, $, w[3], 3572445317, 16), $ = fnH($, T, S, x, w[6], 76029189, 23), x = fnH(x, $, T, S, w[9], 3654602809, 4), S = fnH(S, x, $, T, w[12], 3873151461, 11), T = fnH(T, S, x, $, w[15], 530742520, 16), $ = fnH($, T, S, x, w[2], 3299628645, 23), x = fnI(x, $, T, S, w[0], 4096336452, 6), S = fnI(S, x, $, T, w[7], 1126891415, 10), T = fnI(T, S, x, $, w[14], 2878612391, 15), $ = fnI($, T, S, x, w[5], 4237533241, 21), x = fnI(x, $, T, S, w[12], 1700485571, 6), S = fnI(S, x, $, T, w[3], 2399980690, 10), T = fnI(T, S, x, $, w[10], 4293915773, 15), $ = fnI($, T, S, x, w[1], 2240044497, 21), x = fnI(x, $, T, S, w[8], 1873313359, 6), S = fnI(S, x, $, T, w[15], 4264355552, 10), T = fnI(T, S, x, $, w[6], 2734768916, 15), $ = fnI($, T, S, x, w[13], 1309151649, 21), x = fnI(x, $, T, S, w[4], 4149444226, 6), S = fnI(S, x, $, T, w[11], 3174756917, 10), T = fnI(T, S, x, $, w[2], 718787259, 15), $ = fnI($, T, S, x, w[9], 3951481745, 21), this._a = this._a + x | 0, this._b = this._b + $ | 0, this._c = this._c + T | 0, this._d = this._d + S | 0;
};
MD5$3.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var w = Buffer$z.allocUnsafe(16);
  return w.writeInt32LE(this._a, 0), w.writeInt32LE(this._b, 4), w.writeInt32LE(this._c, 8), w.writeInt32LE(this._d, 12), w;
};
function rotl$2(w, M) {
  return w << M | w >>> 32 - M;
}
function fnF(w, M, x, $, T, S, D) {
  return rotl$2(w + (M & x | ~M & $) + T + S | 0, D) + M | 0;
}
function fnG(w, M, x, $, T, S, D) {
  return rotl$2(w + (M & $ | x & ~$) + T + S | 0, D) + M | 0;
}
function fnH(w, M, x, $, T, S, D) {
  return rotl$2(w + (M ^ x ^ $) + T + S | 0, D) + M | 0;
}
function fnI(w, M, x, $, T, S, D) {
  return rotl$2(w + (x ^ (M | ~$)) + T + S | 0, D) + M | 0;
}
var md5_js = MD5$3, Buffer$y = dist.Buffer, inherits$p = inherits_browserExports, HashBase$2 = hashBase$1, ARRAY16 = new Array(16), zl = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], zr = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], sl = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sr = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], hl = [0, 1518500249, 1859775393, 2400959708, 2840853838], hr = [1352829926, 1548603684, 1836072691, 2053994217, 0];
function RIPEMD160$5() {
  HashBase$2.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
}
inherits$p(RIPEMD160$5, HashBase$2);
RIPEMD160$5.prototype._update = function() {
  for (var w = ARRAY16, M = 0; M < 16; ++M) w[M] = this._block.readInt32LE(M * 4);
  for (var x = this._a | 0, $ = this._b | 0, T = this._c | 0, S = this._d | 0, D = this._e | 0, F = this._a | 0, z = this._b | 0, Z = this._c | 0, H = this._d | 0, V = this._e | 0, X = 0; X < 80; X += 1) {
    var Q, fe;
    X < 16 ? (Q = fn1$1(x, $, T, S, D, w[zl[X]], hl[0], sl[X]), fe = fn5$1(F, z, Z, H, V, w[zr[X]], hr[0], sr[X])) : X < 32 ? (Q = fn2$1(x, $, T, S, D, w[zl[X]], hl[1], sl[X]), fe = fn4$1(F, z, Z, H, V, w[zr[X]], hr[1], sr[X])) : X < 48 ? (Q = fn3$1(x, $, T, S, D, w[zl[X]], hl[2], sl[X]), fe = fn3$1(F, z, Z, H, V, w[zr[X]], hr[2], sr[X])) : X < 64 ? (Q = fn4$1(x, $, T, S, D, w[zl[X]], hl[3], sl[X]), fe = fn2$1(F, z, Z, H, V, w[zr[X]], hr[3], sr[X])) : (Q = fn5$1(x, $, T, S, D, w[zl[X]], hl[4], sl[X]), fe = fn1$1(F, z, Z, H, V, w[zr[X]], hr[4], sr[X])), x = D, D = S, S = rotl$1(T, 10), T = $, $ = Q, F = V, V = H, H = rotl$1(Z, 10), Z = z, z = fe;
  }
  var ce = this._b + T + H | 0;
  this._b = this._c + S + V | 0, this._c = this._d + D + F | 0, this._d = this._e + x + z | 0, this._e = this._a + $ + Z | 0, this._a = ce;
};
RIPEMD160$5.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var w = Buffer$y.alloc ? Buffer$y.alloc(20) : new Buffer$y(20);
  return w.writeInt32LE(this._a, 0), w.writeInt32LE(this._b, 4), w.writeInt32LE(this._c, 8), w.writeInt32LE(this._d, 12), w.writeInt32LE(this._e, 16), w;
};
function rotl$1(w, M) {
  return w << M | w >>> 32 - M;
}
function fn1$1(w, M, x, $, T, S, D, F) {
  return rotl$1(w + (M ^ x ^ $) + S + D | 0, F) + T | 0;
}
function fn2$1(w, M, x, $, T, S, D, F) {
  return rotl$1(w + (M & x | ~M & $) + S + D | 0, F) + T | 0;
}
function fn3$1(w, M, x, $, T, S, D, F) {
  return rotl$1(w + ((M | ~x) ^ $) + S + D | 0, F) + T | 0;
}
function fn4$1(w, M, x, $, T, S, D, F) {
  return rotl$1(w + (M & $ | x & ~$) + S + D | 0, F) + T | 0;
}
function fn5$1(w, M, x, $, T, S, D, F) {
  return rotl$1(w + (M ^ (x | ~$)) + S + D | 0, F) + T | 0;
}
var ripemd160$1 = RIPEMD160$5, sha_js = { exports: {} }, toString$1 = {}.toString, isarray$1 = Array.isArray || function(w) {
  return toString$1.call(w) == "[object Array]";
}, $TypeError = type, callBound = callBound$8, $typedArrayBuffer = callBound("TypedArray.prototype.buffer", !0), isTypedArray = isTypedArray$1, typedArrayBuffer$1 = $typedArrayBuffer || function(M) {
  if (!isTypedArray(M))
    throw new $TypeError("Not a Typed Array");
  return M.buffer;
}, Buffer$x = safeBufferExports$2.Buffer, isArray$1 = isarray$1, typedArrayBuffer = typedArrayBuffer$1, isView$1 = ArrayBuffer.isView || function(M) {
  try {
    return typedArrayBuffer(M), !0;
  } catch {
    return !1;
  }
}, useUint8Array$2 = typeof Uint8Array < "u", useArrayBuffer$2 = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", useFromArrayBuffer = useArrayBuffer$2 && (Buffer$x.prototype instanceof Uint8Array || Buffer$x.TYPED_ARRAY_SUPPORT), toBuffer$5 = function(M, x) {
  if (M instanceof Buffer$x)
    return M;
  if (typeof M == "string")
    return Buffer$x.from(M, x);
  if (useArrayBuffer$2 && isView$1(M)) {
    if (M.byteLength === 0)
      return Buffer$x.alloc(0);
    if (useFromArrayBuffer) {
      var $ = Buffer$x.from(M.buffer, M.byteOffset, M.byteLength);
      if ($.byteLength === M.byteLength)
        return $;
    }
    var T = M instanceof Uint8Array ? M : new Uint8Array(M.buffer, M.byteOffset, M.byteLength), S = Buffer$x.from(T);
    if (S.length === M.byteLength)
      return S;
  }
  if (useUint8Array$2 && M instanceof Uint8Array)
    return Buffer$x.from(M);
  var D = isArray$1(M);
  if (D)
    for (var F = 0; F < M.length; F += 1) {
      var z = M[F];
      if (typeof z != "number" || z < 0 || z > 255 || ~~z !== z)
        throw new RangeError("Array items must be numbers in the range 0-255.");
    }
  if (D || Buffer$x.isBuffer(M) && M.constructor && typeof M.constructor.isBuffer == "function" && M.constructor.isBuffer(M))
    return Buffer$x.from(M);
  throw new TypeError('The "data" argument must be a string, an Array, a Buffer, a Uint8Array, or a DataView.');
}, Buffer$w = safeBufferExports$2.Buffer, toBuffer$4 = toBuffer$5;
function Hash$7(w, M) {
  this._block = Buffer$w.alloc(w), this._finalSize = M, this._blockSize = w, this._len = 0;
}
Hash$7.prototype.update = function(w, M) {
  w = toBuffer$4(w, M || "utf8");
  for (var x = this._block, $ = this._blockSize, T = w.length, S = this._len, D = 0; D < T; ) {
    for (var F = S % $, z = Math.min(T - D, $ - F), Z = 0; Z < z; Z++)
      x[F + Z] = w[D + Z];
    S += z, D += z, S % $ === 0 && this._update(x);
  }
  return this._len += T, this;
};
Hash$7.prototype.digest = function(w) {
  var M = this._len % this._blockSize;
  this._block[M] = 128, this._block.fill(0, M + 1), M >= this._finalSize && (this._update(this._block), this._block.fill(0));
  var x = this._len * 8;
  if (x <= 4294967295)
    this._block.writeUInt32BE(x, this._blockSize - 4);
  else {
    var $ = (x & 4294967295) >>> 0, T = (x - $) / 4294967296;
    this._block.writeUInt32BE(T, this._blockSize - 8), this._block.writeUInt32BE($, this._blockSize - 4);
  }
  this._update(this._block);
  var S = this._hash();
  return w ? S.toString(w) : S;
};
Hash$7.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var hash$4 = Hash$7, inherits$o = inherits_browserExports, Hash$6 = hash$4, Buffer$v = safeBufferExports$2.Buffer, K$4 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], W$5 = new Array(80);
function Sha() {
  this.init(), this._w = W$5, Hash$6.call(this, 64, 56);
}
inherits$o(Sha, Hash$6);
Sha.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function rotl5$1(w) {
  return w << 5 | w >>> 27;
}
function rotl30$1(w) {
  return w << 30 | w >>> 2;
}
function ft$1(w, M, x, $) {
  return w === 0 ? M & x | ~M & $ : w === 2 ? M & x | M & $ | x & $ : M ^ x ^ $;
}
Sha.prototype._update = function(w) {
  for (var M = this._w, x = this._a | 0, $ = this._b | 0, T = this._c | 0, S = this._d | 0, D = this._e | 0, F = 0; F < 16; ++F)
    M[F] = w.readInt32BE(F * 4);
  for (; F < 80; ++F)
    M[F] = M[F - 3] ^ M[F - 8] ^ M[F - 14] ^ M[F - 16];
  for (var z = 0; z < 80; ++z) {
    var Z = ~~(z / 20), H = rotl5$1(x) + ft$1(Z, $, T, S) + D + M[z] + K$4[Z] | 0;
    D = S, S = T, T = rotl30$1($), $ = x, x = H;
  }
  this._a = x + this._a | 0, this._b = $ + this._b | 0, this._c = T + this._c | 0, this._d = S + this._d | 0, this._e = D + this._e | 0;
};
Sha.prototype._hash = function() {
  var w = Buffer$v.allocUnsafe(20);
  return w.writeInt32BE(this._a | 0, 0), w.writeInt32BE(this._b | 0, 4), w.writeInt32BE(this._c | 0, 8), w.writeInt32BE(this._d | 0, 12), w.writeInt32BE(this._e | 0, 16), w;
};
var sha$4 = Sha, inherits$n = inherits_browserExports, Hash$5 = hash$4, Buffer$u = safeBufferExports$2.Buffer, K$3 = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], W$4 = new Array(80);
function Sha1() {
  this.init(), this._w = W$4, Hash$5.call(this, 64, 56);
}
inherits$n(Sha1, Hash$5);
Sha1.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function rotl1(w) {
  return w << 1 | w >>> 31;
}
function rotl5(w) {
  return w << 5 | w >>> 27;
}
function rotl30(w) {
  return w << 30 | w >>> 2;
}
function ft(w, M, x, $) {
  return w === 0 ? M & x | ~M & $ : w === 2 ? M & x | M & $ | x & $ : M ^ x ^ $;
}
Sha1.prototype._update = function(w) {
  for (var M = this._w, x = this._a | 0, $ = this._b | 0, T = this._c | 0, S = this._d | 0, D = this._e | 0, F = 0; F < 16; ++F)
    M[F] = w.readInt32BE(F * 4);
  for (; F < 80; ++F)
    M[F] = rotl1(M[F - 3] ^ M[F - 8] ^ M[F - 14] ^ M[F - 16]);
  for (var z = 0; z < 80; ++z) {
    var Z = ~~(z / 20), H = rotl5(x) + ft(Z, $, T, S) + D + M[z] + K$3[Z] | 0;
    D = S, S = T, T = rotl30($), $ = x, x = H;
  }
  this._a = x + this._a | 0, this._b = $ + this._b | 0, this._c = T + this._c | 0, this._d = S + this._d | 0, this._e = D + this._e | 0;
};
Sha1.prototype._hash = function() {
  var w = Buffer$u.allocUnsafe(20);
  return w.writeInt32BE(this._a | 0, 0), w.writeInt32BE(this._b | 0, 4), w.writeInt32BE(this._c | 0, 8), w.writeInt32BE(this._d | 0, 12), w.writeInt32BE(this._e | 0, 16), w;
};
var sha1 = Sha1, inherits$m = inherits_browserExports, Hash$4 = hash$4, Buffer$t = safeBufferExports$2.Buffer, K$2 = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
], W$3 = new Array(64);
function Sha256$1() {
  this.init(), this._w = W$3, Hash$4.call(this, 64, 56);
}
inherits$m(Sha256$1, Hash$4);
Sha256$1.prototype.init = function() {
  return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
};
function ch(w, M, x) {
  return x ^ w & (M ^ x);
}
function maj$1(w, M, x) {
  return w & M | x & (w | M);
}
function sigma0$1(w) {
  return (w >>> 2 | w << 30) ^ (w >>> 13 | w << 19) ^ (w >>> 22 | w << 10);
}
function sigma1$1(w) {
  return (w >>> 6 | w << 26) ^ (w >>> 11 | w << 21) ^ (w >>> 25 | w << 7);
}
function gamma0(w) {
  return (w >>> 7 | w << 25) ^ (w >>> 18 | w << 14) ^ w >>> 3;
}
function gamma1(w) {
  return (w >>> 17 | w << 15) ^ (w >>> 19 | w << 13) ^ w >>> 10;
}
Sha256$1.prototype._update = function(w) {
  for (var M = this._w, x = this._a | 0, $ = this._b | 0, T = this._c | 0, S = this._d | 0, D = this._e | 0, F = this._f | 0, z = this._g | 0, Z = this._h | 0, H = 0; H < 16; ++H)
    M[H] = w.readInt32BE(H * 4);
  for (; H < 64; ++H)
    M[H] = gamma1(M[H - 2]) + M[H - 7] + gamma0(M[H - 15]) + M[H - 16] | 0;
  for (var V = 0; V < 64; ++V) {
    var X = Z + sigma1$1(D) + ch(D, F, z) + K$2[V] + M[V] | 0, Q = sigma0$1(x) + maj$1(x, $, T) | 0;
    Z = z, z = F, F = D, D = S + X | 0, S = T, T = $, $ = x, x = X + Q | 0;
  }
  this._a = x + this._a | 0, this._b = $ + this._b | 0, this._c = T + this._c | 0, this._d = S + this._d | 0, this._e = D + this._e | 0, this._f = F + this._f | 0, this._g = z + this._g | 0, this._h = Z + this._h | 0;
};
Sha256$1.prototype._hash = function() {
  var w = Buffer$t.allocUnsafe(32);
  return w.writeInt32BE(this._a, 0), w.writeInt32BE(this._b, 4), w.writeInt32BE(this._c, 8), w.writeInt32BE(this._d, 12), w.writeInt32BE(this._e, 16), w.writeInt32BE(this._f, 20), w.writeInt32BE(this._g, 24), w.writeInt32BE(this._h, 28), w;
};
var sha256$1 = Sha256$1, inherits$l = inherits_browserExports, Sha256 = sha256$1, Hash$3 = hash$4, Buffer$s = safeBufferExports$2.Buffer, W$2 = new Array(64);
function Sha224() {
  this.init(), this._w = W$2, Hash$3.call(this, 64, 56);
}
inherits$l(Sha224, Sha256);
Sha224.prototype.init = function() {
  return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
};
Sha224.prototype._hash = function() {
  var w = Buffer$s.allocUnsafe(28);
  return w.writeInt32BE(this._a, 0), w.writeInt32BE(this._b, 4), w.writeInt32BE(this._c, 8), w.writeInt32BE(this._d, 12), w.writeInt32BE(this._e, 16), w.writeInt32BE(this._f, 20), w.writeInt32BE(this._g, 24), w;
};
var sha224$1 = Sha224, inherits$k = inherits_browserExports, Hash$2 = hash$4, Buffer$r = safeBufferExports$2.Buffer, K$1 = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
], W$1 = new Array(160);
function Sha512() {
  this.init(), this._w = W$1, Hash$2.call(this, 128, 112);
}
inherits$k(Sha512, Hash$2);
Sha512.prototype.init = function() {
  return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
};
function Ch(w, M, x) {
  return x ^ w & (M ^ x);
}
function maj(w, M, x) {
  return w & M | x & (w | M);
}
function sigma0(w, M) {
  return (w >>> 28 | M << 4) ^ (M >>> 2 | w << 30) ^ (M >>> 7 | w << 25);
}
function sigma1(w, M) {
  return (w >>> 14 | M << 18) ^ (w >>> 18 | M << 14) ^ (M >>> 9 | w << 23);
}
function Gamma0(w, M) {
  return (w >>> 1 | M << 31) ^ (w >>> 8 | M << 24) ^ w >>> 7;
}
function Gamma0l(w, M) {
  return (w >>> 1 | M << 31) ^ (w >>> 8 | M << 24) ^ (w >>> 7 | M << 25);
}
function Gamma1(w, M) {
  return (w >>> 19 | M << 13) ^ (M >>> 29 | w << 3) ^ w >>> 6;
}
function Gamma1l(w, M) {
  return (w >>> 19 | M << 13) ^ (M >>> 29 | w << 3) ^ (w >>> 6 | M << 26);
}
function getCarry(w, M) {
  return w >>> 0 < M >>> 0 ? 1 : 0;
}
Sha512.prototype._update = function(w) {
  for (var M = this._w, x = this._ah | 0, $ = this._bh | 0, T = this._ch | 0, S = this._dh | 0, D = this._eh | 0, F = this._fh | 0, z = this._gh | 0, Z = this._hh | 0, H = this._al | 0, V = this._bl | 0, X = this._cl | 0, Q = this._dl | 0, fe = this._el | 0, ce = this._fl | 0, me = this._gl | 0, de = this._hl | 0, ne = 0; ne < 32; ne += 2)
    M[ne] = w.readInt32BE(ne * 4), M[ne + 1] = w.readInt32BE(ne * 4 + 4);
  for (; ne < 160; ne += 2) {
    var ge = M[ne - 30], pe = M[ne - 15 * 2 + 1], $e = Gamma0(ge, pe), Re = Gamma0l(pe, ge);
    ge = M[ne - 2 * 2], pe = M[ne - 2 * 2 + 1];
    var Pe = Gamma1(ge, pe), Oe = Gamma1l(pe, ge), xe = M[ne - 7 * 2], rt = M[ne - 7 * 2 + 1], N = M[ne - 16 * 2], y = M[ne - 16 * 2 + 1], E = Re + rt | 0, A = $e + xe + getCarry(E, Re) | 0;
    E = E + Oe | 0, A = A + Pe + getCarry(E, Oe) | 0, E = E + y | 0, A = A + N + getCarry(E, y) | 0, M[ne] = A, M[ne + 1] = E;
  }
  for (var B = 0; B < 160; B += 2) {
    A = M[B], E = M[B + 1];
    var O = maj(x, $, T), C = maj(H, V, X), L = sigma0(x, H), P = sigma0(H, x), _ = sigma1(D, fe), I = sigma1(fe, D), U = K$1[B], Y = K$1[B + 1], te = Ch(D, F, z), oe = Ch(fe, ce, me), re = de + I | 0, ee = Z + _ + getCarry(re, de) | 0;
    re = re + oe | 0, ee = ee + te + getCarry(re, oe) | 0, re = re + Y | 0, ee = ee + U + getCarry(re, Y) | 0, re = re + E | 0, ee = ee + A + getCarry(re, E) | 0;
    var ae = P + C | 0, ue = L + O + getCarry(ae, P) | 0;
    Z = z, de = me, z = F, me = ce, F = D, ce = fe, fe = Q + re | 0, D = S + ee + getCarry(fe, Q) | 0, S = T, Q = X, T = $, X = V, $ = x, V = H, H = re + ae | 0, x = ee + ue + getCarry(H, re) | 0;
  }
  this._al = this._al + H | 0, this._bl = this._bl + V | 0, this._cl = this._cl + X | 0, this._dl = this._dl + Q | 0, this._el = this._el + fe | 0, this._fl = this._fl + ce | 0, this._gl = this._gl + me | 0, this._hl = this._hl + de | 0, this._ah = this._ah + x + getCarry(this._al, H) | 0, this._bh = this._bh + $ + getCarry(this._bl, V) | 0, this._ch = this._ch + T + getCarry(this._cl, X) | 0, this._dh = this._dh + S + getCarry(this._dl, Q) | 0, this._eh = this._eh + D + getCarry(this._el, fe) | 0, this._fh = this._fh + F + getCarry(this._fl, ce) | 0, this._gh = this._gh + z + getCarry(this._gl, me) | 0, this._hh = this._hh + Z + getCarry(this._hl, de) | 0;
};
Sha512.prototype._hash = function() {
  var w = Buffer$r.allocUnsafe(64);
  function M(x, $, T) {
    w.writeInt32BE(x, T), w.writeInt32BE($, T + 4);
  }
  return M(this._ah, this._al, 0), M(this._bh, this._bl, 8), M(this._ch, this._cl, 16), M(this._dh, this._dl, 24), M(this._eh, this._el, 32), M(this._fh, this._fl, 40), M(this._gh, this._gl, 48), M(this._hh, this._hl, 56), w;
};
var sha512$1 = Sha512, inherits$j = inherits_browserExports, SHA512$2 = sha512$1, Hash$1 = hash$4, Buffer$q = safeBufferExports$2.Buffer, W = new Array(160);
function Sha384() {
  this.init(), this._w = W, Hash$1.call(this, 128, 112);
}
inherits$j(Sha384, SHA512$2);
Sha384.prototype.init = function() {
  return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
};
Sha384.prototype._hash = function() {
  var w = Buffer$q.allocUnsafe(48);
  function M(x, $, T) {
    w.writeInt32BE(x, T), w.writeInt32BE($, T + 4);
  }
  return M(this._ah, this._al, 0), M(this._bh, this._bl, 8), M(this._ch, this._cl, 16), M(this._dh, this._dl, 24), M(this._eh, this._el, 32), M(this._fh, this._fl, 40), w;
};
var sha384$1 = Sha384;
(function(w) {
  w.exports = function(x) {
    var $ = x.toLowerCase(), T = w.exports[$];
    if (!T)
      throw new Error($ + " is not supported (we accept pull requests)");
    return new T();
  }, w.exports.sha = sha$4, w.exports.sha1 = sha1, w.exports.sha224 = sha224$1, w.exports.sha256 = sha256$1, w.exports.sha384 = sha384$1, w.exports.sha512 = sha512$1;
})(sha_js);
var sha_jsExports = sha_js.exports, Buffer$p = safeBufferExports$2.Buffer, Transform$7 = streamBrowserify.Transform, StringDecoder = string_decoder.StringDecoder, inherits$i = inherits_browserExports;
function CipherBase$1(w) {
  Transform$7.call(this), this.hashMode = typeof w == "string", this.hashMode ? this[w] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
}
inherits$i(CipherBase$1, Transform$7);
var useUint8Array$1 = typeof Uint8Array < "u", useArrayBuffer$1 = typeof ArrayBuffer < "u" && typeof Uint8Array < "u" && ArrayBuffer.isView && (Buffer$p.prototype instanceof Uint8Array || Buffer$p.TYPED_ARRAY_SUPPORT);
function toBuffer$3(w, M) {
  if (w instanceof Buffer$p)
    return w;
  if (typeof w == "string")
    return Buffer$p.from(w, M);
  if (useArrayBuffer$1 && ArrayBuffer.isView(w)) {
    if (w.byteLength === 0)
      return Buffer$p.alloc(0);
    var x = Buffer$p.from(w.buffer, w.byteOffset, w.byteLength);
    if (x.byteLength === w.byteLength)
      return x;
  }
  if (useUint8Array$1 && w instanceof Uint8Array || Buffer$p.isBuffer(w) && w.constructor && typeof w.constructor.isBuffer == "function" && w.constructor.isBuffer(w))
    return Buffer$p.from(w);
  throw new TypeError('The "data" argument must be of type string or an instance of Buffer, TypedArray, or DataView.');
}
CipherBase$1.prototype.update = function(w, M, x) {
  var $ = toBuffer$3(w, M), T = this._update($);
  return this.hashMode ? this : (x && (T = this._toString(T, x)), T);
};
CipherBase$1.prototype.setAutoPadding = function() {
};
CipherBase$1.prototype.getAuthTag = function() {
  throw new Error("trying to get auth tag in unsupported state");
};
CipherBase$1.prototype.setAuthTag = function() {
  throw new Error("trying to set auth tag in unsupported state");
};
CipherBase$1.prototype.setAAD = function() {
  throw new Error("trying to set aad in unsupported state");
};
CipherBase$1.prototype._transform = function(w, M, x) {
  var $;
  try {
    this.hashMode ? this._update(w) : this.push(this._update(w));
  } catch (T) {
    $ = T;
  } finally {
    x($);
  }
};
CipherBase$1.prototype._flush = function(w) {
  var M;
  try {
    this.push(this.__final());
  } catch (x) {
    M = x;
  }
  w(M);
};
CipherBase$1.prototype._finalOrDigest = function(w) {
  var M = this.__final() || Buffer$p.alloc(0);
  return w && (M = this._toString(M, w, !0)), M;
};
CipherBase$1.prototype._toString = function(w, M, x) {
  if (this._decoder || (this._decoder = new StringDecoder(M), this._encoding = M), this._encoding !== M)
    throw new Error("cant switch encodings");
  var $ = this._decoder.write(w);
  return x && ($ += this._decoder.end()), $;
};
var cipherBase = CipherBase$1, inherits$h = inherits_browserExports, MD5$2 = md5_js, RIPEMD160$4 = ripemd160$1, sha$3 = sha_jsExports, Base$5 = cipherBase;
function Hash(w) {
  Base$5.call(this, "digest"), this._hash = w;
}
inherits$h(Hash, Base$5);
Hash.prototype._update = function(w) {
  this._hash.update(w);
};
Hash.prototype._final = function() {
  return this._hash.digest();
};
var browser$9 = function(M) {
  return M = M.toLowerCase(), M === "md5" ? new MD5$2() : M === "rmd160" || M === "ripemd160" ? new RIPEMD160$4() : new Hash(sha$3(M));
}, inherits$g = inherits_browserExports, Buffer$o = safeBufferExports$2.Buffer, Base$4 = cipherBase, ZEROS$2 = Buffer$o.alloc(128), blocksize = 64;
function Hmac$3(w, M) {
  Base$4.call(this, "digest"), typeof M == "string" && (M = Buffer$o.from(M)), this._alg = w, this._key = M, M.length > blocksize ? M = w(M) : M.length < blocksize && (M = Buffer$o.concat([M, ZEROS$2], blocksize));
  for (var x = this._ipad = Buffer$o.allocUnsafe(blocksize), $ = this._opad = Buffer$o.allocUnsafe(blocksize), T = 0; T < blocksize; T++)
    x[T] = M[T] ^ 54, $[T] = M[T] ^ 92;
  this._hash = [x];
}
inherits$g(Hmac$3, Base$4);
Hmac$3.prototype._update = function(w) {
  this._hash.push(w);
};
Hmac$3.prototype._final = function() {
  var w = this._alg(Buffer$o.concat(this._hash));
  return this._alg(Buffer$o.concat([this._opad, w]));
};
var legacy = Hmac$3, MD5$1 = md5_js, md5$3 = function(w) {
  return new MD5$1().update(w).digest();
}, inherits$f = inherits_browserExports, Legacy = legacy, Base$3 = cipherBase, Buffer$n = safeBufferExports$2.Buffer, md5$2 = md5$3, RIPEMD160$3 = ripemd160$1, sha$2 = sha_jsExports, ZEROS$1 = Buffer$n.alloc(128);
function Hmac$2(w, M) {
  Base$3.call(this, "digest"), typeof M == "string" && (M = Buffer$n.from(M));
  var x = w === "sha512" || w === "sha384" ? 128 : 64;
  if (this._alg = w, this._key = M, M.length > x) {
    var $ = w === "rmd160" ? new RIPEMD160$3() : sha$2(w);
    M = $.update(M).digest();
  } else M.length < x && (M = Buffer$n.concat([M, ZEROS$1], x));
  for (var T = this._ipad = Buffer$n.allocUnsafe(x), S = this._opad = Buffer$n.allocUnsafe(x), D = 0; D < x; D++)
    T[D] = M[D] ^ 54, S[D] = M[D] ^ 92;
  this._hash = w === "rmd160" ? new RIPEMD160$3() : sha$2(w), this._hash.update(T);
}
inherits$f(Hmac$2, Base$3);
Hmac$2.prototype._update = function(w) {
  this._hash.update(w);
};
Hmac$2.prototype._final = function() {
  var w = this._hash.digest(), M = this._alg === "rmd160" ? new RIPEMD160$3() : sha$2(this._alg);
  return M.update(this._opad).update(w).digest();
};
var browser$8 = function(M, x) {
  return M = M.toLowerCase(), M === "rmd160" || M === "ripemd160" ? new Hmac$2("rmd160", x) : M === "md5" ? new Legacy(md5$2, x) : new Hmac$2(M, x);
};
const sha224WithRSAEncryption = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, sha256WithRSAEncryption = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, sha384WithRSAEncryption = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, sha512WithRSAEncryption = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, sha256 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, sha224 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, sha384 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, sha512 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, DSA = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, ripemd160WithRSA = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, md5WithRSAEncryption = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256,
  sha224,
  sha384,
  sha512,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var algos = require$$6, browser$7 = {}, MAX_ALLOC = Math.pow(2, 30) - 1, precondition = function(w, M) {
  if (typeof w != "number")
    throw new TypeError("Iterations not a number");
  if (w < 0)
    throw new TypeError("Bad iterations");
  if (typeof M != "number")
    throw new TypeError("Key length not a number");
  if (M < 0 || M > MAX_ALLOC || M !== M)
    throw new TypeError("Bad key length");
}, defaultEncoding$2;
if (commonjsGlobal.process && commonjsGlobal.process.browser)
  defaultEncoding$2 = "utf-8";
else if (commonjsGlobal.process && commonjsGlobal.process.version) {
  var pVersionMajor = parseInt(process$1.version.split(".")[0].slice(1), 10);
  defaultEncoding$2 = pVersionMajor >= 6 ? "utf-8" : "binary";
} else
  defaultEncoding$2 = "utf-8";
var defaultEncoding_1 = defaultEncoding$2, intSize = 4, zeroBuffer = new Buffer$D(intSize);
zeroBuffer.fill(0);
var charSize = 8, hashSize = 16;
function toArray$2(w) {
  if (w.length % intSize !== 0) {
    var M = w.length + (intSize - w.length % intSize);
    w = Buffer$D.concat([w, zeroBuffer], M);
  }
  for (var x = new Array(w.length >>> 2), $ = 0, T = 0; $ < w.length; $ += intSize, T++)
    x[T] = w.readInt32LE($);
  return x;
}
var makeHash$1 = function(M, x) {
  var $ = x(toArray$2(M), M.length * charSize);
  M = new Buffer$D(hashSize);
  for (var T = 0; T < $.length; T++)
    M.writeInt32LE($[T], T << 2, !0);
  return M;
}, makeHash = makeHash$1;
function core_md5(w, M) {
  w[M >> 5] |= 128 << M % 32, w[(M + 64 >>> 9 << 4) + 14] = M;
  for (var x = 1732584193, $ = -271733879, T = -1732584194, S = 271733878, D = 0; D < w.length; D += 16) {
    var F = x, z = $, Z = T, H = S;
    x = md5_ff(x, $, T, S, w[D + 0], 7, -680876936), S = md5_ff(S, x, $, T, w[D + 1], 12, -389564586), T = md5_ff(T, S, x, $, w[D + 2], 17, 606105819), $ = md5_ff($, T, S, x, w[D + 3], 22, -1044525330), x = md5_ff(x, $, T, S, w[D + 4], 7, -176418897), S = md5_ff(S, x, $, T, w[D + 5], 12, 1200080426), T = md5_ff(T, S, x, $, w[D + 6], 17, -1473231341), $ = md5_ff($, T, S, x, w[D + 7], 22, -45705983), x = md5_ff(x, $, T, S, w[D + 8], 7, 1770035416), S = md5_ff(S, x, $, T, w[D + 9], 12, -1958414417), T = md5_ff(T, S, x, $, w[D + 10], 17, -42063), $ = md5_ff($, T, S, x, w[D + 11], 22, -1990404162), x = md5_ff(x, $, T, S, w[D + 12], 7, 1804603682), S = md5_ff(S, x, $, T, w[D + 13], 12, -40341101), T = md5_ff(T, S, x, $, w[D + 14], 17, -1502002290), $ = md5_ff($, T, S, x, w[D + 15], 22, 1236535329), x = md5_gg(x, $, T, S, w[D + 1], 5, -165796510), S = md5_gg(S, x, $, T, w[D + 6], 9, -1069501632), T = md5_gg(T, S, x, $, w[D + 11], 14, 643717713), $ = md5_gg($, T, S, x, w[D + 0], 20, -373897302), x = md5_gg(x, $, T, S, w[D + 5], 5, -701558691), S = md5_gg(S, x, $, T, w[D + 10], 9, 38016083), T = md5_gg(T, S, x, $, w[D + 15], 14, -660478335), $ = md5_gg($, T, S, x, w[D + 4], 20, -405537848), x = md5_gg(x, $, T, S, w[D + 9], 5, 568446438), S = md5_gg(S, x, $, T, w[D + 14], 9, -1019803690), T = md5_gg(T, S, x, $, w[D + 3], 14, -187363961), $ = md5_gg($, T, S, x, w[D + 8], 20, 1163531501), x = md5_gg(x, $, T, S, w[D + 13], 5, -1444681467), S = md5_gg(S, x, $, T, w[D + 2], 9, -51403784), T = md5_gg(T, S, x, $, w[D + 7], 14, 1735328473), $ = md5_gg($, T, S, x, w[D + 12], 20, -1926607734), x = md5_hh(x, $, T, S, w[D + 5], 4, -378558), S = md5_hh(S, x, $, T, w[D + 8], 11, -2022574463), T = md5_hh(T, S, x, $, w[D + 11], 16, 1839030562), $ = md5_hh($, T, S, x, w[D + 14], 23, -35309556), x = md5_hh(x, $, T, S, w[D + 1], 4, -1530992060), S = md5_hh(S, x, $, T, w[D + 4], 11, 1272893353), T = md5_hh(T, S, x, $, w[D + 7], 16, -155497632), $ = md5_hh($, T, S, x, w[D + 10], 23, -1094730640), x = md5_hh(x, $, T, S, w[D + 13], 4, 681279174), S = md5_hh(S, x, $, T, w[D + 0], 11, -358537222), T = md5_hh(T, S, x, $, w[D + 3], 16, -722521979), $ = md5_hh($, T, S, x, w[D + 6], 23, 76029189), x = md5_hh(x, $, T, S, w[D + 9], 4, -640364487), S = md5_hh(S, x, $, T, w[D + 12], 11, -421815835), T = md5_hh(T, S, x, $, w[D + 15], 16, 530742520), $ = md5_hh($, T, S, x, w[D + 2], 23, -995338651), x = md5_ii(x, $, T, S, w[D + 0], 6, -198630844), S = md5_ii(S, x, $, T, w[D + 7], 10, 1126891415), T = md5_ii(T, S, x, $, w[D + 14], 15, -1416354905), $ = md5_ii($, T, S, x, w[D + 5], 21, -57434055), x = md5_ii(x, $, T, S, w[D + 12], 6, 1700485571), S = md5_ii(S, x, $, T, w[D + 3], 10, -1894986606), T = md5_ii(T, S, x, $, w[D + 10], 15, -1051523), $ = md5_ii($, T, S, x, w[D + 1], 21, -2054922799), x = md5_ii(x, $, T, S, w[D + 8], 6, 1873313359), S = md5_ii(S, x, $, T, w[D + 15], 10, -30611744), T = md5_ii(T, S, x, $, w[D + 6], 15, -1560198380), $ = md5_ii($, T, S, x, w[D + 13], 21, 1309151649), x = md5_ii(x, $, T, S, w[D + 4], 6, -145523070), S = md5_ii(S, x, $, T, w[D + 11], 10, -1120210379), T = md5_ii(T, S, x, $, w[D + 2], 15, 718787259), $ = md5_ii($, T, S, x, w[D + 9], 21, -343485551), x = safe_add(x, F), $ = safe_add($, z), T = safe_add(T, Z), S = safe_add(S, H);
  }
  return [x, $, T, S];
}
function md5_cmn(w, M, x, $, T, S) {
  return safe_add(bit_rol(safe_add(safe_add(M, w), safe_add($, S)), T), x);
}
function md5_ff(w, M, x, $, T, S, D) {
  return md5_cmn(M & x | ~M & $, w, M, T, S, D);
}
function md5_gg(w, M, x, $, T, S, D) {
  return md5_cmn(M & $ | x & ~$, w, M, T, S, D);
}
function md5_hh(w, M, x, $, T, S, D) {
  return md5_cmn(M ^ x ^ $, w, M, T, S, D);
}
function md5_ii(w, M, x, $, T, S, D) {
  return md5_cmn(x ^ (M | ~$), w, M, T, S, D);
}
function safe_add(w, M) {
  var x = (w & 65535) + (M & 65535), $ = (w >> 16) + (M >> 16) + (x >> 16);
  return $ << 16 | x & 65535;
}
function bit_rol(w, M) {
  return w << M | w >>> 32 - M;
}
var md5$1 = function(M) {
  return makeHash(M, core_md5);
}, Transform$6 = streamBrowserify.Transform, inherits$e = inherits_browserExports;
function HashBase$1(w) {
  Transform$6.call(this), this._block = new Buffer$D(w), this._blockSize = w, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
}
inherits$e(HashBase$1, Transform$6);
HashBase$1.prototype._transform = function(w, M, x) {
  var $ = null;
  try {
    M !== "buffer" && (w = new Buffer$D(w, M)), this.update(w);
  } catch (T) {
    $ = T;
  }
  x($);
};
HashBase$1.prototype._flush = function(w) {
  var M = null;
  try {
    this.push(this._digest());
  } catch (x) {
    M = x;
  }
  w(M);
};
HashBase$1.prototype.update = function(w, M) {
  if (!Buffer$D.isBuffer(w) && typeof w != "string") throw new TypeError("Data must be a string or a buffer");
  if (this._finalized) throw new Error("Digest already called");
  Buffer$D.isBuffer(w) || (w = new Buffer$D(w, M || "binary"));
  for (var x = this._block, $ = 0; this._blockOffset + w.length - $ >= this._blockSize; ) {
    for (var T = this._blockOffset; T < this._blockSize; ) x[T++] = w[$++];
    this._update(), this._blockOffset = 0;
  }
  for (; $ < w.length; ) x[this._blockOffset++] = w[$++];
  for (var S = 0, D = w.length * 8; D > 0; ++S)
    this._length[S] += D, D = this._length[S] / 4294967296 | 0, D > 0 && (this._length[S] -= 4294967296 * D);
  return this;
};
HashBase$1.prototype._update = function(w) {
  throw new Error("_update is not implemented");
};
HashBase$1.prototype.digest = function(w) {
  if (this._finalized) throw new Error("Digest already called");
  this._finalized = !0;
  var M = this._digest();
  return w !== void 0 && (M = M.toString(w)), M;
};
HashBase$1.prototype._digest = function() {
  throw new Error("_digest is not implemented");
};
var hashBase = HashBase$1, inherits$d = inherits_browserExports, HashBase = hashBase;
function RIPEMD160$2() {
  HashBase.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
}
inherits$d(RIPEMD160$2, HashBase);
RIPEMD160$2.prototype._update = function() {
  for (var w = new Array(16), M = 0; M < 16; ++M) w[M] = this._block.readInt32LE(M * 4);
  var x = this._a, $ = this._b, T = this._c, S = this._d, D = this._e;
  x = fn1(x, $, T, S, D, w[0], 0, 11), T = rotl(T, 10), D = fn1(D, x, $, T, S, w[1], 0, 14), $ = rotl($, 10), S = fn1(S, D, x, $, T, w[2], 0, 15), x = rotl(x, 10), T = fn1(T, S, D, x, $, w[3], 0, 12), D = rotl(D, 10), $ = fn1($, T, S, D, x, w[4], 0, 5), S = rotl(S, 10), x = fn1(x, $, T, S, D, w[5], 0, 8), T = rotl(T, 10), D = fn1(D, x, $, T, S, w[6], 0, 7), $ = rotl($, 10), S = fn1(S, D, x, $, T, w[7], 0, 9), x = rotl(x, 10), T = fn1(T, S, D, x, $, w[8], 0, 11), D = rotl(D, 10), $ = fn1($, T, S, D, x, w[9], 0, 13), S = rotl(S, 10), x = fn1(x, $, T, S, D, w[10], 0, 14), T = rotl(T, 10), D = fn1(D, x, $, T, S, w[11], 0, 15), $ = rotl($, 10), S = fn1(S, D, x, $, T, w[12], 0, 6), x = rotl(x, 10), T = fn1(T, S, D, x, $, w[13], 0, 7), D = rotl(D, 10), $ = fn1($, T, S, D, x, w[14], 0, 9), S = rotl(S, 10), x = fn1(x, $, T, S, D, w[15], 0, 8), T = rotl(T, 10), D = fn2(D, x, $, T, S, w[7], 1518500249, 7), $ = rotl($, 10), S = fn2(S, D, x, $, T, w[4], 1518500249, 6), x = rotl(x, 10), T = fn2(T, S, D, x, $, w[13], 1518500249, 8), D = rotl(D, 10), $ = fn2($, T, S, D, x, w[1], 1518500249, 13), S = rotl(S, 10), x = fn2(x, $, T, S, D, w[10], 1518500249, 11), T = rotl(T, 10), D = fn2(D, x, $, T, S, w[6], 1518500249, 9), $ = rotl($, 10), S = fn2(S, D, x, $, T, w[15], 1518500249, 7), x = rotl(x, 10), T = fn2(T, S, D, x, $, w[3], 1518500249, 15), D = rotl(D, 10), $ = fn2($, T, S, D, x, w[12], 1518500249, 7), S = rotl(S, 10), x = fn2(x, $, T, S, D, w[0], 1518500249, 12), T = rotl(T, 10), D = fn2(D, x, $, T, S, w[9], 1518500249, 15), $ = rotl($, 10), S = fn2(S, D, x, $, T, w[5], 1518500249, 9), x = rotl(x, 10), T = fn2(T, S, D, x, $, w[2], 1518500249, 11), D = rotl(D, 10), $ = fn2($, T, S, D, x, w[14], 1518500249, 7), S = rotl(S, 10), x = fn2(x, $, T, S, D, w[11], 1518500249, 13), T = rotl(T, 10), D = fn2(D, x, $, T, S, w[8], 1518500249, 12), $ = rotl($, 10), S = fn3(S, D, x, $, T, w[3], 1859775393, 11), x = rotl(x, 10), T = fn3(T, S, D, x, $, w[10], 1859775393, 13), D = rotl(D, 10), $ = fn3($, T, S, D, x, w[14], 1859775393, 6), S = rotl(S, 10), x = fn3(x, $, T, S, D, w[4], 1859775393, 7), T = rotl(T, 10), D = fn3(D, x, $, T, S, w[9], 1859775393, 14), $ = rotl($, 10), S = fn3(S, D, x, $, T, w[15], 1859775393, 9), x = rotl(x, 10), T = fn3(T, S, D, x, $, w[8], 1859775393, 13), D = rotl(D, 10), $ = fn3($, T, S, D, x, w[1], 1859775393, 15), S = rotl(S, 10), x = fn3(x, $, T, S, D, w[2], 1859775393, 14), T = rotl(T, 10), D = fn3(D, x, $, T, S, w[7], 1859775393, 8), $ = rotl($, 10), S = fn3(S, D, x, $, T, w[0], 1859775393, 13), x = rotl(x, 10), T = fn3(T, S, D, x, $, w[6], 1859775393, 6), D = rotl(D, 10), $ = fn3($, T, S, D, x, w[13], 1859775393, 5), S = rotl(S, 10), x = fn3(x, $, T, S, D, w[11], 1859775393, 12), T = rotl(T, 10), D = fn3(D, x, $, T, S, w[5], 1859775393, 7), $ = rotl($, 10), S = fn3(S, D, x, $, T, w[12], 1859775393, 5), x = rotl(x, 10), T = fn4(T, S, D, x, $, w[1], 2400959708, 11), D = rotl(D, 10), $ = fn4($, T, S, D, x, w[9], 2400959708, 12), S = rotl(S, 10), x = fn4(x, $, T, S, D, w[11], 2400959708, 14), T = rotl(T, 10), D = fn4(D, x, $, T, S, w[10], 2400959708, 15), $ = rotl($, 10), S = fn4(S, D, x, $, T, w[0], 2400959708, 14), x = rotl(x, 10), T = fn4(T, S, D, x, $, w[8], 2400959708, 15), D = rotl(D, 10), $ = fn4($, T, S, D, x, w[12], 2400959708, 9), S = rotl(S, 10), x = fn4(x, $, T, S, D, w[4], 2400959708, 8), T = rotl(T, 10), D = fn4(D, x, $, T, S, w[13], 2400959708, 9), $ = rotl($, 10), S = fn4(S, D, x, $, T, w[3], 2400959708, 14), x = rotl(x, 10), T = fn4(T, S, D, x, $, w[7], 2400959708, 5), D = rotl(D, 10), $ = fn4($, T, S, D, x, w[15], 2400959708, 6), S = rotl(S, 10), x = fn4(x, $, T, S, D, w[14], 2400959708, 8), T = rotl(T, 10), D = fn4(D, x, $, T, S, w[5], 2400959708, 6), $ = rotl($, 10), S = fn4(S, D, x, $, T, w[6], 2400959708, 5), x = rotl(x, 10), T = fn4(T, S, D, x, $, w[2], 2400959708, 12), D = rotl(D, 10), $ = fn5($, T, S, D, x, w[4], 2840853838, 9), S = rotl(S, 10), x = fn5(x, $, T, S, D, w[0], 2840853838, 15), T = rotl(T, 10), D = fn5(D, x, $, T, S, w[5], 2840853838, 5), $ = rotl($, 10), S = fn5(S, D, x, $, T, w[9], 2840853838, 11), x = rotl(x, 10), T = fn5(T, S, D, x, $, w[7], 2840853838, 6), D = rotl(D, 10), $ = fn5($, T, S, D, x, w[12], 2840853838, 8), S = rotl(S, 10), x = fn5(x, $, T, S, D, w[2], 2840853838, 13), T = rotl(T, 10), D = fn5(D, x, $, T, S, w[10], 2840853838, 12), $ = rotl($, 10), S = fn5(S, D, x, $, T, w[14], 2840853838, 5), x = rotl(x, 10), T = fn5(T, S, D, x, $, w[1], 2840853838, 12), D = rotl(D, 10), $ = fn5($, T, S, D, x, w[3], 2840853838, 13), S = rotl(S, 10), x = fn5(x, $, T, S, D, w[8], 2840853838, 14), T = rotl(T, 10), D = fn5(D, x, $, T, S, w[11], 2840853838, 11), $ = rotl($, 10), S = fn5(S, D, x, $, T, w[6], 2840853838, 8), x = rotl(x, 10), T = fn5(T, S, D, x, $, w[15], 2840853838, 5), D = rotl(D, 10), $ = fn5($, T, S, D, x, w[13], 2840853838, 6), S = rotl(S, 10);
  var F = this._a, z = this._b, Z = this._c, H = this._d, V = this._e;
  F = fn5(F, z, Z, H, V, w[5], 1352829926, 8), Z = rotl(Z, 10), V = fn5(V, F, z, Z, H, w[14], 1352829926, 9), z = rotl(z, 10), H = fn5(H, V, F, z, Z, w[7], 1352829926, 9), F = rotl(F, 10), Z = fn5(Z, H, V, F, z, w[0], 1352829926, 11), V = rotl(V, 10), z = fn5(z, Z, H, V, F, w[9], 1352829926, 13), H = rotl(H, 10), F = fn5(F, z, Z, H, V, w[2], 1352829926, 15), Z = rotl(Z, 10), V = fn5(V, F, z, Z, H, w[11], 1352829926, 15), z = rotl(z, 10), H = fn5(H, V, F, z, Z, w[4], 1352829926, 5), F = rotl(F, 10), Z = fn5(Z, H, V, F, z, w[13], 1352829926, 7), V = rotl(V, 10), z = fn5(z, Z, H, V, F, w[6], 1352829926, 7), H = rotl(H, 10), F = fn5(F, z, Z, H, V, w[15], 1352829926, 8), Z = rotl(Z, 10), V = fn5(V, F, z, Z, H, w[8], 1352829926, 11), z = rotl(z, 10), H = fn5(H, V, F, z, Z, w[1], 1352829926, 14), F = rotl(F, 10), Z = fn5(Z, H, V, F, z, w[10], 1352829926, 14), V = rotl(V, 10), z = fn5(z, Z, H, V, F, w[3], 1352829926, 12), H = rotl(H, 10), F = fn5(F, z, Z, H, V, w[12], 1352829926, 6), Z = rotl(Z, 10), V = fn4(V, F, z, Z, H, w[6], 1548603684, 9), z = rotl(z, 10), H = fn4(H, V, F, z, Z, w[11], 1548603684, 13), F = rotl(F, 10), Z = fn4(Z, H, V, F, z, w[3], 1548603684, 15), V = rotl(V, 10), z = fn4(z, Z, H, V, F, w[7], 1548603684, 7), H = rotl(H, 10), F = fn4(F, z, Z, H, V, w[0], 1548603684, 12), Z = rotl(Z, 10), V = fn4(V, F, z, Z, H, w[13], 1548603684, 8), z = rotl(z, 10), H = fn4(H, V, F, z, Z, w[5], 1548603684, 9), F = rotl(F, 10), Z = fn4(Z, H, V, F, z, w[10], 1548603684, 11), V = rotl(V, 10), z = fn4(z, Z, H, V, F, w[14], 1548603684, 7), H = rotl(H, 10), F = fn4(F, z, Z, H, V, w[15], 1548603684, 7), Z = rotl(Z, 10), V = fn4(V, F, z, Z, H, w[8], 1548603684, 12), z = rotl(z, 10), H = fn4(H, V, F, z, Z, w[12], 1548603684, 7), F = rotl(F, 10), Z = fn4(Z, H, V, F, z, w[4], 1548603684, 6), V = rotl(V, 10), z = fn4(z, Z, H, V, F, w[9], 1548603684, 15), H = rotl(H, 10), F = fn4(F, z, Z, H, V, w[1], 1548603684, 13), Z = rotl(Z, 10), V = fn4(V, F, z, Z, H, w[2], 1548603684, 11), z = rotl(z, 10), H = fn3(H, V, F, z, Z, w[15], 1836072691, 9), F = rotl(F, 10), Z = fn3(Z, H, V, F, z, w[5], 1836072691, 7), V = rotl(V, 10), z = fn3(z, Z, H, V, F, w[1], 1836072691, 15), H = rotl(H, 10), F = fn3(F, z, Z, H, V, w[3], 1836072691, 11), Z = rotl(Z, 10), V = fn3(V, F, z, Z, H, w[7], 1836072691, 8), z = rotl(z, 10), H = fn3(H, V, F, z, Z, w[14], 1836072691, 6), F = rotl(F, 10), Z = fn3(Z, H, V, F, z, w[6], 1836072691, 6), V = rotl(V, 10), z = fn3(z, Z, H, V, F, w[9], 1836072691, 14), H = rotl(H, 10), F = fn3(F, z, Z, H, V, w[11], 1836072691, 12), Z = rotl(Z, 10), V = fn3(V, F, z, Z, H, w[8], 1836072691, 13), z = rotl(z, 10), H = fn3(H, V, F, z, Z, w[12], 1836072691, 5), F = rotl(F, 10), Z = fn3(Z, H, V, F, z, w[2], 1836072691, 14), V = rotl(V, 10), z = fn3(z, Z, H, V, F, w[10], 1836072691, 13), H = rotl(H, 10), F = fn3(F, z, Z, H, V, w[0], 1836072691, 13), Z = rotl(Z, 10), V = fn3(V, F, z, Z, H, w[4], 1836072691, 7), z = rotl(z, 10), H = fn3(H, V, F, z, Z, w[13], 1836072691, 5), F = rotl(F, 10), Z = fn2(Z, H, V, F, z, w[8], 2053994217, 15), V = rotl(V, 10), z = fn2(z, Z, H, V, F, w[6], 2053994217, 5), H = rotl(H, 10), F = fn2(F, z, Z, H, V, w[4], 2053994217, 8), Z = rotl(Z, 10), V = fn2(V, F, z, Z, H, w[1], 2053994217, 11), z = rotl(z, 10), H = fn2(H, V, F, z, Z, w[3], 2053994217, 14), F = rotl(F, 10), Z = fn2(Z, H, V, F, z, w[11], 2053994217, 14), V = rotl(V, 10), z = fn2(z, Z, H, V, F, w[15], 2053994217, 6), H = rotl(H, 10), F = fn2(F, z, Z, H, V, w[0], 2053994217, 14), Z = rotl(Z, 10), V = fn2(V, F, z, Z, H, w[5], 2053994217, 6), z = rotl(z, 10), H = fn2(H, V, F, z, Z, w[12], 2053994217, 9), F = rotl(F, 10), Z = fn2(Z, H, V, F, z, w[2], 2053994217, 12), V = rotl(V, 10), z = fn2(z, Z, H, V, F, w[13], 2053994217, 9), H = rotl(H, 10), F = fn2(F, z, Z, H, V, w[9], 2053994217, 12), Z = rotl(Z, 10), V = fn2(V, F, z, Z, H, w[7], 2053994217, 5), z = rotl(z, 10), H = fn2(H, V, F, z, Z, w[10], 2053994217, 15), F = rotl(F, 10), Z = fn2(Z, H, V, F, z, w[14], 2053994217, 8), V = rotl(V, 10), z = fn1(z, Z, H, V, F, w[12], 0, 8), H = rotl(H, 10), F = fn1(F, z, Z, H, V, w[15], 0, 5), Z = rotl(Z, 10), V = fn1(V, F, z, Z, H, w[10], 0, 12), z = rotl(z, 10), H = fn1(H, V, F, z, Z, w[4], 0, 9), F = rotl(F, 10), Z = fn1(Z, H, V, F, z, w[1], 0, 12), V = rotl(V, 10), z = fn1(z, Z, H, V, F, w[5], 0, 5), H = rotl(H, 10), F = fn1(F, z, Z, H, V, w[8], 0, 14), Z = rotl(Z, 10), V = fn1(V, F, z, Z, H, w[7], 0, 6), z = rotl(z, 10), H = fn1(H, V, F, z, Z, w[6], 0, 8), F = rotl(F, 10), Z = fn1(Z, H, V, F, z, w[2], 0, 13), V = rotl(V, 10), z = fn1(z, Z, H, V, F, w[13], 0, 6), H = rotl(H, 10), F = fn1(F, z, Z, H, V, w[14], 0, 5), Z = rotl(Z, 10), V = fn1(V, F, z, Z, H, w[0], 0, 15), z = rotl(z, 10), H = fn1(H, V, F, z, Z, w[3], 0, 13), F = rotl(F, 10), Z = fn1(Z, H, V, F, z, w[9], 0, 11), V = rotl(V, 10), z = fn1(z, Z, H, V, F, w[11], 0, 11), H = rotl(H, 10);
  var X = this._b + T + H | 0;
  this._b = this._c + S + V | 0, this._c = this._d + D + F | 0, this._d = this._e + x + z | 0, this._e = this._a + $ + Z | 0, this._a = X;
};
RIPEMD160$2.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var w = new Buffer$D(20);
  return w.writeInt32LE(this._a, 0), w.writeInt32LE(this._b, 4), w.writeInt32LE(this._c, 8), w.writeInt32LE(this._d, 12), w.writeInt32LE(this._e, 16), w;
};
function rotl(w, M) {
  return w << M | w >>> 32 - M;
}
function fn1(w, M, x, $, T, S, D, F) {
  return rotl(w + (M ^ x ^ $) + S + D | 0, F) + T | 0;
}
function fn2(w, M, x, $, T, S, D, F) {
  return rotl(w + (M & x | ~M & $) + S + D | 0, F) + T | 0;
}
function fn3(w, M, x, $, T, S, D, F) {
  return rotl(w + ((M | ~x) ^ $) + S + D | 0, F) + T | 0;
}
function fn4(w, M, x, $, T, S, D, F) {
  return rotl(w + (M & $ | x & ~$) + S + D | 0, F) + T | 0;
}
function fn5(w, M, x, $, T, S, D, F) {
  return rotl(w + (M ^ (x | ~$)) + S + D | 0, F) + T | 0;
}
var ripemd160 = RIPEMD160$2, Buffer$m = safeBufferExports$2.Buffer, toBuffer$2 = toBuffer$5, useUint8Array = typeof Uint8Array < "u", useArrayBuffer = useUint8Array && typeof ArrayBuffer < "u", isView = useArrayBuffer && ArrayBuffer.isView, toBuffer_1 = function(w, M, x) {
  if (typeof w == "string" || Buffer$m.isBuffer(w) || useUint8Array && w instanceof Uint8Array || isView && isView(w))
    return toBuffer$2(w, M);
  throw new TypeError(x + " must be a string, a Buffer, a Uint8Array, or a DataView");
}, md5 = md5$1, RIPEMD160$1 = ripemd160, sha$1 = sha_jsExports, Buffer$l = safeBufferExports$2.Buffer, checkParameters$1 = precondition, defaultEncoding$1 = defaultEncoding_1, toBuffer$1 = toBuffer_1, ZEROS = Buffer$l.alloc(128), sizes = {
  __proto__: null,
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  "sha512-256": 32,
  ripemd160: 20,
  rmd160: 20
}, mapping = {
  __proto__: null,
  "sha-1": "sha1",
  "sha-224": "sha224",
  "sha-256": "sha256",
  "sha-384": "sha384",
  "sha-512": "sha512",
  "ripemd-160": "ripemd160"
};
function rmd160Func(w) {
  return new RIPEMD160$1().update(w).digest();
}
function getDigest(w) {
  function M(x) {
    return sha$1(w).update(x).digest();
  }
  return w === "rmd160" || w === "ripemd160" ? rmd160Func : w === "md5" ? md5 : M;
}
function Hmac$1(w, M, x) {
  var $ = getDigest(w), T = w === "sha512" || w === "sha384" ? 128 : 64;
  M.length > T ? M = $(M) : M.length < T && (M = Buffer$l.concat([M, ZEROS], T));
  for (var S = Buffer$l.allocUnsafe(T + sizes[w]), D = Buffer$l.allocUnsafe(T + sizes[w]), F = 0; F < T; F++)
    S[F] = M[F] ^ 54, D[F] = M[F] ^ 92;
  var z = Buffer$l.allocUnsafe(T + x + 4);
  S.copy(z, 0, 0, T), this.ipad1 = z, this.ipad2 = S, this.opad = D, this.alg = w, this.blocksize = T, this.hash = $, this.size = sizes[w];
}
Hmac$1.prototype.run = function(w, M) {
  w.copy(M, this.blocksize);
  var x = this.hash(M);
  return x.copy(this.opad, this.blocksize), this.hash(this.opad);
};
function pbkdf2(w, M, x, $, T) {
  checkParameters$1(x, $), w = toBuffer$1(w, defaultEncoding$1, "Password"), M = toBuffer$1(M, defaultEncoding$1, "Salt");
  var S = (T || "sha1").toLowerCase(), D = mapping[S] || S, F = sizes[D];
  if (typeof F != "number" || !F)
    throw new TypeError("Digest algorithm not supported: " + T);
  var z = new Hmac$1(D, w, M.length), Z = Buffer$l.allocUnsafe($), H = Buffer$l.allocUnsafe(M.length + 4);
  M.copy(H, 0, 0, M.length);
  for (var V = 0, X = F, Q = Math.ceil($ / X), fe = 1; fe <= Q; fe++) {
    H.writeUInt32BE(fe, M.length);
    for (var ce = z.run(H, z.ipad1), me = ce, de = 1; de < x; de++) {
      me = z.run(me, z.ipad2);
      for (var ne = 0; ne < X; ne++)
        ce[ne] ^= me[ne];
    }
    ce.copy(Z, V), V += X;
  }
  return Z;
}
var syncBrowser = pbkdf2, Buffer$k = safeBufferExports$2.Buffer, checkParameters = precondition, defaultEncoding = defaultEncoding_1, sync = syncBrowser, toBuffer = toBuffer_1, ZERO_BUF, subtle = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle, toBrowser = {
  sha: "SHA-1",
  "sha-1": "SHA-1",
  sha1: "SHA-1",
  sha256: "SHA-256",
  "sha-256": "SHA-256",
  sha384: "SHA-384",
  "sha-384": "SHA-384",
  "sha-512": "SHA-512",
  sha512: "SHA-512"
}, checks = [], nextTick$1;
function getNextTick() {
  return nextTick$1 || (commonjsGlobal.process && commonjsGlobal.process.nextTick ? nextTick$1 = commonjsGlobal.process.nextTick : commonjsGlobal.queueMicrotask ? nextTick$1 = commonjsGlobal.queueMicrotask : commonjsGlobal.setImmediate ? nextTick$1 = commonjsGlobal.setImmediate : nextTick$1 = commonjsGlobal.setTimeout, nextTick$1);
}
function browserPbkdf2(w, M, x, $, T) {
  return subtle.importKey("raw", w, { name: "PBKDF2" }, !1, ["deriveBits"]).then(function(S) {
    return subtle.deriveBits({
      name: "PBKDF2",
      salt: M,
      iterations: x,
      hash: {
        name: T
      }
    }, S, $ << 3);
  }).then(function(S) {
    return Buffer$k.from(S);
  });
}
function checkNative(w) {
  if (commonjsGlobal.process && !commonjsGlobal.process.browser || !subtle || !subtle.importKey || !subtle.deriveBits)
    return Promise.resolve(!1);
  if (checks[w] !== void 0)
    return checks[w];
  ZERO_BUF = ZERO_BUF || Buffer$k.alloc(8);
  var M = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, w).then(
    function() {
      return !0;
    },
    function() {
      return !1;
    }
  );
  return checks[w] = M, M;
}
function resolvePromise(w, M) {
  w.then(function(x) {
    getNextTick()(function() {
      M(null, x);
    });
  }, function(x) {
    getNextTick()(function() {
      M(x);
    });
  });
}
var async = function(w, M, x, $, T, S) {
  typeof T == "function" && (S = T, T = void 0), T = T || "sha1";
  var D = toBrowser[T.toLowerCase()];
  if (!D || typeof commonjsGlobal.Promise != "function") {
    getNextTick()(function() {
      var F;
      try {
        F = sync(w, M, x, $, T);
      } catch (z) {
        S(z);
        return;
      }
      S(null, F);
    });
    return;
  }
  if (checkParameters(x, $), w = toBuffer(w, defaultEncoding, "Password"), M = toBuffer(M, defaultEncoding, "Salt"), typeof S != "function")
    throw new Error("No callback provided to pbkdf2");
  resolvePromise(checkNative(D).then(function(F) {
    return F ? browserPbkdf2(w, M, x, $, D) : sync(w, M, x, $, T);
  }), S);
};
browser$7.pbkdf2 = async;
browser$7.pbkdf2Sync = syncBrowser;
var browser$6 = {}, des$2 = {}, utils$n = {};
utils$n.readUInt32BE = function(M, x) {
  var $ = M[0 + x] << 24 | M[1 + x] << 16 | M[2 + x] << 8 | M[3 + x];
  return $ >>> 0;
};
utils$n.writeUInt32BE = function(M, x, $) {
  M[0 + $] = x >>> 24, M[1 + $] = x >>> 16 & 255, M[2 + $] = x >>> 8 & 255, M[3 + $] = x & 255;
};
utils$n.ip = function(M, x, $, T) {
  for (var S = 0, D = 0, F = 6; F >= 0; F -= 2) {
    for (var z = 0; z <= 24; z += 8)
      S <<= 1, S |= x >>> z + F & 1;
    for (var z = 0; z <= 24; z += 8)
      S <<= 1, S |= M >>> z + F & 1;
  }
  for (var F = 6; F >= 0; F -= 2) {
    for (var z = 1; z <= 25; z += 8)
      D <<= 1, D |= x >>> z + F & 1;
    for (var z = 1; z <= 25; z += 8)
      D <<= 1, D |= M >>> z + F & 1;
  }
  $[T + 0] = S >>> 0, $[T + 1] = D >>> 0;
};
utils$n.rip = function(M, x, $, T) {
  for (var S = 0, D = 0, F = 0; F < 4; F++)
    for (var z = 24; z >= 0; z -= 8)
      S <<= 1, S |= x >>> z + F & 1, S <<= 1, S |= M >>> z + F & 1;
  for (var F = 4; F < 8; F++)
    for (var z = 24; z >= 0; z -= 8)
      D <<= 1, D |= x >>> z + F & 1, D <<= 1, D |= M >>> z + F & 1;
  $[T + 0] = S >>> 0, $[T + 1] = D >>> 0;
};
utils$n.pc1 = function(M, x, $, T) {
  for (var S = 0, D = 0, F = 7; F >= 5; F--) {
    for (var z = 0; z <= 24; z += 8)
      S <<= 1, S |= x >> z + F & 1;
    for (var z = 0; z <= 24; z += 8)
      S <<= 1, S |= M >> z + F & 1;
  }
  for (var z = 0; z <= 24; z += 8)
    S <<= 1, S |= x >> z + F & 1;
  for (var F = 1; F <= 3; F++) {
    for (var z = 0; z <= 24; z += 8)
      D <<= 1, D |= x >> z + F & 1;
    for (var z = 0; z <= 24; z += 8)
      D <<= 1, D |= M >> z + F & 1;
  }
  for (var z = 0; z <= 24; z += 8)
    D <<= 1, D |= M >> z + F & 1;
  $[T + 0] = S >>> 0, $[T + 1] = D >>> 0;
};
utils$n.r28shl = function(M, x) {
  return M << x & 268435455 | M >>> 28 - x;
};
var pc2table = [
  // inL => outL
  14,
  11,
  17,
  4,
  27,
  23,
  25,
  0,
  13,
  22,
  7,
  18,
  5,
  9,
  16,
  24,
  2,
  20,
  12,
  21,
  1,
  8,
  15,
  26,
  // inR => outR
  15,
  4,
  25,
  19,
  9,
  1,
  26,
  16,
  5,
  11,
  23,
  8,
  12,
  7,
  17,
  0,
  22,
  3,
  10,
  14,
  6,
  20,
  27,
  24
];
utils$n.pc2 = function(M, x, $, T) {
  for (var S = 0, D = 0, F = pc2table.length >>> 1, z = 0; z < F; z++)
    S <<= 1, S |= M >>> pc2table[z] & 1;
  for (var z = F; z < pc2table.length; z++)
    D <<= 1, D |= x >>> pc2table[z] & 1;
  $[T + 0] = S >>> 0, $[T + 1] = D >>> 0;
};
utils$n.expand = function(M, x, $) {
  var T = 0, S = 0;
  T = (M & 1) << 5 | M >>> 27;
  for (var D = 23; D >= 15; D -= 4)
    T <<= 6, T |= M >>> D & 63;
  for (var D = 11; D >= 3; D -= 4)
    S |= M >>> D & 63, S <<= 6;
  S |= (M & 31) << 1 | M >>> 31, x[$ + 0] = T >>> 0, x[$ + 1] = S >>> 0;
};
var sTable = [
  14,
  0,
  4,
  15,
  13,
  7,
  1,
  4,
  2,
  14,
  15,
  2,
  11,
  13,
  8,
  1,
  3,
  10,
  10,
  6,
  6,
  12,
  12,
  11,
  5,
  9,
  9,
  5,
  0,
  3,
  7,
  8,
  4,
  15,
  1,
  12,
  14,
  8,
  8,
  2,
  13,
  4,
  6,
  9,
  2,
  1,
  11,
  7,
  15,
  5,
  12,
  11,
  9,
  3,
  7,
  14,
  3,
  10,
  10,
  0,
  5,
  6,
  0,
  13,
  15,
  3,
  1,
  13,
  8,
  4,
  14,
  7,
  6,
  15,
  11,
  2,
  3,
  8,
  4,
  14,
  9,
  12,
  7,
  0,
  2,
  1,
  13,
  10,
  12,
  6,
  0,
  9,
  5,
  11,
  10,
  5,
  0,
  13,
  14,
  8,
  7,
  10,
  11,
  1,
  10,
  3,
  4,
  15,
  13,
  4,
  1,
  2,
  5,
  11,
  8,
  6,
  12,
  7,
  6,
  12,
  9,
  0,
  3,
  5,
  2,
  14,
  15,
  9,
  10,
  13,
  0,
  7,
  9,
  0,
  14,
  9,
  6,
  3,
  3,
  4,
  15,
  6,
  5,
  10,
  1,
  2,
  13,
  8,
  12,
  5,
  7,
  14,
  11,
  12,
  4,
  11,
  2,
  15,
  8,
  1,
  13,
  1,
  6,
  10,
  4,
  13,
  9,
  0,
  8,
  6,
  15,
  9,
  3,
  8,
  0,
  7,
  11,
  4,
  1,
  15,
  2,
  14,
  12,
  3,
  5,
  11,
  10,
  5,
  14,
  2,
  7,
  12,
  7,
  13,
  13,
  8,
  14,
  11,
  3,
  5,
  0,
  6,
  6,
  15,
  9,
  0,
  10,
  3,
  1,
  4,
  2,
  7,
  8,
  2,
  5,
  12,
  11,
  1,
  12,
  10,
  4,
  14,
  15,
  9,
  10,
  3,
  6,
  15,
  9,
  0,
  0,
  6,
  12,
  10,
  11,
  1,
  7,
  13,
  13,
  8,
  15,
  9,
  1,
  4,
  3,
  5,
  14,
  11,
  5,
  12,
  2,
  7,
  8,
  2,
  4,
  14,
  2,
  14,
  12,
  11,
  4,
  2,
  1,
  12,
  7,
  4,
  10,
  7,
  11,
  13,
  6,
  1,
  8,
  5,
  5,
  0,
  3,
  15,
  15,
  10,
  13,
  3,
  0,
  9,
  14,
  8,
  9,
  6,
  4,
  11,
  2,
  8,
  1,
  12,
  11,
  7,
  10,
  1,
  13,
  14,
  7,
  2,
  8,
  13,
  15,
  6,
  9,
  15,
  12,
  0,
  5,
  9,
  6,
  10,
  3,
  4,
  0,
  5,
  14,
  3,
  12,
  10,
  1,
  15,
  10,
  4,
  15,
  2,
  9,
  7,
  2,
  12,
  6,
  9,
  8,
  5,
  0,
  6,
  13,
  1,
  3,
  13,
  4,
  14,
  14,
  0,
  7,
  11,
  5,
  3,
  11,
  8,
  9,
  4,
  14,
  3,
  15,
  2,
  5,
  12,
  2,
  9,
  8,
  5,
  12,
  15,
  3,
  10,
  7,
  11,
  0,
  14,
  4,
  1,
  10,
  7,
  1,
  6,
  13,
  0,
  11,
  8,
  6,
  13,
  4,
  13,
  11,
  0,
  2,
  11,
  14,
  7,
  15,
  4,
  0,
  9,
  8,
  1,
  13,
  10,
  3,
  14,
  12,
  3,
  9,
  5,
  7,
  12,
  5,
  2,
  10,
  15,
  6,
  8,
  1,
  6,
  1,
  6,
  4,
  11,
  11,
  13,
  13,
  8,
  12,
  1,
  3,
  4,
  7,
  10,
  14,
  7,
  10,
  9,
  15,
  5,
  6,
  0,
  8,
  15,
  0,
  14,
  5,
  2,
  9,
  3,
  2,
  12,
  13,
  1,
  2,
  15,
  8,
  13,
  4,
  8,
  6,
  10,
  15,
  3,
  11,
  7,
  1,
  4,
  10,
  12,
  9,
  5,
  3,
  6,
  14,
  11,
  5,
  0,
  0,
  14,
  12,
  9,
  7,
  2,
  7,
  2,
  11,
  1,
  4,
  14,
  1,
  7,
  9,
  4,
  12,
  10,
  14,
  8,
  2,
  13,
  0,
  15,
  6,
  12,
  10,
  9,
  13,
  0,
  15,
  3,
  3,
  5,
  5,
  6,
  8,
  11
];
utils$n.substitute = function(M, x) {
  for (var $ = 0, T = 0; T < 4; T++) {
    var S = M >>> 18 - T * 6 & 63, D = sTable[T * 64 + S];
    $ <<= 4, $ |= D;
  }
  for (var T = 0; T < 4; T++) {
    var S = x >>> 18 - T * 6 & 63, D = sTable[4 * 64 + T * 64 + S];
    $ <<= 4, $ |= D;
  }
  return $ >>> 0;
};
var permuteTable = [
  16,
  25,
  12,
  11,
  3,
  20,
  4,
  15,
  31,
  17,
  9,
  6,
  27,
  14,
  1,
  22,
  30,
  24,
  8,
  18,
  0,
  5,
  29,
  23,
  13,
  19,
  2,
  26,
  10,
  21,
  28,
  7
];
utils$n.permute = function(M) {
  for (var x = 0, $ = 0; $ < permuteTable.length; $++)
    x <<= 1, x |= M >>> permuteTable[$] & 1;
  return x >>> 0;
};
utils$n.padSplit = function(M, x, $) {
  for (var T = M.toString(2); T.length < x; )
    T = "0" + T;
  for (var S = [], D = 0; D < x; D += $)
    S.push(T.slice(D, D + $));
  return S.join(" ");
};
var minimalisticAssert = assert$i;
function assert$i(w, M) {
  if (!w)
    throw new Error(M || "Assertion failed");
}
assert$i.equal = function(M, x, $) {
  if (M != x)
    throw new Error($ || "Assertion failed: " + M + " != " + x);
};
var assert$h = minimalisticAssert;
function Cipher$3(w) {
  this.options = w, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = w.padding !== !1;
}
var cipher = Cipher$3;
Cipher$3.prototype._init = function() {
};
Cipher$3.prototype.update = function(M) {
  return M.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(M) : this._updateEncrypt(M);
};
Cipher$3.prototype._buffer = function(M, x) {
  for (var $ = Math.min(this.buffer.length - this.bufferOff, M.length - x), T = 0; T < $; T++)
    this.buffer[this.bufferOff + T] = M[x + T];
  return this.bufferOff += $, $;
};
Cipher$3.prototype._flushBuffer = function(M, x) {
  return this._update(this.buffer, 0, M, x), this.bufferOff = 0, this.blockSize;
};
Cipher$3.prototype._updateEncrypt = function(M) {
  var x = 0, $ = 0, T = (this.bufferOff + M.length) / this.blockSize | 0, S = new Array(T * this.blockSize);
  this.bufferOff !== 0 && (x += this._buffer(M, x), this.bufferOff === this.buffer.length && ($ += this._flushBuffer(S, $)));
  for (var D = M.length - (M.length - x) % this.blockSize; x < D; x += this.blockSize)
    this._update(M, x, S, $), $ += this.blockSize;
  for (; x < M.length; x++, this.bufferOff++)
    this.buffer[this.bufferOff] = M[x];
  return S;
};
Cipher$3.prototype._updateDecrypt = function(M) {
  for (var x = 0, $ = 0, T = Math.ceil((this.bufferOff + M.length) / this.blockSize) - 1, S = new Array(T * this.blockSize); T > 0; T--)
    x += this._buffer(M, x), $ += this._flushBuffer(S, $);
  return x += this._buffer(M, x), S;
};
Cipher$3.prototype.final = function(M) {
  var x;
  M && (x = this.update(M));
  var $;
  return this.type === "encrypt" ? $ = this._finalEncrypt() : $ = this._finalDecrypt(), x ? x.concat($) : $;
};
Cipher$3.prototype._pad = function(M, x) {
  if (x === 0)
    return !1;
  for (; x < M.length; )
    M[x++] = 0;
  return !0;
};
Cipher$3.prototype._finalEncrypt = function() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];
  var M = new Array(this.blockSize);
  return this._update(this.buffer, 0, M, 0), M;
};
Cipher$3.prototype._unpad = function(M) {
  return M;
};
Cipher$3.prototype._finalDecrypt = function() {
  assert$h.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
  var M = new Array(this.blockSize);
  return this._flushBuffer(M, 0), this._unpad(M);
};
var assert$g = minimalisticAssert, inherits$c = inherits_browserExports, utils$m = utils$n, Cipher$2 = cipher;
function DESState() {
  this.tmp = new Array(2), this.keys = null;
}
function DES$3(w) {
  Cipher$2.call(this, w);
  var M = new DESState();
  this._desState = M, this.deriveKeys(M, w.key);
}
inherits$c(DES$3, Cipher$2);
var des$1 = DES$3;
DES$3.create = function(M) {
  return new DES$3(M);
};
var shiftTable = [
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1
];
DES$3.prototype.deriveKeys = function(M, x) {
  M.keys = new Array(16 * 2), assert$g.equal(x.length, this.blockSize, "Invalid key length");
  var $ = utils$m.readUInt32BE(x, 0), T = utils$m.readUInt32BE(x, 4);
  utils$m.pc1($, T, M.tmp, 0), $ = M.tmp[0], T = M.tmp[1];
  for (var S = 0; S < M.keys.length; S += 2) {
    var D = shiftTable[S >>> 1];
    $ = utils$m.r28shl($, D), T = utils$m.r28shl(T, D), utils$m.pc2($, T, M.keys, S);
  }
};
DES$3.prototype._update = function(M, x, $, T) {
  var S = this._desState, D = utils$m.readUInt32BE(M, x), F = utils$m.readUInt32BE(M, x + 4);
  utils$m.ip(D, F, S.tmp, 0), D = S.tmp[0], F = S.tmp[1], this.type === "encrypt" ? this._encrypt(S, D, F, S.tmp, 0) : this._decrypt(S, D, F, S.tmp, 0), D = S.tmp[0], F = S.tmp[1], utils$m.writeUInt32BE($, D, T), utils$m.writeUInt32BE($, F, T + 4);
};
DES$3.prototype._pad = function(M, x) {
  if (this.padding === !1)
    return !1;
  for (var $ = M.length - x, T = x; T < M.length; T++)
    M[T] = $;
  return !0;
};
DES$3.prototype._unpad = function(M) {
  if (this.padding === !1)
    return M;
  for (var x = M[M.length - 1], $ = M.length - x; $ < M.length; $++)
    assert$g.equal(M[$], x);
  return M.slice(0, M.length - x);
};
DES$3.prototype._encrypt = function(M, x, $, T, S) {
  for (var D = x, F = $, z = 0; z < M.keys.length; z += 2) {
    var Z = M.keys[z], H = M.keys[z + 1];
    utils$m.expand(F, M.tmp, 0), Z ^= M.tmp[0], H ^= M.tmp[1];
    var V = utils$m.substitute(Z, H), X = utils$m.permute(V), Q = F;
    F = (D ^ X) >>> 0, D = Q;
  }
  utils$m.rip(F, D, T, S);
};
DES$3.prototype._decrypt = function(M, x, $, T, S) {
  for (var D = $, F = x, z = M.keys.length - 2; z >= 0; z -= 2) {
    var Z = M.keys[z], H = M.keys[z + 1];
    utils$m.expand(D, M.tmp, 0), Z ^= M.tmp[0], H ^= M.tmp[1];
    var V = utils$m.substitute(Z, H), X = utils$m.permute(V), Q = D;
    D = (F ^ X) >>> 0, F = Q;
  }
  utils$m.rip(D, F, T, S);
};
var cbc$1 = {}, assert$f = minimalisticAssert, inherits$b = inherits_browserExports, proto$1 = {};
function CBCState(w) {
  assert$f.equal(w.length, 8, "Invalid IV length"), this.iv = new Array(8);
  for (var M = 0; M < this.iv.length; M++)
    this.iv[M] = w[M];
}
function instantiate(w) {
  function M(S) {
    w.call(this, S), this._cbcInit();
  }
  inherits$b(M, w);
  for (var x = Object.keys(proto$1), $ = 0; $ < x.length; $++) {
    var T = x[$];
    M.prototype[T] = proto$1[T];
  }
  return M.create = function(D) {
    return new M(D);
  }, M;
}
cbc$1.instantiate = instantiate;
proto$1._cbcInit = function() {
  var M = new CBCState(this.options.iv);
  this._cbcState = M;
};
proto$1._update = function(M, x, $, T) {
  var S = this._cbcState, D = this.constructor.super_.prototype, F = S.iv;
  if (this.type === "encrypt") {
    for (var z = 0; z < this.blockSize; z++)
      F[z] ^= M[x + z];
    D._update.call(this, F, 0, $, T);
    for (var z = 0; z < this.blockSize; z++)
      F[z] = $[T + z];
  } else {
    D._update.call(this, M, x, $, T);
    for (var z = 0; z < this.blockSize; z++)
      $[T + z] ^= F[z];
    for (var z = 0; z < this.blockSize; z++)
      F[z] = M[x + z];
  }
};
var assert$e = minimalisticAssert, inherits$a = inherits_browserExports, Cipher$1 = cipher, DES$2 = des$1;
function EDEState(w, M) {
  assert$e.equal(M.length, 24, "Invalid key length");
  var x = M.slice(0, 8), $ = M.slice(8, 16), T = M.slice(16, 24);
  w === "encrypt" ? this.ciphers = [
    DES$2.create({ type: "encrypt", key: x }),
    DES$2.create({ type: "decrypt", key: $ }),
    DES$2.create({ type: "encrypt", key: T })
  ] : this.ciphers = [
    DES$2.create({ type: "decrypt", key: T }),
    DES$2.create({ type: "encrypt", key: $ }),
    DES$2.create({ type: "decrypt", key: x })
  ];
}
function EDE(w) {
  Cipher$1.call(this, w);
  var M = new EDEState(this.type, this.options.key);
  this._edeState = M;
}
inherits$a(EDE, Cipher$1);
var ede = EDE;
EDE.create = function(M) {
  return new EDE(M);
};
EDE.prototype._update = function(M, x, $, T) {
  var S = this._edeState;
  S.ciphers[0]._update(M, x, $, T), S.ciphers[1]._update($, T, $, T), S.ciphers[2]._update($, T, $, T);
};
EDE.prototype._pad = DES$2.prototype._pad;
EDE.prototype._unpad = DES$2.prototype._unpad;
des$2.utils = utils$n;
des$2.Cipher = cipher;
des$2.DES = des$1;
des$2.CBC = cbc$1;
des$2.EDE = ede;
var CipherBase = cipherBase, des = des$2, inherits$9 = inherits_browserExports, Buffer$j = safeBufferExports$2.Buffer, modes$3 = {
  "des-ede3-cbc": des.CBC.instantiate(des.EDE),
  "des-ede3": des.EDE,
  "des-ede-cbc": des.CBC.instantiate(des.EDE),
  "des-ede": des.EDE,
  "des-cbc": des.CBC.instantiate(des.DES),
  "des-ecb": des.DES
};
modes$3.des = modes$3["des-cbc"];
modes$3.des3 = modes$3["des-ede3-cbc"];
var browserifyDes = DES$1;
inherits$9(DES$1, CipherBase);
function DES$1(w) {
  CipherBase.call(this);
  var M = w.mode.toLowerCase(), x = modes$3[M], $;
  w.decrypt ? $ = "decrypt" : $ = "encrypt";
  var T = w.key;
  Buffer$j.isBuffer(T) || (T = Buffer$j.from(T)), (M === "des-ede" || M === "des-ede-cbc") && (T = Buffer$j.concat([T, T.slice(0, 8)]));
  var S = w.iv;
  Buffer$j.isBuffer(S) || (S = Buffer$j.from(S)), this._des = x.create({
    key: T,
    iv: S,
    type: $
  });
}
DES$1.prototype._update = function(w) {
  return Buffer$j.from(this._des.update(w));
};
DES$1.prototype._final = function() {
  return Buffer$j.from(this._des.final());
};
var browser$5 = {}, encrypter = {}, ecb = {};
ecb.encrypt = function(w, M) {
  return w._cipher.encryptBlock(M);
};
ecb.decrypt = function(w, M) {
  return w._cipher.decryptBlock(M);
};
var cbc = {}, bufferXor = function(M, x) {
  for (var $ = Math.min(M.length, x.length), T = new Buffer$D($), S = 0; S < $; ++S)
    T[S] = M[S] ^ x[S];
  return T;
}, xor$7 = bufferXor;
cbc.encrypt = function(w, M) {
  var x = xor$7(M, w._prev);
  return w._prev = w._cipher.encryptBlock(x), w._prev;
};
cbc.decrypt = function(w, M) {
  var x = w._prev;
  w._prev = M;
  var $ = w._cipher.decryptBlock(M);
  return xor$7($, x);
};
var cfb = {}, Buffer$i = safeBufferExports$2.Buffer, xor$6 = bufferXor;
function encryptStart(w, M, x) {
  var $ = M.length, T = xor$6(M, w._cache);
  return w._cache = w._cache.slice($), w._prev = Buffer$i.concat([w._prev, x ? M : T]), T;
}
cfb.encrypt = function(w, M, x) {
  for (var $ = Buffer$i.allocUnsafe(0), T; M.length; )
    if (w._cache.length === 0 && (w._cache = w._cipher.encryptBlock(w._prev), w._prev = Buffer$i.allocUnsafe(0)), w._cache.length <= M.length)
      T = w._cache.length, $ = Buffer$i.concat([$, encryptStart(w, M.slice(0, T), x)]), M = M.slice(T);
    else {
      $ = Buffer$i.concat([$, encryptStart(w, M, x)]);
      break;
    }
  return $;
};
var cfb8 = {}, Buffer$h = safeBufferExports$2.Buffer;
function encryptByte$1(w, M, x) {
  var $ = w._cipher.encryptBlock(w._prev), T = $[0] ^ M;
  return w._prev = Buffer$h.concat([
    w._prev.slice(1),
    Buffer$h.from([x ? M : T])
  ]), T;
}
cfb8.encrypt = function(w, M, x) {
  for (var $ = M.length, T = Buffer$h.allocUnsafe($), S = -1; ++S < $; )
    T[S] = encryptByte$1(w, M[S], x);
  return T;
};
var cfb1 = {}, Buffer$g = safeBufferExports$2.Buffer;
function encryptByte(w, M, x) {
  for (var $, T = -1, S = 8, D = 0, F, z; ++T < S; )
    $ = w._cipher.encryptBlock(w._prev), F = M & 1 << 7 - T ? 128 : 0, z = $[0] ^ F, D += (z & 128) >> T % 8, w._prev = shiftIn(w._prev, x ? F : z);
  return D;
}
function shiftIn(w, M) {
  var x = w.length, $ = -1, T = Buffer$g.allocUnsafe(w.length);
  for (w = Buffer$g.concat([w, Buffer$g.from([M])]); ++$ < x; )
    T[$] = w[$] << 1 | w[$ + 1] >> 7;
  return T;
}
cfb1.encrypt = function(w, M, x) {
  for (var $ = M.length, T = Buffer$g.allocUnsafe($), S = -1; ++S < $; )
    T[S] = encryptByte(w, M[S], x);
  return T;
};
var ofb = {}, xor$5 = bufferXor;
function getBlock$1(w) {
  return w._prev = w._cipher.encryptBlock(w._prev), w._prev;
}
ofb.encrypt = function(w, M) {
  for (; w._cache.length < M.length; )
    w._cache = Buffer$D.concat([w._cache, getBlock$1(w)]);
  var x = w._cache.slice(0, M.length);
  return w._cache = w._cache.slice(M.length), xor$5(M, x);
};
var ctr = {};
function incr32$2(w) {
  for (var M = w.length, x; M--; )
    if (x = w.readUInt8(M), x === 255)
      w.writeUInt8(0, M);
    else {
      x++, w.writeUInt8(x, M);
      break;
    }
}
var incr32_1 = incr32$2, xor$4 = bufferXor, Buffer$f = safeBufferExports$2.Buffer, incr32$1 = incr32_1;
function getBlock(w) {
  var M = w._cipher.encryptBlockRaw(w._prev);
  return incr32$1(w._prev), M;
}
var blockSize = 16;
ctr.encrypt = function(w, M) {
  var x = Math.ceil(M.length / blockSize), $ = w._cache.length;
  w._cache = Buffer$f.concat([
    w._cache,
    Buffer$f.allocUnsafe(x * blockSize)
  ]);
  for (var T = 0; T < x; T++) {
    var S = getBlock(w), D = $ + T * blockSize;
    w._cache.writeUInt32BE(S[0], D + 0), w._cache.writeUInt32BE(S[1], D + 4), w._cache.writeUInt32BE(S[2], D + 8), w._cache.writeUInt32BE(S[3], D + 12);
  }
  var F = w._cache.slice(0, M.length);
  return w._cache = w._cache.slice(M.length), xor$4(M, F);
};
const aes128 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes192 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes256 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, require$$2 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modeModules = {
  ECB: ecb,
  CBC: cbc,
  CFB: cfb,
  CFB8: cfb8,
  CFB1: cfb1,
  OFB: ofb,
  CTR: ctr,
  GCM: ctr
}, modes$2 = require$$2;
for (var key$2 in modes$2)
  modes$2[key$2].module = modeModules[modes$2[key$2].mode];
var modes_1 = modes$2, aes$5 = {}, Buffer$e = safeBufferExports$2.Buffer;
function asUInt32Array(w) {
  Buffer$e.isBuffer(w) || (w = Buffer$e.from(w));
  for (var M = w.length / 4 | 0, x = new Array(M), $ = 0; $ < M; $++)
    x[$] = w.readUInt32BE($ * 4);
  return x;
}
function scrubVec(w) {
  for (var M = 0; M < w.length; w++)
    w[M] = 0;
}
function cryptBlock(w, M, x, $, T) {
  for (var S = x[0], D = x[1], F = x[2], z = x[3], Z = w[0] ^ M[0], H = w[1] ^ M[1], V = w[2] ^ M[2], X = w[3] ^ M[3], Q, fe, ce, me, de = 4, ne = 1; ne < T; ne++)
    Q = S[Z >>> 24] ^ D[H >>> 16 & 255] ^ F[V >>> 8 & 255] ^ z[X & 255] ^ M[de++], fe = S[H >>> 24] ^ D[V >>> 16 & 255] ^ F[X >>> 8 & 255] ^ z[Z & 255] ^ M[de++], ce = S[V >>> 24] ^ D[X >>> 16 & 255] ^ F[Z >>> 8 & 255] ^ z[H & 255] ^ M[de++], me = S[X >>> 24] ^ D[Z >>> 16 & 255] ^ F[H >>> 8 & 255] ^ z[V & 255] ^ M[de++], Z = Q, H = fe, V = ce, X = me;
  return Q = ($[Z >>> 24] << 24 | $[H >>> 16 & 255] << 16 | $[V >>> 8 & 255] << 8 | $[X & 255]) ^ M[de++], fe = ($[H >>> 24] << 24 | $[V >>> 16 & 255] << 16 | $[X >>> 8 & 255] << 8 | $[Z & 255]) ^ M[de++], ce = ($[V >>> 24] << 24 | $[X >>> 16 & 255] << 16 | $[Z >>> 8 & 255] << 8 | $[H & 255]) ^ M[de++], me = ($[X >>> 24] << 24 | $[Z >>> 16 & 255] << 16 | $[H >>> 8 & 255] << 8 | $[V & 255]) ^ M[de++], Q = Q >>> 0, fe = fe >>> 0, ce = ce >>> 0, me = me >>> 0, [Q, fe, ce, me];
}
var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], G = function() {
  for (var w = new Array(256), M = 0; M < 256; M++)
    M < 128 ? w[M] = M << 1 : w[M] = M << 1 ^ 283;
  for (var x = [], $ = [], T = [[], [], [], []], S = [[], [], [], []], D = 0, F = 0, z = 0; z < 256; ++z) {
    var Z = F ^ F << 1 ^ F << 2 ^ F << 3 ^ F << 4;
    Z = Z >>> 8 ^ Z & 255 ^ 99, x[D] = Z, $[Z] = D;
    var H = w[D], V = w[H], X = w[V], Q = w[Z] * 257 ^ Z * 16843008;
    T[0][D] = Q << 24 | Q >>> 8, T[1][D] = Q << 16 | Q >>> 16, T[2][D] = Q << 8 | Q >>> 24, T[3][D] = Q, Q = X * 16843009 ^ V * 65537 ^ H * 257 ^ D * 16843008, S[0][Z] = Q << 24 | Q >>> 8, S[1][Z] = Q << 16 | Q >>> 16, S[2][Z] = Q << 8 | Q >>> 24, S[3][Z] = Q, D === 0 ? D = F = 1 : (D = H ^ w[w[w[X ^ H]]], F ^= w[w[F]]);
  }
  return {
    SBOX: x,
    INV_SBOX: $,
    SUB_MIX: T,
    INV_SUB_MIX: S
  };
}();
function AES(w) {
  this._key = asUInt32Array(w), this._reset();
}
AES.blockSize = 4 * 4;
AES.keySize = 256 / 8;
AES.prototype.blockSize = AES.blockSize;
AES.prototype.keySize = AES.keySize;
AES.prototype._reset = function() {
  for (var w = this._key, M = w.length, x = M + 6, $ = (x + 1) * 4, T = [], S = 0; S < M; S++)
    T[S] = w[S];
  for (S = M; S < $; S++) {
    var D = T[S - 1];
    S % M === 0 ? (D = D << 8 | D >>> 24, D = G.SBOX[D >>> 24] << 24 | G.SBOX[D >>> 16 & 255] << 16 | G.SBOX[D >>> 8 & 255] << 8 | G.SBOX[D & 255], D ^= RCON[S / M | 0] << 24) : M > 6 && S % M === 4 && (D = G.SBOX[D >>> 24] << 24 | G.SBOX[D >>> 16 & 255] << 16 | G.SBOX[D >>> 8 & 255] << 8 | G.SBOX[D & 255]), T[S] = T[S - M] ^ D;
  }
  for (var F = [], z = 0; z < $; z++) {
    var Z = $ - z, H = T[Z - (z % 4 ? 0 : 4)];
    z < 4 || Z <= 4 ? F[z] = H : F[z] = G.INV_SUB_MIX[0][G.SBOX[H >>> 24]] ^ G.INV_SUB_MIX[1][G.SBOX[H >>> 16 & 255]] ^ G.INV_SUB_MIX[2][G.SBOX[H >>> 8 & 255]] ^ G.INV_SUB_MIX[3][G.SBOX[H & 255]];
  }
  this._nRounds = x, this._keySchedule = T, this._invKeySchedule = F;
};
AES.prototype.encryptBlockRaw = function(w) {
  return w = asUInt32Array(w), cryptBlock(w, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds);
};
AES.prototype.encryptBlock = function(w) {
  var M = this.encryptBlockRaw(w), x = Buffer$e.allocUnsafe(16);
  return x.writeUInt32BE(M[0], 0), x.writeUInt32BE(M[1], 4), x.writeUInt32BE(M[2], 8), x.writeUInt32BE(M[3], 12), x;
};
AES.prototype.decryptBlock = function(w) {
  w = asUInt32Array(w);
  var M = w[1];
  w[1] = w[3], w[3] = M;
  var x = cryptBlock(w, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds), $ = Buffer$e.allocUnsafe(16);
  return $.writeUInt32BE(x[0], 0), $.writeUInt32BE(x[3], 4), $.writeUInt32BE(x[2], 8), $.writeUInt32BE(x[1], 12), $;
};
AES.prototype.scrub = function() {
  scrubVec(this._keySchedule), scrubVec(this._invKeySchedule), scrubVec(this._key);
};
aes$5.AES = AES;
var Buffer$d = safeBufferExports$2.Buffer, ZEROES = Buffer$d.alloc(16, 0);
function toArray$1(w) {
  return [
    w.readUInt32BE(0),
    w.readUInt32BE(4),
    w.readUInt32BE(8),
    w.readUInt32BE(12)
  ];
}
function fromArray(w) {
  var M = Buffer$d.allocUnsafe(16);
  return M.writeUInt32BE(w[0] >>> 0, 0), M.writeUInt32BE(w[1] >>> 0, 4), M.writeUInt32BE(w[2] >>> 0, 8), M.writeUInt32BE(w[3] >>> 0, 12), M;
}
function GHASH$1(w) {
  this.h = w, this.state = Buffer$d.alloc(16, 0), this.cache = Buffer$d.allocUnsafe(0);
}
GHASH$1.prototype.ghash = function(w) {
  for (var M = -1; ++M < w.length; )
    this.state[M] ^= w[M];
  this._multiply();
};
GHASH$1.prototype._multiply = function() {
  for (var w = toArray$1(this.h), M = [0, 0, 0, 0], x, $, T, S = -1; ++S < 128; ) {
    for ($ = (this.state[~~(S / 8)] & 1 << 7 - S % 8) !== 0, $ && (M[0] ^= w[0], M[1] ^= w[1], M[2] ^= w[2], M[3] ^= w[3]), T = (w[3] & 1) !== 0, x = 3; x > 0; x--)
      w[x] = w[x] >>> 1 | (w[x - 1] & 1) << 31;
    w[0] = w[0] >>> 1, T && (w[0] = w[0] ^ 225 << 24);
  }
  this.state = fromArray(M);
};
GHASH$1.prototype.update = function(w) {
  this.cache = Buffer$d.concat([this.cache, w]);
  for (var M; this.cache.length >= 16; )
    M = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(M);
};
GHASH$1.prototype.final = function(w, M) {
  return this.cache.length && this.ghash(Buffer$d.concat([this.cache, ZEROES], 16)), this.ghash(fromArray([0, w, 0, M])), this.state;
};
var ghash = GHASH$1, aes$4 = aes$5, Buffer$c = safeBufferExports$2.Buffer, Transform$5 = cipherBase, inherits$8 = inherits_browserExports, GHASH = ghash, xor$3 = bufferXor, incr32 = incr32_1;
function xorTest(w, M) {
  var x = 0;
  w.length !== M.length && x++;
  for (var $ = Math.min(w.length, M.length), T = 0; T < $; ++T)
    x += w[T] ^ M[T];
  return x;
}
function calcIv(w, M, x) {
  if (M.length === 12)
    return w._finID = Buffer$c.concat([M, Buffer$c.from([0, 0, 0, 1])]), Buffer$c.concat([M, Buffer$c.from([0, 0, 0, 2])]);
  var $ = new GHASH(x), T = M.length, S = T % 16;
  $.update(M), S && (S = 16 - S, $.update(Buffer$c.alloc(S, 0))), $.update(Buffer$c.alloc(8, 0));
  var D = T * 8, F = Buffer$c.alloc(8);
  F.writeUIntBE(D, 0, 8), $.update(F), w._finID = $.state;
  var z = Buffer$c.from(w._finID);
  return incr32(z), z;
}
function StreamCipher$3(w, M, x, $) {
  Transform$5.call(this);
  var T = Buffer$c.alloc(4, 0);
  this._cipher = new aes$4.AES(M);
  var S = this._cipher.encryptBlock(T);
  this._ghash = new GHASH(S), x = calcIv(this, x, S), this._prev = Buffer$c.from(x), this._cache = Buffer$c.allocUnsafe(0), this._secCache = Buffer$c.allocUnsafe(0), this._decrypt = $, this._alen = 0, this._len = 0, this._mode = w, this._authTag = null, this._called = !1;
}
inherits$8(StreamCipher$3, Transform$5);
StreamCipher$3.prototype._update = function(w) {
  if (!this._called && this._alen) {
    var M = 16 - this._alen % 16;
    M < 16 && (M = Buffer$c.alloc(M, 0), this._ghash.update(M));
  }
  this._called = !0;
  var x = this._mode.encrypt(this, w);
  return this._decrypt ? this._ghash.update(w) : this._ghash.update(x), this._len += w.length, x;
};
StreamCipher$3.prototype._final = function() {
  if (this._decrypt && !this._authTag) throw new Error("Unsupported state or unable to authenticate data");
  var w = xor$3(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
  if (this._decrypt && xorTest(w, this._authTag)) throw new Error("Unsupported state or unable to authenticate data");
  this._authTag = w, this._cipher.scrub();
};
StreamCipher$3.prototype.getAuthTag = function() {
  if (this._decrypt || !Buffer$c.isBuffer(this._authTag)) throw new Error("Attempting to get auth tag in unsupported state");
  return this._authTag;
};
StreamCipher$3.prototype.setAuthTag = function(M) {
  if (!this._decrypt) throw new Error("Attempting to set auth tag in unsupported state");
  this._authTag = M;
};
StreamCipher$3.prototype.setAAD = function(M) {
  if (this._called) throw new Error("Attempting to set AAD in unsupported state");
  this._ghash.update(M), this._alen += M.length;
};
var authCipher = StreamCipher$3, aes$3 = aes$5, Buffer$b = safeBufferExports$2.Buffer, Transform$4 = cipherBase, inherits$7 = inherits_browserExports;
function StreamCipher$2(w, M, x, $) {
  Transform$4.call(this), this._cipher = new aes$3.AES(M), this._prev = Buffer$b.from(x), this._cache = Buffer$b.allocUnsafe(0), this._secCache = Buffer$b.allocUnsafe(0), this._decrypt = $, this._mode = w;
}
inherits$7(StreamCipher$2, Transform$4);
StreamCipher$2.prototype._update = function(w) {
  return this._mode.encrypt(this, w, this._decrypt);
};
StreamCipher$2.prototype._final = function() {
  this._cipher.scrub();
};
var streamCipher = StreamCipher$2, Buffer$a = safeBufferExports$2.Buffer, MD5 = md5_js;
function EVP_BytesToKey(w, M, x, $) {
  if (Buffer$a.isBuffer(w) || (w = Buffer$a.from(w, "binary")), M && (Buffer$a.isBuffer(M) || (M = Buffer$a.from(M, "binary")), M.length !== 8))
    throw new RangeError("salt should be Buffer with 8 byte length");
  for (var T = x / 8, S = Buffer$a.alloc(T), D = Buffer$a.alloc($ || 0), F = Buffer$a.alloc(0); T > 0 || $ > 0; ) {
    var z = new MD5();
    z.update(F), z.update(w), M && z.update(M), F = z.digest();
    var Z = 0;
    if (T > 0) {
      var H = S.length - T;
      Z = Math.min(T, F.length), F.copy(S, H, 0, Z), T -= Z;
    }
    if (Z < F.length && $ > 0) {
      var V = D.length - $, X = Math.min($, F.length - Z);
      F.copy(D, V, Z, Z + X), $ -= X;
    }
  }
  return F.fill(0), { key: S, iv: D };
}
var evp_bytestokey = EVP_BytesToKey, MODES$1 = modes_1, AuthCipher$1 = authCipher, Buffer$9 = safeBufferExports$2.Buffer, StreamCipher$1 = streamCipher, Transform$3 = cipherBase, aes$2 = aes$5, ebtk$2 = evp_bytestokey, inherits$6 = inherits_browserExports;
function Cipher(w, M, x) {
  Transform$3.call(this), this._cache = new Splitter$1(), this._cipher = new aes$2.AES(M), this._prev = Buffer$9.from(x), this._mode = w, this._autopadding = !0;
}
inherits$6(Cipher, Transform$3);
Cipher.prototype._update = function(w) {
  this._cache.add(w);
  for (var M, x, $ = []; M = this._cache.get(); )
    x = this._mode.encrypt(this, M), $.push(x);
  return Buffer$9.concat($);
};
var PADDING = Buffer$9.alloc(16, 16);
Cipher.prototype._final = function() {
  var w = this._cache.flush();
  if (this._autopadding)
    return w = this._mode.encrypt(this, w), this._cipher.scrub(), w;
  if (!w.equals(PADDING))
    throw this._cipher.scrub(), new Error("data not multiple of block length");
};
Cipher.prototype.setAutoPadding = function(w) {
  return this._autopadding = !!w, this;
};
function Splitter$1() {
  this.cache = Buffer$9.allocUnsafe(0);
}
Splitter$1.prototype.add = function(w) {
  this.cache = Buffer$9.concat([this.cache, w]);
};
Splitter$1.prototype.get = function() {
  if (this.cache.length > 15) {
    var w = this.cache.slice(0, 16);
    return this.cache = this.cache.slice(16), w;
  }
  return null;
};
Splitter$1.prototype.flush = function() {
  for (var w = 16 - this.cache.length, M = Buffer$9.allocUnsafe(w), x = -1; ++x < w; )
    M.writeUInt8(w, x);
  return Buffer$9.concat([this.cache, M]);
};
function createCipheriv$1(w, M, x) {
  var $ = MODES$1[w.toLowerCase()];
  if (!$) throw new TypeError("invalid suite type");
  if (typeof M == "string" && (M = Buffer$9.from(M)), M.length !== $.key / 8) throw new TypeError("invalid key length " + M.length);
  if (typeof x == "string" && (x = Buffer$9.from(x)), $.mode !== "GCM" && x.length !== $.iv) throw new TypeError("invalid iv length " + x.length);
  return $.type === "stream" ? new StreamCipher$1($.module, M, x) : $.type === "auth" ? new AuthCipher$1($.module, M, x) : new Cipher($.module, M, x);
}
function createCipher$1(w, M) {
  var x = MODES$1[w.toLowerCase()];
  if (!x) throw new TypeError("invalid suite type");
  var $ = ebtk$2(M, !1, x.key, x.iv);
  return createCipheriv$1(w, $.key, $.iv);
}
encrypter.createCipheriv = createCipheriv$1;
encrypter.createCipher = createCipher$1;
var decrypter = {}, AuthCipher = authCipher, Buffer$8 = safeBufferExports$2.Buffer, MODES = modes_1, StreamCipher = streamCipher, Transform$2 = cipherBase, aes$1 = aes$5, ebtk$1 = evp_bytestokey, inherits$5 = inherits_browserExports;
function Decipher(w, M, x) {
  Transform$2.call(this), this._cache = new Splitter(), this._last = void 0, this._cipher = new aes$1.AES(M), this._prev = Buffer$8.from(x), this._mode = w, this._autopadding = !0;
}
inherits$5(Decipher, Transform$2);
Decipher.prototype._update = function(w) {
  this._cache.add(w);
  for (var M, x, $ = []; M = this._cache.get(this._autopadding); )
    x = this._mode.decrypt(this, M), $.push(x);
  return Buffer$8.concat($);
};
Decipher.prototype._final = function() {
  var w = this._cache.flush();
  if (this._autopadding)
    return unpad(this._mode.decrypt(this, w));
  if (w)
    throw new Error("data not multiple of block length");
};
Decipher.prototype.setAutoPadding = function(w) {
  return this._autopadding = !!w, this;
};
function Splitter() {
  this.cache = Buffer$8.allocUnsafe(0);
}
Splitter.prototype.add = function(w) {
  this.cache = Buffer$8.concat([this.cache, w]);
};
Splitter.prototype.get = function(w) {
  var M;
  if (w) {
    if (this.cache.length > 16)
      return M = this.cache.slice(0, 16), this.cache = this.cache.slice(16), M;
  } else if (this.cache.length >= 16)
    return M = this.cache.slice(0, 16), this.cache = this.cache.slice(16), M;
  return null;
};
Splitter.prototype.flush = function() {
  if (this.cache.length) return this.cache;
};
function unpad(w) {
  var M = w[15];
  if (M < 1 || M > 16)
    throw new Error("unable to decrypt data");
  for (var x = -1; ++x < M; )
    if (w[x + (16 - M)] !== M)
      throw new Error("unable to decrypt data");
  if (M !== 16)
    return w.slice(0, 16 - M);
}
function createDecipheriv$1(w, M, x) {
  var $ = MODES[w.toLowerCase()];
  if (!$) throw new TypeError("invalid suite type");
  if (typeof x == "string" && (x = Buffer$8.from(x)), $.mode !== "GCM" && x.length !== $.iv) throw new TypeError("invalid iv length " + x.length);
  if (typeof M == "string" && (M = Buffer$8.from(M)), M.length !== $.key / 8) throw new TypeError("invalid key length " + M.length);
  return $.type === "stream" ? new StreamCipher($.module, M, x, !0) : $.type === "auth" ? new AuthCipher($.module, M, x, !0) : new Decipher($.module, M, x);
}
function createDecipher$1(w, M) {
  var x = MODES[w.toLowerCase()];
  if (!x) throw new TypeError("invalid suite type");
  var $ = ebtk$1(M, !1, x.key, x.iv);
  return createDecipheriv$1(w, $.key, $.iv);
}
decrypter.createDecipher = createDecipher$1;
decrypter.createDecipheriv = createDecipheriv$1;
var ciphers$2 = encrypter, deciphers = decrypter, modes$1 = require$$2;
function getCiphers$1() {
  return Object.keys(modes$1);
}
browser$5.createCipher = browser$5.Cipher = ciphers$2.createCipher;
browser$5.createCipheriv = browser$5.Cipheriv = ciphers$2.createCipheriv;
browser$5.createDecipher = browser$5.Decipher = deciphers.createDecipher;
browser$5.createDecipheriv = browser$5.Decipheriv = deciphers.createDecipheriv;
browser$5.listCiphers = browser$5.getCiphers = getCiphers$1;
var modes = {};
(function(w) {
  w["des-ecb"] = {
    key: 8,
    iv: 0
  }, w["des-cbc"] = w.des = {
    key: 8,
    iv: 8
  }, w["des-ede3-cbc"] = w.des3 = {
    key: 24,
    iv: 8
  }, w["des-ede3"] = {
    key: 24,
    iv: 0
  }, w["des-ede-cbc"] = {
    key: 16,
    iv: 8
  }, w["des-ede"] = {
    key: 16,
    iv: 0
  };
})(modes);
var DES = browserifyDes, aes = browser$5, aesModes = modes_1, desModes = modes, ebtk = evp_bytestokey;
function createCipher(w, M) {
  w = w.toLowerCase();
  var x, $;
  if (aesModes[w])
    x = aesModes[w].key, $ = aesModes[w].iv;
  else if (desModes[w])
    x = desModes[w].key * 8, $ = desModes[w].iv;
  else
    throw new TypeError("invalid suite type");
  var T = ebtk(M, !1, x, $);
  return createCipheriv(w, T.key, T.iv);
}
function createDecipher(w, M) {
  w = w.toLowerCase();
  var x, $;
  if (aesModes[w])
    x = aesModes[w].key, $ = aesModes[w].iv;
  else if (desModes[w])
    x = desModes[w].key * 8, $ = desModes[w].iv;
  else
    throw new TypeError("invalid suite type");
  var T = ebtk(M, !1, x, $);
  return createDecipheriv(w, T.key, T.iv);
}
function createCipheriv(w, M, x) {
  if (w = w.toLowerCase(), aesModes[w]) return aes.createCipheriv(w, M, x);
  if (desModes[w]) return new DES({ key: M, iv: x, mode: w });
  throw new TypeError("invalid suite type");
}
function createDecipheriv(w, M, x) {
  if (w = w.toLowerCase(), aesModes[w]) return aes.createDecipheriv(w, M, x);
  if (desModes[w]) return new DES({ key: M, iv: x, mode: w, decrypt: !0 });
  throw new TypeError("invalid suite type");
}
function getCiphers() {
  return Object.keys(desModes).concat(aes.getCiphers());
}
browser$6.createCipher = browser$6.Cipher = createCipher;
browser$6.createCipheriv = browser$6.Cipheriv = createCipheriv;
browser$6.createDecipher = browser$6.Decipher = createDecipher;
browser$6.createDecipheriv = browser$6.Decipheriv = createDecipheriv;
browser$6.listCiphers = browser$6.getCiphers = getCiphers;
var browser$4 = {}, bn$6 = { exports: {} };
bn$6.exports;
(function(w) {
  (function(M, x) {
    function $(N, y) {
      if (!N) throw new Error(y || "Assertion failed");
    }
    function T(N, y) {
      N.super_ = y;
      var E = function() {
      };
      E.prototype = y.prototype, N.prototype = new E(), N.prototype.constructor = N;
    }
    function S(N, y, E) {
      if (S.isBN(N))
        return N;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, N !== null && ((y === "le" || y === "be") && (E = y, y = 10), this._init(N || 0, y || 10, E || "be"));
    }
    typeof M == "object" ? M.exports = S : x.BN = S, S.BN = S, S.wordSize = 26;
    var D;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? D = window.Buffer : D = dist.Buffer;
    } catch {
    }
    S.isBN = function(y) {
      return y instanceof S ? !0 : y !== null && typeof y == "object" && y.constructor.wordSize === S.wordSize && Array.isArray(y.words);
    }, S.max = function(y, E) {
      return y.cmp(E) > 0 ? y : E;
    }, S.min = function(y, E) {
      return y.cmp(E) < 0 ? y : E;
    }, S.prototype._init = function(y, E, A) {
      if (typeof y == "number")
        return this._initNumber(y, E, A);
      if (typeof y == "object")
        return this._initArray(y, E, A);
      E === "hex" && (E = 16), $(E === (E | 0) && E >= 2 && E <= 36), y = y.toString().replace(/\s+/g, "");
      var B = 0;
      y[0] === "-" && (B++, this.negative = 1), B < y.length && (E === 16 ? this._parseHex(y, B, A) : (this._parseBase(y, E, B), A === "le" && this._initArray(this.toArray(), E, A)));
    }, S.prototype._initNumber = function(y, E, A) {
      y < 0 && (this.negative = 1, y = -y), y < 67108864 ? (this.words = [y & 67108863], this.length = 1) : y < 4503599627370496 ? (this.words = [
        y & 67108863,
        y / 67108864 & 67108863
      ], this.length = 2) : ($(y < 9007199254740992), this.words = [
        y & 67108863,
        y / 67108864 & 67108863,
        1
      ], this.length = 3), A === "le" && this._initArray(this.toArray(), E, A);
    }, S.prototype._initArray = function(y, E, A) {
      if ($(typeof y.length == "number"), y.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(y.length / 3), this.words = new Array(this.length);
      for (var B = 0; B < this.length; B++)
        this.words[B] = 0;
      var O, C, L = 0;
      if (A === "be")
        for (B = y.length - 1, O = 0; B >= 0; B -= 3)
          C = y[B] | y[B - 1] << 8 | y[B - 2] << 16, this.words[O] |= C << L & 67108863, this.words[O + 1] = C >>> 26 - L & 67108863, L += 24, L >= 26 && (L -= 26, O++);
      else if (A === "le")
        for (B = 0, O = 0; B < y.length; B += 3)
          C = y[B] | y[B + 1] << 8 | y[B + 2] << 16, this.words[O] |= C << L & 67108863, this.words[O + 1] = C >>> 26 - L & 67108863, L += 24, L >= 26 && (L -= 26, O++);
      return this.strip();
    };
    function F(N, y) {
      var E = N.charCodeAt(y);
      return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
    }
    function z(N, y, E) {
      var A = F(N, E);
      return E - 1 >= y && (A |= F(N, E - 1) << 4), A;
    }
    S.prototype._parseHex = function(y, E, A) {
      this.length = Math.ceil((y.length - E) / 6), this.words = new Array(this.length);
      for (var B = 0; B < this.length; B++)
        this.words[B] = 0;
      var O = 0, C = 0, L;
      if (A === "be")
        for (B = y.length - 1; B >= E; B -= 2)
          L = z(y, E, B) << O, this.words[C] |= L & 67108863, O >= 18 ? (O -= 18, C += 1, this.words[C] |= L >>> 26) : O += 8;
      else {
        var P = y.length - E;
        for (B = P % 2 === 0 ? E + 1 : E; B < y.length; B += 2)
          L = z(y, E, B) << O, this.words[C] |= L & 67108863, O >= 18 ? (O -= 18, C += 1, this.words[C] |= L >>> 26) : O += 8;
      }
      this.strip();
    };
    function Z(N, y, E, A) {
      for (var B = 0, O = Math.min(N.length, E), C = y; C < O; C++) {
        var L = N.charCodeAt(C) - 48;
        B *= A, L >= 49 ? B += L - 49 + 10 : L >= 17 ? B += L - 17 + 10 : B += L;
      }
      return B;
    }
    S.prototype._parseBase = function(y, E, A) {
      this.words = [0], this.length = 1;
      for (var B = 0, O = 1; O <= 67108863; O *= E)
        B++;
      B--, O = O / E | 0;
      for (var C = y.length - A, L = C % B, P = Math.min(C, C - L) + A, _ = 0, I = A; I < P; I += B)
        _ = Z(y, I, I + B, E), this.imuln(O), this.words[0] + _ < 67108864 ? this.words[0] += _ : this._iaddn(_);
      if (L !== 0) {
        var U = 1;
        for (_ = Z(y, I, y.length, E), I = 0; I < L; I++)
          U *= E;
        this.imuln(U), this.words[0] + _ < 67108864 ? this.words[0] += _ : this._iaddn(_);
      }
      this.strip();
    }, S.prototype.copy = function(y) {
      y.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        y.words[E] = this.words[E];
      y.length = this.length, y.negative = this.negative, y.red = this.red;
    }, S.prototype.clone = function() {
      var y = new S(null);
      return this.copy(y), y;
    }, S.prototype._expand = function(y) {
      for (; this.length < y; )
        this.words[this.length++] = 0;
      return this;
    }, S.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, S.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, S.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var H = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], V = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], X = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    S.prototype.toString = function(y, E) {
      y = y || 10, E = E | 0 || 1;
      var A;
      if (y === 16 || y === "hex") {
        A = "";
        for (var B = 0, O = 0, C = 0; C < this.length; C++) {
          var L = this.words[C], P = ((L << B | O) & 16777215).toString(16);
          O = L >>> 24 - B & 16777215, B += 2, B >= 26 && (B -= 26, C--), O !== 0 || C !== this.length - 1 ? A = H[6 - P.length] + P + A : A = P + A;
        }
        for (O !== 0 && (A = O.toString(16) + A); A.length % E !== 0; )
          A = "0" + A;
        return this.negative !== 0 && (A = "-" + A), A;
      }
      if (y === (y | 0) && y >= 2 && y <= 36) {
        var _ = V[y], I = X[y];
        A = "";
        var U = this.clone();
        for (U.negative = 0; !U.isZero(); ) {
          var Y = U.modn(I).toString(y);
          U = U.idivn(I), U.isZero() ? A = Y + A : A = H[_ - Y.length] + Y + A;
        }
        for (this.isZero() && (A = "0" + A); A.length % E !== 0; )
          A = "0" + A;
        return this.negative !== 0 && (A = "-" + A), A;
      }
      $(!1, "Base should be between 2 and 36");
    }, S.prototype.toNumber = function() {
      var y = this.words[0];
      return this.length === 2 ? y += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? y += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && $(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -y : y;
    }, S.prototype.toJSON = function() {
      return this.toString(16);
    }, S.prototype.toBuffer = function(y, E) {
      return $(typeof D < "u"), this.toArrayLike(D, y, E);
    }, S.prototype.toArray = function(y, E) {
      return this.toArrayLike(Array, y, E);
    }, S.prototype.toArrayLike = function(y, E, A) {
      var B = this.byteLength(), O = A || Math.max(1, B);
      $(B <= O, "byte array longer than desired length"), $(O > 0, "Requested array length <= 0"), this.strip();
      var C = E === "le", L = new y(O), P, _, I = this.clone();
      if (C) {
        for (_ = 0; !I.isZero(); _++)
          P = I.andln(255), I.iushrn(8), L[_] = P;
        for (; _ < O; _++)
          L[_] = 0;
      } else {
        for (_ = 0; _ < O - B; _++)
          L[_] = 0;
        for (_ = 0; !I.isZero(); _++)
          P = I.andln(255), I.iushrn(8), L[O - _ - 1] = P;
      }
      return L;
    }, Math.clz32 ? S.prototype._countBits = function(y) {
      return 32 - Math.clz32(y);
    } : S.prototype._countBits = function(y) {
      var E = y, A = 0;
      return E >= 4096 && (A += 13, E >>>= 13), E >= 64 && (A += 7, E >>>= 7), E >= 8 && (A += 4, E >>>= 4), E >= 2 && (A += 2, E >>>= 2), A + E;
    }, S.prototype._zeroBits = function(y) {
      if (y === 0) return 26;
      var E = y, A = 0;
      return E & 8191 || (A += 13, E >>>= 13), E & 127 || (A += 7, E >>>= 7), E & 15 || (A += 4, E >>>= 4), E & 3 || (A += 2, E >>>= 2), E & 1 || A++, A;
    }, S.prototype.bitLength = function() {
      var y = this.words[this.length - 1], E = this._countBits(y);
      return (this.length - 1) * 26 + E;
    };
    function Q(N) {
      for (var y = new Array(N.bitLength()), E = 0; E < y.length; E++) {
        var A = E / 26 | 0, B = E % 26;
        y[E] = (N.words[A] & 1 << B) >>> B;
      }
      return y;
    }
    S.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var y = 0, E = 0; E < this.length; E++) {
        var A = this._zeroBits(this.words[E]);
        if (y += A, A !== 26) break;
      }
      return y;
    }, S.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, S.prototype.toTwos = function(y) {
      return this.negative !== 0 ? this.abs().inotn(y).iaddn(1) : this.clone();
    }, S.prototype.fromTwos = function(y) {
      return this.testn(y - 1) ? this.notn(y).iaddn(1).ineg() : this.clone();
    }, S.prototype.isNeg = function() {
      return this.negative !== 0;
    }, S.prototype.neg = function() {
      return this.clone().ineg();
    }, S.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, S.prototype.iuor = function(y) {
      for (; this.length < y.length; )
        this.words[this.length++] = 0;
      for (var E = 0; E < y.length; E++)
        this.words[E] = this.words[E] | y.words[E];
      return this.strip();
    }, S.prototype.ior = function(y) {
      return $((this.negative | y.negative) === 0), this.iuor(y);
    }, S.prototype.or = function(y) {
      return this.length > y.length ? this.clone().ior(y) : y.clone().ior(this);
    }, S.prototype.uor = function(y) {
      return this.length > y.length ? this.clone().iuor(y) : y.clone().iuor(this);
    }, S.prototype.iuand = function(y) {
      var E;
      this.length > y.length ? E = y : E = this;
      for (var A = 0; A < E.length; A++)
        this.words[A] = this.words[A] & y.words[A];
      return this.length = E.length, this.strip();
    }, S.prototype.iand = function(y) {
      return $((this.negative | y.negative) === 0), this.iuand(y);
    }, S.prototype.and = function(y) {
      return this.length > y.length ? this.clone().iand(y) : y.clone().iand(this);
    }, S.prototype.uand = function(y) {
      return this.length > y.length ? this.clone().iuand(y) : y.clone().iuand(this);
    }, S.prototype.iuxor = function(y) {
      var E, A;
      this.length > y.length ? (E = this, A = y) : (E = y, A = this);
      for (var B = 0; B < A.length; B++)
        this.words[B] = E.words[B] ^ A.words[B];
      if (this !== E)
        for (; B < E.length; B++)
          this.words[B] = E.words[B];
      return this.length = E.length, this.strip();
    }, S.prototype.ixor = function(y) {
      return $((this.negative | y.negative) === 0), this.iuxor(y);
    }, S.prototype.xor = function(y) {
      return this.length > y.length ? this.clone().ixor(y) : y.clone().ixor(this);
    }, S.prototype.uxor = function(y) {
      return this.length > y.length ? this.clone().iuxor(y) : y.clone().iuxor(this);
    }, S.prototype.inotn = function(y) {
      $(typeof y == "number" && y >= 0);
      var E = Math.ceil(y / 26) | 0, A = y % 26;
      this._expand(E), A > 0 && E--;
      for (var B = 0; B < E; B++)
        this.words[B] = ~this.words[B] & 67108863;
      return A > 0 && (this.words[B] = ~this.words[B] & 67108863 >> 26 - A), this.strip();
    }, S.prototype.notn = function(y) {
      return this.clone().inotn(y);
    }, S.prototype.setn = function(y, E) {
      $(typeof y == "number" && y >= 0);
      var A = y / 26 | 0, B = y % 26;
      return this._expand(A + 1), E ? this.words[A] = this.words[A] | 1 << B : this.words[A] = this.words[A] & ~(1 << B), this.strip();
    }, S.prototype.iadd = function(y) {
      var E;
      if (this.negative !== 0 && y.negative === 0)
        return this.negative = 0, E = this.isub(y), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && y.negative !== 0)
        return y.negative = 0, E = this.isub(y), y.negative = 1, E._normSign();
      var A, B;
      this.length > y.length ? (A = this, B = y) : (A = y, B = this);
      for (var O = 0, C = 0; C < B.length; C++)
        E = (A.words[C] | 0) + (B.words[C] | 0) + O, this.words[C] = E & 67108863, O = E >>> 26;
      for (; O !== 0 && C < A.length; C++)
        E = (A.words[C] | 0) + O, this.words[C] = E & 67108863, O = E >>> 26;
      if (this.length = A.length, O !== 0)
        this.words[this.length] = O, this.length++;
      else if (A !== this)
        for (; C < A.length; C++)
          this.words[C] = A.words[C];
      return this;
    }, S.prototype.add = function(y) {
      var E;
      return y.negative !== 0 && this.negative === 0 ? (y.negative = 0, E = this.sub(y), y.negative ^= 1, E) : y.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = y.sub(this), this.negative = 1, E) : this.length > y.length ? this.clone().iadd(y) : y.clone().iadd(this);
    }, S.prototype.isub = function(y) {
      if (y.negative !== 0) {
        y.negative = 0;
        var E = this.iadd(y);
        return y.negative = 1, E._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(y), this.negative = 1, this._normSign();
      var A = this.cmp(y);
      if (A === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var B, O;
      A > 0 ? (B = this, O = y) : (B = y, O = this);
      for (var C = 0, L = 0; L < O.length; L++)
        E = (B.words[L] | 0) - (O.words[L] | 0) + C, C = E >> 26, this.words[L] = E & 67108863;
      for (; C !== 0 && L < B.length; L++)
        E = (B.words[L] | 0) + C, C = E >> 26, this.words[L] = E & 67108863;
      if (C === 0 && L < B.length && B !== this)
        for (; L < B.length; L++)
          this.words[L] = B.words[L];
      return this.length = Math.max(this.length, L), B !== this && (this.negative = 1), this.strip();
    }, S.prototype.sub = function(y) {
      return this.clone().isub(y);
    };
    function fe(N, y, E) {
      E.negative = y.negative ^ N.negative;
      var A = N.length + y.length | 0;
      E.length = A, A = A - 1 | 0;
      var B = N.words[0] | 0, O = y.words[0] | 0, C = B * O, L = C & 67108863, P = C / 67108864 | 0;
      E.words[0] = L;
      for (var _ = 1; _ < A; _++) {
        for (var I = P >>> 26, U = P & 67108863, Y = Math.min(_, y.length - 1), te = Math.max(0, _ - N.length + 1); te <= Y; te++) {
          var oe = _ - te | 0;
          B = N.words[oe] | 0, O = y.words[te] | 0, C = B * O + U, I += C / 67108864 | 0, U = C & 67108863;
        }
        E.words[_] = U | 0, P = I | 0;
      }
      return P !== 0 ? E.words[_] = P | 0 : E.length--, E.strip();
    }
    var ce = function(y, E, A) {
      var B = y.words, O = E.words, C = A.words, L = 0, P, _, I, U = B[0] | 0, Y = U & 8191, te = U >>> 13, oe = B[1] | 0, re = oe & 8191, ee = oe >>> 13, ae = B[2] | 0, ue = ae & 8191, ye = ae >>> 13, ve = B[3] | 0, he = ve & 8191, Me = ve >>> 13, Qe = B[4] | 0, Ie = Qe & 8191, De = Qe >>> 13, at = B[5] | 0, ke = at & 8191, Se = at >>> 13, lt = B[6] | 0, qe = lt & 8191, He = lt >>> 13, ot = B[7] | 0, be = ot & 8191, _e = ot >>> 13, it = B[8] | 0, Ae = it & 8191, Be = it >>> 13, nt = B[9] | 0, Te = nt & 8191, Ue = nt >>> 13, st = O[0] | 0, Le = st & 8191, Ge = st >>> 13, pt = O[1] | 0, je = pt & 8191, Je = pt >>> 13, dt = O[2] | 0, ze = dt & 8191, et = dt >>> 13, yt = O[3] | 0, Ke = yt & 8191, Ye = yt >>> 13, gt = O[4] | 0, We = gt & 8191, Xe = gt >>> 13, bt = O[5] | 0, se = bt & 8191, J = bt >>> 13, ie = O[6] | 0, le = ie & 8191, we = ie >>> 13, Ce = O[7] | 0, Ee = Ce & 8191, Fe = Ce >>> 13, ut = O[8] | 0, Ne = ut & 8191, Ve = ut >>> 13, ht = O[9] | 0, Ze = ht & 8191, tt = ht >>> 13;
      A.negative = y.negative ^ E.negative, A.length = 19, P = Math.imul(Y, Le), _ = Math.imul(Y, Ge), _ = _ + Math.imul(te, Le) | 0, I = Math.imul(te, Ge);
      var vt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, P = Math.imul(re, Le), _ = Math.imul(re, Ge), _ = _ + Math.imul(ee, Le) | 0, I = Math.imul(ee, Ge), P = P + Math.imul(Y, je) | 0, _ = _ + Math.imul(Y, Je) | 0, _ = _ + Math.imul(te, je) | 0, I = I + Math.imul(te, Je) | 0;
      var mt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, P = Math.imul(ue, Le), _ = Math.imul(ue, Ge), _ = _ + Math.imul(ye, Le) | 0, I = Math.imul(ye, Ge), P = P + Math.imul(re, je) | 0, _ = _ + Math.imul(re, Je) | 0, _ = _ + Math.imul(ee, je) | 0, I = I + Math.imul(ee, Je) | 0, P = P + Math.imul(Y, ze) | 0, _ = _ + Math.imul(Y, et) | 0, _ = _ + Math.imul(te, ze) | 0, I = I + Math.imul(te, et) | 0;
      var wt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, P = Math.imul(he, Le), _ = Math.imul(he, Ge), _ = _ + Math.imul(Me, Le) | 0, I = Math.imul(Me, Ge), P = P + Math.imul(ue, je) | 0, _ = _ + Math.imul(ue, Je) | 0, _ = _ + Math.imul(ye, je) | 0, I = I + Math.imul(ye, Je) | 0, P = P + Math.imul(re, ze) | 0, _ = _ + Math.imul(re, et) | 0, _ = _ + Math.imul(ee, ze) | 0, I = I + Math.imul(ee, et) | 0, P = P + Math.imul(Y, Ke) | 0, _ = _ + Math.imul(Y, Ye) | 0, _ = _ + Math.imul(te, Ke) | 0, I = I + Math.imul(te, Ye) | 0;
      var Mt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, P = Math.imul(Ie, Le), _ = Math.imul(Ie, Ge), _ = _ + Math.imul(De, Le) | 0, I = Math.imul(De, Ge), P = P + Math.imul(he, je) | 0, _ = _ + Math.imul(he, Je) | 0, _ = _ + Math.imul(Me, je) | 0, I = I + Math.imul(Me, Je) | 0, P = P + Math.imul(ue, ze) | 0, _ = _ + Math.imul(ue, et) | 0, _ = _ + Math.imul(ye, ze) | 0, I = I + Math.imul(ye, et) | 0, P = P + Math.imul(re, Ke) | 0, _ = _ + Math.imul(re, Ye) | 0, _ = _ + Math.imul(ee, Ke) | 0, I = I + Math.imul(ee, Ye) | 0, P = P + Math.imul(Y, We) | 0, _ = _ + Math.imul(Y, Xe) | 0, _ = _ + Math.imul(te, We) | 0, I = I + Math.imul(te, Xe) | 0;
      var _t = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, P = Math.imul(ke, Le), _ = Math.imul(ke, Ge), _ = _ + Math.imul(Se, Le) | 0, I = Math.imul(Se, Ge), P = P + Math.imul(Ie, je) | 0, _ = _ + Math.imul(Ie, Je) | 0, _ = _ + Math.imul(De, je) | 0, I = I + Math.imul(De, Je) | 0, P = P + Math.imul(he, ze) | 0, _ = _ + Math.imul(he, et) | 0, _ = _ + Math.imul(Me, ze) | 0, I = I + Math.imul(Me, et) | 0, P = P + Math.imul(ue, Ke) | 0, _ = _ + Math.imul(ue, Ye) | 0, _ = _ + Math.imul(ye, Ke) | 0, I = I + Math.imul(ye, Ye) | 0, P = P + Math.imul(re, We) | 0, _ = _ + Math.imul(re, Xe) | 0, _ = _ + Math.imul(ee, We) | 0, I = I + Math.imul(ee, Xe) | 0, P = P + Math.imul(Y, se) | 0, _ = _ + Math.imul(Y, J) | 0, _ = _ + Math.imul(te, se) | 0, I = I + Math.imul(te, J) | 0;
      var xt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, P = Math.imul(qe, Le), _ = Math.imul(qe, Ge), _ = _ + Math.imul(He, Le) | 0, I = Math.imul(He, Ge), P = P + Math.imul(ke, je) | 0, _ = _ + Math.imul(ke, Je) | 0, _ = _ + Math.imul(Se, je) | 0, I = I + Math.imul(Se, Je) | 0, P = P + Math.imul(Ie, ze) | 0, _ = _ + Math.imul(Ie, et) | 0, _ = _ + Math.imul(De, ze) | 0, I = I + Math.imul(De, et) | 0, P = P + Math.imul(he, Ke) | 0, _ = _ + Math.imul(he, Ye) | 0, _ = _ + Math.imul(Me, Ke) | 0, I = I + Math.imul(Me, Ye) | 0, P = P + Math.imul(ue, We) | 0, _ = _ + Math.imul(ue, Xe) | 0, _ = _ + Math.imul(ye, We) | 0, I = I + Math.imul(ye, Xe) | 0, P = P + Math.imul(re, se) | 0, _ = _ + Math.imul(re, J) | 0, _ = _ + Math.imul(ee, se) | 0, I = I + Math.imul(ee, J) | 0, P = P + Math.imul(Y, le) | 0, _ = _ + Math.imul(Y, we) | 0, _ = _ + Math.imul(te, le) | 0, I = I + Math.imul(te, we) | 0;
      var Et = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, P = Math.imul(be, Le), _ = Math.imul(be, Ge), _ = _ + Math.imul(_e, Le) | 0, I = Math.imul(_e, Ge), P = P + Math.imul(qe, je) | 0, _ = _ + Math.imul(qe, Je) | 0, _ = _ + Math.imul(He, je) | 0, I = I + Math.imul(He, Je) | 0, P = P + Math.imul(ke, ze) | 0, _ = _ + Math.imul(ke, et) | 0, _ = _ + Math.imul(Se, ze) | 0, I = I + Math.imul(Se, et) | 0, P = P + Math.imul(Ie, Ke) | 0, _ = _ + Math.imul(Ie, Ye) | 0, _ = _ + Math.imul(De, Ke) | 0, I = I + Math.imul(De, Ye) | 0, P = P + Math.imul(he, We) | 0, _ = _ + Math.imul(he, Xe) | 0, _ = _ + Math.imul(Me, We) | 0, I = I + Math.imul(Me, Xe) | 0, P = P + Math.imul(ue, se) | 0, _ = _ + Math.imul(ue, J) | 0, _ = _ + Math.imul(ye, se) | 0, I = I + Math.imul(ye, J) | 0, P = P + Math.imul(re, le) | 0, _ = _ + Math.imul(re, we) | 0, _ = _ + Math.imul(ee, le) | 0, I = I + Math.imul(ee, we) | 0, P = P + Math.imul(Y, Ee) | 0, _ = _ + Math.imul(Y, Fe) | 0, _ = _ + Math.imul(te, Ee) | 0, I = I + Math.imul(te, Fe) | 0;
      var St = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, P = Math.imul(Ae, Le), _ = Math.imul(Ae, Ge), _ = _ + Math.imul(Be, Le) | 0, I = Math.imul(Be, Ge), P = P + Math.imul(be, je) | 0, _ = _ + Math.imul(be, Je) | 0, _ = _ + Math.imul(_e, je) | 0, I = I + Math.imul(_e, Je) | 0, P = P + Math.imul(qe, ze) | 0, _ = _ + Math.imul(qe, et) | 0, _ = _ + Math.imul(He, ze) | 0, I = I + Math.imul(He, et) | 0, P = P + Math.imul(ke, Ke) | 0, _ = _ + Math.imul(ke, Ye) | 0, _ = _ + Math.imul(Se, Ke) | 0, I = I + Math.imul(Se, Ye) | 0, P = P + Math.imul(Ie, We) | 0, _ = _ + Math.imul(Ie, Xe) | 0, _ = _ + Math.imul(De, We) | 0, I = I + Math.imul(De, Xe) | 0, P = P + Math.imul(he, se) | 0, _ = _ + Math.imul(he, J) | 0, _ = _ + Math.imul(Me, se) | 0, I = I + Math.imul(Me, J) | 0, P = P + Math.imul(ue, le) | 0, _ = _ + Math.imul(ue, we) | 0, _ = _ + Math.imul(ye, le) | 0, I = I + Math.imul(ye, we) | 0, P = P + Math.imul(re, Ee) | 0, _ = _ + Math.imul(re, Fe) | 0, _ = _ + Math.imul(ee, Ee) | 0, I = I + Math.imul(ee, Fe) | 0, P = P + Math.imul(Y, Ne) | 0, _ = _ + Math.imul(Y, Ve) | 0, _ = _ + Math.imul(te, Ne) | 0, I = I + Math.imul(te, Ve) | 0;
      var $t = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, P = Math.imul(Te, Le), _ = Math.imul(Te, Ge), _ = _ + Math.imul(Ue, Le) | 0, I = Math.imul(Ue, Ge), P = P + Math.imul(Ae, je) | 0, _ = _ + Math.imul(Ae, Je) | 0, _ = _ + Math.imul(Be, je) | 0, I = I + Math.imul(Be, Je) | 0, P = P + Math.imul(be, ze) | 0, _ = _ + Math.imul(be, et) | 0, _ = _ + Math.imul(_e, ze) | 0, I = I + Math.imul(_e, et) | 0, P = P + Math.imul(qe, Ke) | 0, _ = _ + Math.imul(qe, Ye) | 0, _ = _ + Math.imul(He, Ke) | 0, I = I + Math.imul(He, Ye) | 0, P = P + Math.imul(ke, We) | 0, _ = _ + Math.imul(ke, Xe) | 0, _ = _ + Math.imul(Se, We) | 0, I = I + Math.imul(Se, Xe) | 0, P = P + Math.imul(Ie, se) | 0, _ = _ + Math.imul(Ie, J) | 0, _ = _ + Math.imul(De, se) | 0, I = I + Math.imul(De, J) | 0, P = P + Math.imul(he, le) | 0, _ = _ + Math.imul(he, we) | 0, _ = _ + Math.imul(Me, le) | 0, I = I + Math.imul(Me, we) | 0, P = P + Math.imul(ue, Ee) | 0, _ = _ + Math.imul(ue, Fe) | 0, _ = _ + Math.imul(ye, Ee) | 0, I = I + Math.imul(ye, Fe) | 0, P = P + Math.imul(re, Ne) | 0, _ = _ + Math.imul(re, Ve) | 0, _ = _ + Math.imul(ee, Ne) | 0, I = I + Math.imul(ee, Ve) | 0, P = P + Math.imul(Y, Ze) | 0, _ = _ + Math.imul(Y, tt) | 0, _ = _ + Math.imul(te, Ze) | 0, I = I + Math.imul(te, tt) | 0;
      var At = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, P = Math.imul(Te, je), _ = Math.imul(Te, Je), _ = _ + Math.imul(Ue, je) | 0, I = Math.imul(Ue, Je), P = P + Math.imul(Ae, ze) | 0, _ = _ + Math.imul(Ae, et) | 0, _ = _ + Math.imul(Be, ze) | 0, I = I + Math.imul(Be, et) | 0, P = P + Math.imul(be, Ke) | 0, _ = _ + Math.imul(be, Ye) | 0, _ = _ + Math.imul(_e, Ke) | 0, I = I + Math.imul(_e, Ye) | 0, P = P + Math.imul(qe, We) | 0, _ = _ + Math.imul(qe, Xe) | 0, _ = _ + Math.imul(He, We) | 0, I = I + Math.imul(He, Xe) | 0, P = P + Math.imul(ke, se) | 0, _ = _ + Math.imul(ke, J) | 0, _ = _ + Math.imul(Se, se) | 0, I = I + Math.imul(Se, J) | 0, P = P + Math.imul(Ie, le) | 0, _ = _ + Math.imul(Ie, we) | 0, _ = _ + Math.imul(De, le) | 0, I = I + Math.imul(De, we) | 0, P = P + Math.imul(he, Ee) | 0, _ = _ + Math.imul(he, Fe) | 0, _ = _ + Math.imul(Me, Ee) | 0, I = I + Math.imul(Me, Fe) | 0, P = P + Math.imul(ue, Ne) | 0, _ = _ + Math.imul(ue, Ve) | 0, _ = _ + Math.imul(ye, Ne) | 0, I = I + Math.imul(ye, Ve) | 0, P = P + Math.imul(re, Ze) | 0, _ = _ + Math.imul(re, tt) | 0, _ = _ + Math.imul(ee, Ze) | 0, I = I + Math.imul(ee, tt) | 0;
      var Rt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, P = Math.imul(Te, ze), _ = Math.imul(Te, et), _ = _ + Math.imul(Ue, ze) | 0, I = Math.imul(Ue, et), P = P + Math.imul(Ae, Ke) | 0, _ = _ + Math.imul(Ae, Ye) | 0, _ = _ + Math.imul(Be, Ke) | 0, I = I + Math.imul(Be, Ye) | 0, P = P + Math.imul(be, We) | 0, _ = _ + Math.imul(be, Xe) | 0, _ = _ + Math.imul(_e, We) | 0, I = I + Math.imul(_e, Xe) | 0, P = P + Math.imul(qe, se) | 0, _ = _ + Math.imul(qe, J) | 0, _ = _ + Math.imul(He, se) | 0, I = I + Math.imul(He, J) | 0, P = P + Math.imul(ke, le) | 0, _ = _ + Math.imul(ke, we) | 0, _ = _ + Math.imul(Se, le) | 0, I = I + Math.imul(Se, we) | 0, P = P + Math.imul(Ie, Ee) | 0, _ = _ + Math.imul(Ie, Fe) | 0, _ = _ + Math.imul(De, Ee) | 0, I = I + Math.imul(De, Fe) | 0, P = P + Math.imul(he, Ne) | 0, _ = _ + Math.imul(he, Ve) | 0, _ = _ + Math.imul(Me, Ne) | 0, I = I + Math.imul(Me, Ve) | 0, P = P + Math.imul(ue, Ze) | 0, _ = _ + Math.imul(ue, tt) | 0, _ = _ + Math.imul(ye, Ze) | 0, I = I + Math.imul(ye, tt) | 0;
      var Bt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, P = Math.imul(Te, Ke), _ = Math.imul(Te, Ye), _ = _ + Math.imul(Ue, Ke) | 0, I = Math.imul(Ue, Ye), P = P + Math.imul(Ae, We) | 0, _ = _ + Math.imul(Ae, Xe) | 0, _ = _ + Math.imul(Be, We) | 0, I = I + Math.imul(Be, Xe) | 0, P = P + Math.imul(be, se) | 0, _ = _ + Math.imul(be, J) | 0, _ = _ + Math.imul(_e, se) | 0, I = I + Math.imul(_e, J) | 0, P = P + Math.imul(qe, le) | 0, _ = _ + Math.imul(qe, we) | 0, _ = _ + Math.imul(He, le) | 0, I = I + Math.imul(He, we) | 0, P = P + Math.imul(ke, Ee) | 0, _ = _ + Math.imul(ke, Fe) | 0, _ = _ + Math.imul(Se, Ee) | 0, I = I + Math.imul(Se, Fe) | 0, P = P + Math.imul(Ie, Ne) | 0, _ = _ + Math.imul(Ie, Ve) | 0, _ = _ + Math.imul(De, Ne) | 0, I = I + Math.imul(De, Ve) | 0, P = P + Math.imul(he, Ze) | 0, _ = _ + Math.imul(he, tt) | 0, _ = _ + Math.imul(Me, Ze) | 0, I = I + Math.imul(Me, tt) | 0;
      var Tt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, P = Math.imul(Te, We), _ = Math.imul(Te, Xe), _ = _ + Math.imul(Ue, We) | 0, I = Math.imul(Ue, Xe), P = P + Math.imul(Ae, se) | 0, _ = _ + Math.imul(Ae, J) | 0, _ = _ + Math.imul(Be, se) | 0, I = I + Math.imul(Be, J) | 0, P = P + Math.imul(be, le) | 0, _ = _ + Math.imul(be, we) | 0, _ = _ + Math.imul(_e, le) | 0, I = I + Math.imul(_e, we) | 0, P = P + Math.imul(qe, Ee) | 0, _ = _ + Math.imul(qe, Fe) | 0, _ = _ + Math.imul(He, Ee) | 0, I = I + Math.imul(He, Fe) | 0, P = P + Math.imul(ke, Ne) | 0, _ = _ + Math.imul(ke, Ve) | 0, _ = _ + Math.imul(Se, Ne) | 0, I = I + Math.imul(Se, Ve) | 0, P = P + Math.imul(Ie, Ze) | 0, _ = _ + Math.imul(Ie, tt) | 0, _ = _ + Math.imul(De, Ze) | 0, I = I + Math.imul(De, tt) | 0;
      var Pt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, P = Math.imul(Te, se), _ = Math.imul(Te, J), _ = _ + Math.imul(Ue, se) | 0, I = Math.imul(Ue, J), P = P + Math.imul(Ae, le) | 0, _ = _ + Math.imul(Ae, we) | 0, _ = _ + Math.imul(Be, le) | 0, I = I + Math.imul(Be, we) | 0, P = P + Math.imul(be, Ee) | 0, _ = _ + Math.imul(be, Fe) | 0, _ = _ + Math.imul(_e, Ee) | 0, I = I + Math.imul(_e, Fe) | 0, P = P + Math.imul(qe, Ne) | 0, _ = _ + Math.imul(qe, Ve) | 0, _ = _ + Math.imul(He, Ne) | 0, I = I + Math.imul(He, Ve) | 0, P = P + Math.imul(ke, Ze) | 0, _ = _ + Math.imul(ke, tt) | 0, _ = _ + Math.imul(Se, Ze) | 0, I = I + Math.imul(Se, tt) | 0;
      var It = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, P = Math.imul(Te, le), _ = Math.imul(Te, we), _ = _ + Math.imul(Ue, le) | 0, I = Math.imul(Ue, we), P = P + Math.imul(Ae, Ee) | 0, _ = _ + Math.imul(Ae, Fe) | 0, _ = _ + Math.imul(Be, Ee) | 0, I = I + Math.imul(Be, Fe) | 0, P = P + Math.imul(be, Ne) | 0, _ = _ + Math.imul(be, Ve) | 0, _ = _ + Math.imul(_e, Ne) | 0, I = I + Math.imul(_e, Ve) | 0, P = P + Math.imul(qe, Ze) | 0, _ = _ + Math.imul(qe, tt) | 0, _ = _ + Math.imul(He, Ze) | 0, I = I + Math.imul(He, tt) | 0;
      var Ot = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, P = Math.imul(Te, Ee), _ = Math.imul(Te, Fe), _ = _ + Math.imul(Ue, Ee) | 0, I = Math.imul(Ue, Fe), P = P + Math.imul(Ae, Ne) | 0, _ = _ + Math.imul(Ae, Ve) | 0, _ = _ + Math.imul(Be, Ne) | 0, I = I + Math.imul(Be, Ve) | 0, P = P + Math.imul(be, Ze) | 0, _ = _ + Math.imul(be, tt) | 0, _ = _ + Math.imul(_e, Ze) | 0, I = I + Math.imul(_e, tt) | 0;
      var Ct = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, P = Math.imul(Te, Ne), _ = Math.imul(Te, Ve), _ = _ + Math.imul(Ue, Ne) | 0, I = Math.imul(Ue, Ve), P = P + Math.imul(Ae, Ze) | 0, _ = _ + Math.imul(Ae, tt) | 0, _ = _ + Math.imul(Be, Ze) | 0, I = I + Math.imul(Be, tt) | 0;
      var Dt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, P = Math.imul(Te, Ze), _ = Math.imul(Te, tt), _ = _ + Math.imul(Ue, Ze) | 0, I = Math.imul(Ue, tt);
      var kt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      return L = (I + (_ >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, C[0] = vt, C[1] = mt, C[2] = wt, C[3] = Mt, C[4] = _t, C[5] = xt, C[6] = Et, C[7] = St, C[8] = $t, C[9] = At, C[10] = Rt, C[11] = Bt, C[12] = Tt, C[13] = Pt, C[14] = It, C[15] = Ot, C[16] = Ct, C[17] = Dt, C[18] = kt, L !== 0 && (C[19] = L, A.length++), A;
    };
    Math.imul || (ce = fe);
    function me(N, y, E) {
      E.negative = y.negative ^ N.negative, E.length = N.length + y.length;
      for (var A = 0, B = 0, O = 0; O < E.length - 1; O++) {
        var C = B;
        B = 0;
        for (var L = A & 67108863, P = Math.min(O, y.length - 1), _ = Math.max(0, O - N.length + 1); _ <= P; _++) {
          var I = O - _, U = N.words[I] | 0, Y = y.words[_] | 0, te = U * Y, oe = te & 67108863;
          C = C + (te / 67108864 | 0) | 0, oe = oe + L | 0, L = oe & 67108863, C = C + (oe >>> 26) | 0, B += C >>> 26, C &= 67108863;
        }
        E.words[O] = L, A = C, C = B;
      }
      return A !== 0 ? E.words[O] = A : E.length--, E.strip();
    }
    function de(N, y, E) {
      var A = new ne();
      return A.mulp(N, y, E);
    }
    S.prototype.mulTo = function(y, E) {
      var A, B = this.length + y.length;
      return this.length === 10 && y.length === 10 ? A = ce(this, y, E) : B < 63 ? A = fe(this, y, E) : B < 1024 ? A = me(this, y, E) : A = de(this, y, E), A;
    };
    function ne(N, y) {
      this.x = N, this.y = y;
    }
    ne.prototype.makeRBT = function(y) {
      for (var E = new Array(y), A = S.prototype._countBits(y) - 1, B = 0; B < y; B++)
        E[B] = this.revBin(B, A, y);
      return E;
    }, ne.prototype.revBin = function(y, E, A) {
      if (y === 0 || y === A - 1) return y;
      for (var B = 0, O = 0; O < E; O++)
        B |= (y & 1) << E - O - 1, y >>= 1;
      return B;
    }, ne.prototype.permute = function(y, E, A, B, O, C) {
      for (var L = 0; L < C; L++)
        B[L] = E[y[L]], O[L] = A[y[L]];
    }, ne.prototype.transform = function(y, E, A, B, O, C) {
      this.permute(C, y, E, A, B, O);
      for (var L = 1; L < O; L <<= 1)
        for (var P = L << 1, _ = Math.cos(2 * Math.PI / P), I = Math.sin(2 * Math.PI / P), U = 0; U < O; U += P)
          for (var Y = _, te = I, oe = 0; oe < L; oe++) {
            var re = A[U + oe], ee = B[U + oe], ae = A[U + oe + L], ue = B[U + oe + L], ye = Y * ae - te * ue;
            ue = Y * ue + te * ae, ae = ye, A[U + oe] = re + ae, B[U + oe] = ee + ue, A[U + oe + L] = re - ae, B[U + oe + L] = ee - ue, oe !== P && (ye = _ * Y - I * te, te = _ * te + I * Y, Y = ye);
          }
    }, ne.prototype.guessLen13b = function(y, E) {
      var A = Math.max(E, y) | 1, B = A & 1, O = 0;
      for (A = A / 2 | 0; A; A = A >>> 1)
        O++;
      return 1 << O + 1 + B;
    }, ne.prototype.conjugate = function(y, E, A) {
      if (!(A <= 1))
        for (var B = 0; B < A / 2; B++) {
          var O = y[B];
          y[B] = y[A - B - 1], y[A - B - 1] = O, O = E[B], E[B] = -E[A - B - 1], E[A - B - 1] = -O;
        }
    }, ne.prototype.normalize13b = function(y, E) {
      for (var A = 0, B = 0; B < E / 2; B++) {
        var O = Math.round(y[2 * B + 1] / E) * 8192 + Math.round(y[2 * B] / E) + A;
        y[B] = O & 67108863, O < 67108864 ? A = 0 : A = O / 67108864 | 0;
      }
      return y;
    }, ne.prototype.convert13b = function(y, E, A, B) {
      for (var O = 0, C = 0; C < E; C++)
        O = O + (y[C] | 0), A[2 * C] = O & 8191, O = O >>> 13, A[2 * C + 1] = O & 8191, O = O >>> 13;
      for (C = 2 * E; C < B; ++C)
        A[C] = 0;
      $(O === 0), $((O & -8192) === 0);
    }, ne.prototype.stub = function(y) {
      for (var E = new Array(y), A = 0; A < y; A++)
        E[A] = 0;
      return E;
    }, ne.prototype.mulp = function(y, E, A) {
      var B = 2 * this.guessLen13b(y.length, E.length), O = this.makeRBT(B), C = this.stub(B), L = new Array(B), P = new Array(B), _ = new Array(B), I = new Array(B), U = new Array(B), Y = new Array(B), te = A.words;
      te.length = B, this.convert13b(y.words, y.length, L, B), this.convert13b(E.words, E.length, I, B), this.transform(L, C, P, _, B, O), this.transform(I, C, U, Y, B, O);
      for (var oe = 0; oe < B; oe++) {
        var re = P[oe] * U[oe] - _[oe] * Y[oe];
        _[oe] = P[oe] * Y[oe] + _[oe] * U[oe], P[oe] = re;
      }
      return this.conjugate(P, _, B), this.transform(P, _, te, C, B, O), this.conjugate(te, C, B), this.normalize13b(te, B), A.negative = y.negative ^ E.negative, A.length = y.length + E.length, A.strip();
    }, S.prototype.mul = function(y) {
      var E = new S(null);
      return E.words = new Array(this.length + y.length), this.mulTo(y, E);
    }, S.prototype.mulf = function(y) {
      var E = new S(null);
      return E.words = new Array(this.length + y.length), de(this, y, E);
    }, S.prototype.imul = function(y) {
      return this.clone().mulTo(y, this);
    }, S.prototype.imuln = function(y) {
      $(typeof y == "number"), $(y < 67108864);
      for (var E = 0, A = 0; A < this.length; A++) {
        var B = (this.words[A] | 0) * y, O = (B & 67108863) + (E & 67108863);
        E >>= 26, E += B / 67108864 | 0, E += O >>> 26, this.words[A] = O & 67108863;
      }
      return E !== 0 && (this.words[A] = E, this.length++), this.length = y === 0 ? 1 : this.length, this;
    }, S.prototype.muln = function(y) {
      return this.clone().imuln(y);
    }, S.prototype.sqr = function() {
      return this.mul(this);
    }, S.prototype.isqr = function() {
      return this.imul(this.clone());
    }, S.prototype.pow = function(y) {
      var E = Q(y);
      if (E.length === 0) return new S(1);
      for (var A = this, B = 0; B < E.length && E[B] === 0; B++, A = A.sqr())
        ;
      if (++B < E.length)
        for (var O = A.sqr(); B < E.length; B++, O = O.sqr())
          E[B] !== 0 && (A = A.mul(O));
      return A;
    }, S.prototype.iushln = function(y) {
      $(typeof y == "number" && y >= 0);
      var E = y % 26, A = (y - E) / 26, B = 67108863 >>> 26 - E << 26 - E, O;
      if (E !== 0) {
        var C = 0;
        for (O = 0; O < this.length; O++) {
          var L = this.words[O] & B, P = (this.words[O] | 0) - L << E;
          this.words[O] = P | C, C = L >>> 26 - E;
        }
        C && (this.words[O] = C, this.length++);
      }
      if (A !== 0) {
        for (O = this.length - 1; O >= 0; O--)
          this.words[O + A] = this.words[O];
        for (O = 0; O < A; O++)
          this.words[O] = 0;
        this.length += A;
      }
      return this.strip();
    }, S.prototype.ishln = function(y) {
      return $(this.negative === 0), this.iushln(y);
    }, S.prototype.iushrn = function(y, E, A) {
      $(typeof y == "number" && y >= 0);
      var B;
      E ? B = (E - E % 26) / 26 : B = 0;
      var O = y % 26, C = Math.min((y - O) / 26, this.length), L = 67108863 ^ 67108863 >>> O << O, P = A;
      if (B -= C, B = Math.max(0, B), P) {
        for (var _ = 0; _ < C; _++)
          P.words[_] = this.words[_];
        P.length = C;
      }
      if (C !== 0) if (this.length > C)
        for (this.length -= C, _ = 0; _ < this.length; _++)
          this.words[_] = this.words[_ + C];
      else
        this.words[0] = 0, this.length = 1;
      var I = 0;
      for (_ = this.length - 1; _ >= 0 && (I !== 0 || _ >= B); _--) {
        var U = this.words[_] | 0;
        this.words[_] = I << 26 - O | U >>> O, I = U & L;
      }
      return P && I !== 0 && (P.words[P.length++] = I), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, S.prototype.ishrn = function(y, E, A) {
      return $(this.negative === 0), this.iushrn(y, E, A);
    }, S.prototype.shln = function(y) {
      return this.clone().ishln(y);
    }, S.prototype.ushln = function(y) {
      return this.clone().iushln(y);
    }, S.prototype.shrn = function(y) {
      return this.clone().ishrn(y);
    }, S.prototype.ushrn = function(y) {
      return this.clone().iushrn(y);
    }, S.prototype.testn = function(y) {
      $(typeof y == "number" && y >= 0);
      var E = y % 26, A = (y - E) / 26, B = 1 << E;
      if (this.length <= A) return !1;
      var O = this.words[A];
      return !!(O & B);
    }, S.prototype.imaskn = function(y) {
      $(typeof y == "number" && y >= 0);
      var E = y % 26, A = (y - E) / 26;
      if ($(this.negative === 0, "imaskn works only with positive numbers"), this.length <= A)
        return this;
      if (E !== 0 && A++, this.length = Math.min(A, this.length), E !== 0) {
        var B = 67108863 ^ 67108863 >>> E << E;
        this.words[this.length - 1] &= B;
      }
      return this.strip();
    }, S.prototype.maskn = function(y) {
      return this.clone().imaskn(y);
    }, S.prototype.iaddn = function(y) {
      return $(typeof y == "number"), $(y < 67108864), y < 0 ? this.isubn(-y) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < y ? (this.words[0] = y - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(y), this.negative = 1, this) : this._iaddn(y);
    }, S.prototype._iaddn = function(y) {
      this.words[0] += y;
      for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
        this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
      return this.length = Math.max(this.length, E + 1), this;
    }, S.prototype.isubn = function(y) {
      if ($(typeof y == "number"), $(y < 67108864), y < 0) return this.iaddn(-y);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(y), this.negative = 1, this;
      if (this.words[0] -= y, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var E = 0; E < this.length && this.words[E] < 0; E++)
          this.words[E] += 67108864, this.words[E + 1] -= 1;
      return this.strip();
    }, S.prototype.addn = function(y) {
      return this.clone().iaddn(y);
    }, S.prototype.subn = function(y) {
      return this.clone().isubn(y);
    }, S.prototype.iabs = function() {
      return this.negative = 0, this;
    }, S.prototype.abs = function() {
      return this.clone().iabs();
    }, S.prototype._ishlnsubmul = function(y, E, A) {
      var B = y.length + A, O;
      this._expand(B);
      var C, L = 0;
      for (O = 0; O < y.length; O++) {
        C = (this.words[O + A] | 0) + L;
        var P = (y.words[O] | 0) * E;
        C -= P & 67108863, L = (C >> 26) - (P / 67108864 | 0), this.words[O + A] = C & 67108863;
      }
      for (; O < this.length - A; O++)
        C = (this.words[O + A] | 0) + L, L = C >> 26, this.words[O + A] = C & 67108863;
      if (L === 0) return this.strip();
      for ($(L === -1), L = 0, O = 0; O < this.length; O++)
        C = -(this.words[O] | 0) + L, L = C >> 26, this.words[O] = C & 67108863;
      return this.negative = 1, this.strip();
    }, S.prototype._wordDiv = function(y, E) {
      var A = this.length - y.length, B = this.clone(), O = y, C = O.words[O.length - 1] | 0, L = this._countBits(C);
      A = 26 - L, A !== 0 && (O = O.ushln(A), B.iushln(A), C = O.words[O.length - 1] | 0);
      var P = B.length - O.length, _;
      if (E !== "mod") {
        _ = new S(null), _.length = P + 1, _.words = new Array(_.length);
        for (var I = 0; I < _.length; I++)
          _.words[I] = 0;
      }
      var U = B.clone()._ishlnsubmul(O, 1, P);
      U.negative === 0 && (B = U, _ && (_.words[P] = 1));
      for (var Y = P - 1; Y >= 0; Y--) {
        var te = (B.words[O.length + Y] | 0) * 67108864 + (B.words[O.length + Y - 1] | 0);
        for (te = Math.min(te / C | 0, 67108863), B._ishlnsubmul(O, te, Y); B.negative !== 0; )
          te--, B.negative = 0, B._ishlnsubmul(O, 1, Y), B.isZero() || (B.negative ^= 1);
        _ && (_.words[Y] = te);
      }
      return _ && _.strip(), B.strip(), E !== "div" && A !== 0 && B.iushrn(A), {
        div: _ || null,
        mod: B
      };
    }, S.prototype.divmod = function(y, E, A) {
      if ($(!y.isZero()), this.isZero())
        return {
          div: new S(0),
          mod: new S(0)
        };
      var B, O, C;
      return this.negative !== 0 && y.negative === 0 ? (C = this.neg().divmod(y, E), E !== "mod" && (B = C.div.neg()), E !== "div" && (O = C.mod.neg(), A && O.negative !== 0 && O.iadd(y)), {
        div: B,
        mod: O
      }) : this.negative === 0 && y.negative !== 0 ? (C = this.divmod(y.neg(), E), E !== "mod" && (B = C.div.neg()), {
        div: B,
        mod: C.mod
      }) : this.negative & y.negative ? (C = this.neg().divmod(y.neg(), E), E !== "div" && (O = C.mod.neg(), A && O.negative !== 0 && O.isub(y)), {
        div: C.div,
        mod: O
      }) : y.length > this.length || this.cmp(y) < 0 ? {
        div: new S(0),
        mod: this
      } : y.length === 1 ? E === "div" ? {
        div: this.divn(y.words[0]),
        mod: null
      } : E === "mod" ? {
        div: null,
        mod: new S(this.modn(y.words[0]))
      } : {
        div: this.divn(y.words[0]),
        mod: new S(this.modn(y.words[0]))
      } : this._wordDiv(y, E);
    }, S.prototype.div = function(y) {
      return this.divmod(y, "div", !1).div;
    }, S.prototype.mod = function(y) {
      return this.divmod(y, "mod", !1).mod;
    }, S.prototype.umod = function(y) {
      return this.divmod(y, "mod", !0).mod;
    }, S.prototype.divRound = function(y) {
      var E = this.divmod(y);
      if (E.mod.isZero()) return E.div;
      var A = E.div.negative !== 0 ? E.mod.isub(y) : E.mod, B = y.ushrn(1), O = y.andln(1), C = A.cmp(B);
      return C < 0 || O === 1 && C === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
    }, S.prototype.modn = function(y) {
      $(y <= 67108863);
      for (var E = (1 << 26) % y, A = 0, B = this.length - 1; B >= 0; B--)
        A = (E * A + (this.words[B] | 0)) % y;
      return A;
    }, S.prototype.idivn = function(y) {
      $(y <= 67108863);
      for (var E = 0, A = this.length - 1; A >= 0; A--) {
        var B = (this.words[A] | 0) + E * 67108864;
        this.words[A] = B / y | 0, E = B % y;
      }
      return this.strip();
    }, S.prototype.divn = function(y) {
      return this.clone().idivn(y);
    }, S.prototype.egcd = function(y) {
      $(y.negative === 0), $(!y.isZero());
      var E = this, A = y.clone();
      E.negative !== 0 ? E = E.umod(y) : E = E.clone();
      for (var B = new S(1), O = new S(0), C = new S(0), L = new S(1), P = 0; E.isEven() && A.isEven(); )
        E.iushrn(1), A.iushrn(1), ++P;
      for (var _ = A.clone(), I = E.clone(); !E.isZero(); ) {
        for (var U = 0, Y = 1; !(E.words[0] & Y) && U < 26; ++U, Y <<= 1) ;
        if (U > 0)
          for (E.iushrn(U); U-- > 0; )
            (B.isOdd() || O.isOdd()) && (B.iadd(_), O.isub(I)), B.iushrn(1), O.iushrn(1);
        for (var te = 0, oe = 1; !(A.words[0] & oe) && te < 26; ++te, oe <<= 1) ;
        if (te > 0)
          for (A.iushrn(te); te-- > 0; )
            (C.isOdd() || L.isOdd()) && (C.iadd(_), L.isub(I)), C.iushrn(1), L.iushrn(1);
        E.cmp(A) >= 0 ? (E.isub(A), B.isub(C), O.isub(L)) : (A.isub(E), C.isub(B), L.isub(O));
      }
      return {
        a: C,
        b: L,
        gcd: A.iushln(P)
      };
    }, S.prototype._invmp = function(y) {
      $(y.negative === 0), $(!y.isZero());
      var E = this, A = y.clone();
      E.negative !== 0 ? E = E.umod(y) : E = E.clone();
      for (var B = new S(1), O = new S(0), C = A.clone(); E.cmpn(1) > 0 && A.cmpn(1) > 0; ) {
        for (var L = 0, P = 1; !(E.words[0] & P) && L < 26; ++L, P <<= 1) ;
        if (L > 0)
          for (E.iushrn(L); L-- > 0; )
            B.isOdd() && B.iadd(C), B.iushrn(1);
        for (var _ = 0, I = 1; !(A.words[0] & I) && _ < 26; ++_, I <<= 1) ;
        if (_ > 0)
          for (A.iushrn(_); _-- > 0; )
            O.isOdd() && O.iadd(C), O.iushrn(1);
        E.cmp(A) >= 0 ? (E.isub(A), B.isub(O)) : (A.isub(E), O.isub(B));
      }
      var U;
      return E.cmpn(1) === 0 ? U = B : U = O, U.cmpn(0) < 0 && U.iadd(y), U;
    }, S.prototype.gcd = function(y) {
      if (this.isZero()) return y.abs();
      if (y.isZero()) return this.abs();
      var E = this.clone(), A = y.clone();
      E.negative = 0, A.negative = 0;
      for (var B = 0; E.isEven() && A.isEven(); B++)
        E.iushrn(1), A.iushrn(1);
      do {
        for (; E.isEven(); )
          E.iushrn(1);
        for (; A.isEven(); )
          A.iushrn(1);
        var O = E.cmp(A);
        if (O < 0) {
          var C = E;
          E = A, A = C;
        } else if (O === 0 || A.cmpn(1) === 0)
          break;
        E.isub(A);
      } while (!0);
      return A.iushln(B);
    }, S.prototype.invm = function(y) {
      return this.egcd(y).a.umod(y);
    }, S.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, S.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, S.prototype.andln = function(y) {
      return this.words[0] & y;
    }, S.prototype.bincn = function(y) {
      $(typeof y == "number");
      var E = y % 26, A = (y - E) / 26, B = 1 << E;
      if (this.length <= A)
        return this._expand(A + 1), this.words[A] |= B, this;
      for (var O = B, C = A; O !== 0 && C < this.length; C++) {
        var L = this.words[C] | 0;
        L += O, O = L >>> 26, L &= 67108863, this.words[C] = L;
      }
      return O !== 0 && (this.words[C] = O, this.length++), this;
    }, S.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, S.prototype.cmpn = function(y) {
      var E = y < 0;
      if (this.negative !== 0 && !E) return -1;
      if (this.negative === 0 && E) return 1;
      this.strip();
      var A;
      if (this.length > 1)
        A = 1;
      else {
        E && (y = -y), $(y <= 67108863, "Number is too big");
        var B = this.words[0] | 0;
        A = B === y ? 0 : B < y ? -1 : 1;
      }
      return this.negative !== 0 ? -A | 0 : A;
    }, S.prototype.cmp = function(y) {
      if (this.negative !== 0 && y.negative === 0) return -1;
      if (this.negative === 0 && y.negative !== 0) return 1;
      var E = this.ucmp(y);
      return this.negative !== 0 ? -E | 0 : E;
    }, S.prototype.ucmp = function(y) {
      if (this.length > y.length) return 1;
      if (this.length < y.length) return -1;
      for (var E = 0, A = this.length - 1; A >= 0; A--) {
        var B = this.words[A] | 0, O = y.words[A] | 0;
        if (B !== O) {
          B < O ? E = -1 : B > O && (E = 1);
          break;
        }
      }
      return E;
    }, S.prototype.gtn = function(y) {
      return this.cmpn(y) === 1;
    }, S.prototype.gt = function(y) {
      return this.cmp(y) === 1;
    }, S.prototype.gten = function(y) {
      return this.cmpn(y) >= 0;
    }, S.prototype.gte = function(y) {
      return this.cmp(y) >= 0;
    }, S.prototype.ltn = function(y) {
      return this.cmpn(y) === -1;
    }, S.prototype.lt = function(y) {
      return this.cmp(y) === -1;
    }, S.prototype.lten = function(y) {
      return this.cmpn(y) <= 0;
    }, S.prototype.lte = function(y) {
      return this.cmp(y) <= 0;
    }, S.prototype.eqn = function(y) {
      return this.cmpn(y) === 0;
    }, S.prototype.eq = function(y) {
      return this.cmp(y) === 0;
    }, S.red = function(y) {
      return new xe(y);
    }, S.prototype.toRed = function(y) {
      return $(!this.red, "Already a number in reduction context"), $(this.negative === 0, "red works only with positives"), y.convertTo(this)._forceRed(y);
    }, S.prototype.fromRed = function() {
      return $(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, S.prototype._forceRed = function(y) {
      return this.red = y, this;
    }, S.prototype.forceRed = function(y) {
      return $(!this.red, "Already a number in reduction context"), this._forceRed(y);
    }, S.prototype.redAdd = function(y) {
      return $(this.red, "redAdd works only with red numbers"), this.red.add(this, y);
    }, S.prototype.redIAdd = function(y) {
      return $(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, y);
    }, S.prototype.redSub = function(y) {
      return $(this.red, "redSub works only with red numbers"), this.red.sub(this, y);
    }, S.prototype.redISub = function(y) {
      return $(this.red, "redISub works only with red numbers"), this.red.isub(this, y);
    }, S.prototype.redShl = function(y) {
      return $(this.red, "redShl works only with red numbers"), this.red.shl(this, y);
    }, S.prototype.redMul = function(y) {
      return $(this.red, "redMul works only with red numbers"), this.red._verify2(this, y), this.red.mul(this, y);
    }, S.prototype.redIMul = function(y) {
      return $(this.red, "redMul works only with red numbers"), this.red._verify2(this, y), this.red.imul(this, y);
    }, S.prototype.redSqr = function() {
      return $(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, S.prototype.redISqr = function() {
      return $(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, S.prototype.redSqrt = function() {
      return $(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, S.prototype.redInvm = function() {
      return $(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, S.prototype.redNeg = function() {
      return $(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, S.prototype.redPow = function(y) {
      return $(this.red && !y.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, y);
    };
    var ge = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function pe(N, y) {
      this.name = N, this.p = new S(y, 16), this.n = this.p.bitLength(), this.k = new S(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    pe.prototype._tmp = function() {
      var y = new S(null);
      return y.words = new Array(Math.ceil(this.n / 13)), y;
    }, pe.prototype.ireduce = function(y) {
      var E = y, A;
      do
        this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), A = E.bitLength();
      while (A > this.n);
      var B = A < this.n ? -1 : E.ucmp(this.p);
      return B === 0 ? (E.words[0] = 0, E.length = 1) : B > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
    }, pe.prototype.split = function(y, E) {
      y.iushrn(this.n, 0, E);
    }, pe.prototype.imulK = function(y) {
      return y.imul(this.k);
    };
    function $e() {
      pe.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    T($e, pe), $e.prototype.split = function(y, E) {
      for (var A = 4194303, B = Math.min(y.length, 9), O = 0; O < B; O++)
        E.words[O] = y.words[O];
      if (E.length = B, y.length <= 9) {
        y.words[0] = 0, y.length = 1;
        return;
      }
      var C = y.words[9];
      for (E.words[E.length++] = C & A, O = 10; O < y.length; O++) {
        var L = y.words[O] | 0;
        y.words[O - 10] = (L & A) << 4 | C >>> 22, C = L;
      }
      C >>>= 22, y.words[O - 10] = C, C === 0 && y.length > 10 ? y.length -= 10 : y.length -= 9;
    }, $e.prototype.imulK = function(y) {
      y.words[y.length] = 0, y.words[y.length + 1] = 0, y.length += 2;
      for (var E = 0, A = 0; A < y.length; A++) {
        var B = y.words[A] | 0;
        E += B * 977, y.words[A] = E & 67108863, E = B * 64 + (E / 67108864 | 0);
      }
      return y.words[y.length - 1] === 0 && (y.length--, y.words[y.length - 1] === 0 && y.length--), y;
    };
    function Re() {
      pe.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    T(Re, pe);
    function Pe() {
      pe.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    T(Pe, pe);
    function Oe() {
      pe.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    T(Oe, pe), Oe.prototype.imulK = function(y) {
      for (var E = 0, A = 0; A < y.length; A++) {
        var B = (y.words[A] | 0) * 19 + E, O = B & 67108863;
        B >>>= 26, y.words[A] = O, E = B;
      }
      return E !== 0 && (y.words[y.length++] = E), y;
    }, S._prime = function(y) {
      if (ge[y]) return ge[y];
      var E;
      if (y === "k256")
        E = new $e();
      else if (y === "p224")
        E = new Re();
      else if (y === "p192")
        E = new Pe();
      else if (y === "p25519")
        E = new Oe();
      else
        throw new Error("Unknown prime " + y);
      return ge[y] = E, E;
    };
    function xe(N) {
      if (typeof N == "string") {
        var y = S._prime(N);
        this.m = y.p, this.prime = y;
      } else
        $(N.gtn(1), "modulus must be greater than 1"), this.m = N, this.prime = null;
    }
    xe.prototype._verify1 = function(y) {
      $(y.negative === 0, "red works only with positives"), $(y.red, "red works only with red numbers");
    }, xe.prototype._verify2 = function(y, E) {
      $((y.negative | E.negative) === 0, "red works only with positives"), $(
        y.red && y.red === E.red,
        "red works only with red numbers"
      );
    }, xe.prototype.imod = function(y) {
      return this.prime ? this.prime.ireduce(y)._forceRed(this) : y.umod(this.m)._forceRed(this);
    }, xe.prototype.neg = function(y) {
      return y.isZero() ? y.clone() : this.m.sub(y)._forceRed(this);
    }, xe.prototype.add = function(y, E) {
      this._verify2(y, E);
      var A = y.add(E);
      return A.cmp(this.m) >= 0 && A.isub(this.m), A._forceRed(this);
    }, xe.prototype.iadd = function(y, E) {
      this._verify2(y, E);
      var A = y.iadd(E);
      return A.cmp(this.m) >= 0 && A.isub(this.m), A;
    }, xe.prototype.sub = function(y, E) {
      this._verify2(y, E);
      var A = y.sub(E);
      return A.cmpn(0) < 0 && A.iadd(this.m), A._forceRed(this);
    }, xe.prototype.isub = function(y, E) {
      this._verify2(y, E);
      var A = y.isub(E);
      return A.cmpn(0) < 0 && A.iadd(this.m), A;
    }, xe.prototype.shl = function(y, E) {
      return this._verify1(y), this.imod(y.ushln(E));
    }, xe.prototype.imul = function(y, E) {
      return this._verify2(y, E), this.imod(y.imul(E));
    }, xe.prototype.mul = function(y, E) {
      return this._verify2(y, E), this.imod(y.mul(E));
    }, xe.prototype.isqr = function(y) {
      return this.imul(y, y.clone());
    }, xe.prototype.sqr = function(y) {
      return this.mul(y, y);
    }, xe.prototype.sqrt = function(y) {
      if (y.isZero()) return y.clone();
      var E = this.m.andln(3);
      if ($(E % 2 === 1), E === 3) {
        var A = this.m.add(new S(1)).iushrn(2);
        return this.pow(y, A);
      }
      for (var B = this.m.subn(1), O = 0; !B.isZero() && B.andln(1) === 0; )
        O++, B.iushrn(1);
      $(!B.isZero());
      var C = new S(1).toRed(this), L = C.redNeg(), P = this.m.subn(1).iushrn(1), _ = this.m.bitLength();
      for (_ = new S(2 * _ * _).toRed(this); this.pow(_, P).cmp(L) !== 0; )
        _.redIAdd(L);
      for (var I = this.pow(_, B), U = this.pow(y, B.addn(1).iushrn(1)), Y = this.pow(y, B), te = O; Y.cmp(C) !== 0; ) {
        for (var oe = Y, re = 0; oe.cmp(C) !== 0; re++)
          oe = oe.redSqr();
        $(re < te);
        var ee = this.pow(I, new S(1).iushln(te - re - 1));
        U = U.redMul(ee), I = ee.redSqr(), Y = Y.redMul(I), te = re;
      }
      return U;
    }, xe.prototype.invm = function(y) {
      var E = y._invmp(this.m);
      return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
    }, xe.prototype.pow = function(y, E) {
      if (E.isZero()) return new S(1).toRed(this);
      if (E.cmpn(1) === 0) return y.clone();
      var A = 4, B = new Array(1 << A);
      B[0] = new S(1).toRed(this), B[1] = y;
      for (var O = 2; O < B.length; O++)
        B[O] = this.mul(B[O - 1], y);
      var C = B[0], L = 0, P = 0, _ = E.bitLength() % 26;
      for (_ === 0 && (_ = 26), O = E.length - 1; O >= 0; O--) {
        for (var I = E.words[O], U = _ - 1; U >= 0; U--) {
          var Y = I >> U & 1;
          if (C !== B[0] && (C = this.sqr(C)), Y === 0 && L === 0) {
            P = 0;
            continue;
          }
          L <<= 1, L |= Y, P++, !(P !== A && (O !== 0 || U !== 0)) && (C = this.mul(C, B[L]), P = 0, L = 0);
        }
        _ = 26;
      }
      return C;
    }, xe.prototype.convertTo = function(y) {
      var E = y.umod(this.m);
      return E === y ? E.clone() : E;
    }, xe.prototype.convertFrom = function(y) {
      var E = y.clone();
      return E.red = null, E;
    }, S.mont = function(y) {
      return new rt(y);
    };
    function rt(N) {
      xe.call(this, N), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new S(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    T(rt, xe), rt.prototype.convertTo = function(y) {
      return this.imod(y.ushln(this.shift));
    }, rt.prototype.convertFrom = function(y) {
      var E = this.imod(y.mul(this.rinv));
      return E.red = null, E;
    }, rt.prototype.imul = function(y, E) {
      if (y.isZero() || E.isZero())
        return y.words[0] = 0, y.length = 1, y;
      var A = y.imul(E), B = A.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), O = A.isub(B).iushrn(this.shift), C = O;
      return O.cmp(this.m) >= 0 ? C = O.isub(this.m) : O.cmpn(0) < 0 && (C = O.iadd(this.m)), C._forceRed(this);
    }, rt.prototype.mul = function(y, E) {
      if (y.isZero() || E.isZero()) return new S(0)._forceRed(this);
      var A = y.mul(E), B = A.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), O = A.isub(B).iushrn(this.shift), C = O;
      return O.cmp(this.m) >= 0 ? C = O.isub(this.m) : O.cmpn(0) < 0 && (C = O.iadd(this.m)), C._forceRed(this);
    }, rt.prototype.invm = function(y) {
      var E = this.imod(y._invmp(this.m).mul(this.r2));
      return E._forceRed(this);
    };
  })(w, commonjsGlobal);
})(bn$6);
var bnExports$6 = bn$6.exports, bn$5 = { exports: {} };
bn$5.exports;
(function(w) {
  (function(M, x) {
    function $(N, y) {
      if (!N) throw new Error(y || "Assertion failed");
    }
    function T(N, y) {
      N.super_ = y;
      var E = function() {
      };
      E.prototype = y.prototype, N.prototype = new E(), N.prototype.constructor = N;
    }
    function S(N, y, E) {
      if (S.isBN(N))
        return N;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, N !== null && ((y === "le" || y === "be") && (E = y, y = 10), this._init(N || 0, y || 10, E || "be"));
    }
    typeof M == "object" ? M.exports = S : x.BN = S, S.BN = S, S.wordSize = 26;
    var D;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? D = window.Buffer : D = dist.Buffer;
    } catch {
    }
    S.isBN = function(y) {
      return y instanceof S ? !0 : y !== null && typeof y == "object" && y.constructor.wordSize === S.wordSize && Array.isArray(y.words);
    }, S.max = function(y, E) {
      return y.cmp(E) > 0 ? y : E;
    }, S.min = function(y, E) {
      return y.cmp(E) < 0 ? y : E;
    }, S.prototype._init = function(y, E, A) {
      if (typeof y == "number")
        return this._initNumber(y, E, A);
      if (typeof y == "object")
        return this._initArray(y, E, A);
      E === "hex" && (E = 16), $(E === (E | 0) && E >= 2 && E <= 36), y = y.toString().replace(/\s+/g, "");
      var B = 0;
      y[0] === "-" && (B++, this.negative = 1), B < y.length && (E === 16 ? this._parseHex(y, B, A) : (this._parseBase(y, E, B), A === "le" && this._initArray(this.toArray(), E, A)));
    }, S.prototype._initNumber = function(y, E, A) {
      y < 0 && (this.negative = 1, y = -y), y < 67108864 ? (this.words = [y & 67108863], this.length = 1) : y < 4503599627370496 ? (this.words = [
        y & 67108863,
        y / 67108864 & 67108863
      ], this.length = 2) : ($(y < 9007199254740992), this.words = [
        y & 67108863,
        y / 67108864 & 67108863,
        1
      ], this.length = 3), A === "le" && this._initArray(this.toArray(), E, A);
    }, S.prototype._initArray = function(y, E, A) {
      if ($(typeof y.length == "number"), y.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(y.length / 3), this.words = new Array(this.length);
      for (var B = 0; B < this.length; B++)
        this.words[B] = 0;
      var O, C, L = 0;
      if (A === "be")
        for (B = y.length - 1, O = 0; B >= 0; B -= 3)
          C = y[B] | y[B - 1] << 8 | y[B - 2] << 16, this.words[O] |= C << L & 67108863, this.words[O + 1] = C >>> 26 - L & 67108863, L += 24, L >= 26 && (L -= 26, O++);
      else if (A === "le")
        for (B = 0, O = 0; B < y.length; B += 3)
          C = y[B] | y[B + 1] << 8 | y[B + 2] << 16, this.words[O] |= C << L & 67108863, this.words[O + 1] = C >>> 26 - L & 67108863, L += 24, L >= 26 && (L -= 26, O++);
      return this.strip();
    };
    function F(N, y) {
      var E = N.charCodeAt(y);
      return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
    }
    function z(N, y, E) {
      var A = F(N, E);
      return E - 1 >= y && (A |= F(N, E - 1) << 4), A;
    }
    S.prototype._parseHex = function(y, E, A) {
      this.length = Math.ceil((y.length - E) / 6), this.words = new Array(this.length);
      for (var B = 0; B < this.length; B++)
        this.words[B] = 0;
      var O = 0, C = 0, L;
      if (A === "be")
        for (B = y.length - 1; B >= E; B -= 2)
          L = z(y, E, B) << O, this.words[C] |= L & 67108863, O >= 18 ? (O -= 18, C += 1, this.words[C] |= L >>> 26) : O += 8;
      else {
        var P = y.length - E;
        for (B = P % 2 === 0 ? E + 1 : E; B < y.length; B += 2)
          L = z(y, E, B) << O, this.words[C] |= L & 67108863, O >= 18 ? (O -= 18, C += 1, this.words[C] |= L >>> 26) : O += 8;
      }
      this.strip();
    };
    function Z(N, y, E, A) {
      for (var B = 0, O = Math.min(N.length, E), C = y; C < O; C++) {
        var L = N.charCodeAt(C) - 48;
        B *= A, L >= 49 ? B += L - 49 + 10 : L >= 17 ? B += L - 17 + 10 : B += L;
      }
      return B;
    }
    S.prototype._parseBase = function(y, E, A) {
      this.words = [0], this.length = 1;
      for (var B = 0, O = 1; O <= 67108863; O *= E)
        B++;
      B--, O = O / E | 0;
      for (var C = y.length - A, L = C % B, P = Math.min(C, C - L) + A, _ = 0, I = A; I < P; I += B)
        _ = Z(y, I, I + B, E), this.imuln(O), this.words[0] + _ < 67108864 ? this.words[0] += _ : this._iaddn(_);
      if (L !== 0) {
        var U = 1;
        for (_ = Z(y, I, y.length, E), I = 0; I < L; I++)
          U *= E;
        this.imuln(U), this.words[0] + _ < 67108864 ? this.words[0] += _ : this._iaddn(_);
      }
      this.strip();
    }, S.prototype.copy = function(y) {
      y.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        y.words[E] = this.words[E];
      y.length = this.length, y.negative = this.negative, y.red = this.red;
    }, S.prototype.clone = function() {
      var y = new S(null);
      return this.copy(y), y;
    }, S.prototype._expand = function(y) {
      for (; this.length < y; )
        this.words[this.length++] = 0;
      return this;
    }, S.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, S.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, S.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var H = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], V = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], X = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    S.prototype.toString = function(y, E) {
      y = y || 10, E = E | 0 || 1;
      var A;
      if (y === 16 || y === "hex") {
        A = "";
        for (var B = 0, O = 0, C = 0; C < this.length; C++) {
          var L = this.words[C], P = ((L << B | O) & 16777215).toString(16);
          O = L >>> 24 - B & 16777215, B += 2, B >= 26 && (B -= 26, C--), O !== 0 || C !== this.length - 1 ? A = H[6 - P.length] + P + A : A = P + A;
        }
        for (O !== 0 && (A = O.toString(16) + A); A.length % E !== 0; )
          A = "0" + A;
        return this.negative !== 0 && (A = "-" + A), A;
      }
      if (y === (y | 0) && y >= 2 && y <= 36) {
        var _ = V[y], I = X[y];
        A = "";
        var U = this.clone();
        for (U.negative = 0; !U.isZero(); ) {
          var Y = U.modn(I).toString(y);
          U = U.idivn(I), U.isZero() ? A = Y + A : A = H[_ - Y.length] + Y + A;
        }
        for (this.isZero() && (A = "0" + A); A.length % E !== 0; )
          A = "0" + A;
        return this.negative !== 0 && (A = "-" + A), A;
      }
      $(!1, "Base should be between 2 and 36");
    }, S.prototype.toNumber = function() {
      var y = this.words[0];
      return this.length === 2 ? y += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? y += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && $(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -y : y;
    }, S.prototype.toJSON = function() {
      return this.toString(16);
    }, S.prototype.toBuffer = function(y, E) {
      return $(typeof D < "u"), this.toArrayLike(D, y, E);
    }, S.prototype.toArray = function(y, E) {
      return this.toArrayLike(Array, y, E);
    }, S.prototype.toArrayLike = function(y, E, A) {
      var B = this.byteLength(), O = A || Math.max(1, B);
      $(B <= O, "byte array longer than desired length"), $(O > 0, "Requested array length <= 0"), this.strip();
      var C = E === "le", L = new y(O), P, _, I = this.clone();
      if (C) {
        for (_ = 0; !I.isZero(); _++)
          P = I.andln(255), I.iushrn(8), L[_] = P;
        for (; _ < O; _++)
          L[_] = 0;
      } else {
        for (_ = 0; _ < O - B; _++)
          L[_] = 0;
        for (_ = 0; !I.isZero(); _++)
          P = I.andln(255), I.iushrn(8), L[O - _ - 1] = P;
      }
      return L;
    }, Math.clz32 ? S.prototype._countBits = function(y) {
      return 32 - Math.clz32(y);
    } : S.prototype._countBits = function(y) {
      var E = y, A = 0;
      return E >= 4096 && (A += 13, E >>>= 13), E >= 64 && (A += 7, E >>>= 7), E >= 8 && (A += 4, E >>>= 4), E >= 2 && (A += 2, E >>>= 2), A + E;
    }, S.prototype._zeroBits = function(y) {
      if (y === 0) return 26;
      var E = y, A = 0;
      return E & 8191 || (A += 13, E >>>= 13), E & 127 || (A += 7, E >>>= 7), E & 15 || (A += 4, E >>>= 4), E & 3 || (A += 2, E >>>= 2), E & 1 || A++, A;
    }, S.prototype.bitLength = function() {
      var y = this.words[this.length - 1], E = this._countBits(y);
      return (this.length - 1) * 26 + E;
    };
    function Q(N) {
      for (var y = new Array(N.bitLength()), E = 0; E < y.length; E++) {
        var A = E / 26 | 0, B = E % 26;
        y[E] = (N.words[A] & 1 << B) >>> B;
      }
      return y;
    }
    S.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var y = 0, E = 0; E < this.length; E++) {
        var A = this._zeroBits(this.words[E]);
        if (y += A, A !== 26) break;
      }
      return y;
    }, S.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, S.prototype.toTwos = function(y) {
      return this.negative !== 0 ? this.abs().inotn(y).iaddn(1) : this.clone();
    }, S.prototype.fromTwos = function(y) {
      return this.testn(y - 1) ? this.notn(y).iaddn(1).ineg() : this.clone();
    }, S.prototype.isNeg = function() {
      return this.negative !== 0;
    }, S.prototype.neg = function() {
      return this.clone().ineg();
    }, S.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, S.prototype.iuor = function(y) {
      for (; this.length < y.length; )
        this.words[this.length++] = 0;
      for (var E = 0; E < y.length; E++)
        this.words[E] = this.words[E] | y.words[E];
      return this.strip();
    }, S.prototype.ior = function(y) {
      return $((this.negative | y.negative) === 0), this.iuor(y);
    }, S.prototype.or = function(y) {
      return this.length > y.length ? this.clone().ior(y) : y.clone().ior(this);
    }, S.prototype.uor = function(y) {
      return this.length > y.length ? this.clone().iuor(y) : y.clone().iuor(this);
    }, S.prototype.iuand = function(y) {
      var E;
      this.length > y.length ? E = y : E = this;
      for (var A = 0; A < E.length; A++)
        this.words[A] = this.words[A] & y.words[A];
      return this.length = E.length, this.strip();
    }, S.prototype.iand = function(y) {
      return $((this.negative | y.negative) === 0), this.iuand(y);
    }, S.prototype.and = function(y) {
      return this.length > y.length ? this.clone().iand(y) : y.clone().iand(this);
    }, S.prototype.uand = function(y) {
      return this.length > y.length ? this.clone().iuand(y) : y.clone().iuand(this);
    }, S.prototype.iuxor = function(y) {
      var E, A;
      this.length > y.length ? (E = this, A = y) : (E = y, A = this);
      for (var B = 0; B < A.length; B++)
        this.words[B] = E.words[B] ^ A.words[B];
      if (this !== E)
        for (; B < E.length; B++)
          this.words[B] = E.words[B];
      return this.length = E.length, this.strip();
    }, S.prototype.ixor = function(y) {
      return $((this.negative | y.negative) === 0), this.iuxor(y);
    }, S.prototype.xor = function(y) {
      return this.length > y.length ? this.clone().ixor(y) : y.clone().ixor(this);
    }, S.prototype.uxor = function(y) {
      return this.length > y.length ? this.clone().iuxor(y) : y.clone().iuxor(this);
    }, S.prototype.inotn = function(y) {
      $(typeof y == "number" && y >= 0);
      var E = Math.ceil(y / 26) | 0, A = y % 26;
      this._expand(E), A > 0 && E--;
      for (var B = 0; B < E; B++)
        this.words[B] = ~this.words[B] & 67108863;
      return A > 0 && (this.words[B] = ~this.words[B] & 67108863 >> 26 - A), this.strip();
    }, S.prototype.notn = function(y) {
      return this.clone().inotn(y);
    }, S.prototype.setn = function(y, E) {
      $(typeof y == "number" && y >= 0);
      var A = y / 26 | 0, B = y % 26;
      return this._expand(A + 1), E ? this.words[A] = this.words[A] | 1 << B : this.words[A] = this.words[A] & ~(1 << B), this.strip();
    }, S.prototype.iadd = function(y) {
      var E;
      if (this.negative !== 0 && y.negative === 0)
        return this.negative = 0, E = this.isub(y), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && y.negative !== 0)
        return y.negative = 0, E = this.isub(y), y.negative = 1, E._normSign();
      var A, B;
      this.length > y.length ? (A = this, B = y) : (A = y, B = this);
      for (var O = 0, C = 0; C < B.length; C++)
        E = (A.words[C] | 0) + (B.words[C] | 0) + O, this.words[C] = E & 67108863, O = E >>> 26;
      for (; O !== 0 && C < A.length; C++)
        E = (A.words[C] | 0) + O, this.words[C] = E & 67108863, O = E >>> 26;
      if (this.length = A.length, O !== 0)
        this.words[this.length] = O, this.length++;
      else if (A !== this)
        for (; C < A.length; C++)
          this.words[C] = A.words[C];
      return this;
    }, S.prototype.add = function(y) {
      var E;
      return y.negative !== 0 && this.negative === 0 ? (y.negative = 0, E = this.sub(y), y.negative ^= 1, E) : y.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = y.sub(this), this.negative = 1, E) : this.length > y.length ? this.clone().iadd(y) : y.clone().iadd(this);
    }, S.prototype.isub = function(y) {
      if (y.negative !== 0) {
        y.negative = 0;
        var E = this.iadd(y);
        return y.negative = 1, E._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(y), this.negative = 1, this._normSign();
      var A = this.cmp(y);
      if (A === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var B, O;
      A > 0 ? (B = this, O = y) : (B = y, O = this);
      for (var C = 0, L = 0; L < O.length; L++)
        E = (B.words[L] | 0) - (O.words[L] | 0) + C, C = E >> 26, this.words[L] = E & 67108863;
      for (; C !== 0 && L < B.length; L++)
        E = (B.words[L] | 0) + C, C = E >> 26, this.words[L] = E & 67108863;
      if (C === 0 && L < B.length && B !== this)
        for (; L < B.length; L++)
          this.words[L] = B.words[L];
      return this.length = Math.max(this.length, L), B !== this && (this.negative = 1), this.strip();
    }, S.prototype.sub = function(y) {
      return this.clone().isub(y);
    };
    function fe(N, y, E) {
      E.negative = y.negative ^ N.negative;
      var A = N.length + y.length | 0;
      E.length = A, A = A - 1 | 0;
      var B = N.words[0] | 0, O = y.words[0] | 0, C = B * O, L = C & 67108863, P = C / 67108864 | 0;
      E.words[0] = L;
      for (var _ = 1; _ < A; _++) {
        for (var I = P >>> 26, U = P & 67108863, Y = Math.min(_, y.length - 1), te = Math.max(0, _ - N.length + 1); te <= Y; te++) {
          var oe = _ - te | 0;
          B = N.words[oe] | 0, O = y.words[te] | 0, C = B * O + U, I += C / 67108864 | 0, U = C & 67108863;
        }
        E.words[_] = U | 0, P = I | 0;
      }
      return P !== 0 ? E.words[_] = P | 0 : E.length--, E.strip();
    }
    var ce = function(y, E, A) {
      var B = y.words, O = E.words, C = A.words, L = 0, P, _, I, U = B[0] | 0, Y = U & 8191, te = U >>> 13, oe = B[1] | 0, re = oe & 8191, ee = oe >>> 13, ae = B[2] | 0, ue = ae & 8191, ye = ae >>> 13, ve = B[3] | 0, he = ve & 8191, Me = ve >>> 13, Qe = B[4] | 0, Ie = Qe & 8191, De = Qe >>> 13, at = B[5] | 0, ke = at & 8191, Se = at >>> 13, lt = B[6] | 0, qe = lt & 8191, He = lt >>> 13, ot = B[7] | 0, be = ot & 8191, _e = ot >>> 13, it = B[8] | 0, Ae = it & 8191, Be = it >>> 13, nt = B[9] | 0, Te = nt & 8191, Ue = nt >>> 13, st = O[0] | 0, Le = st & 8191, Ge = st >>> 13, pt = O[1] | 0, je = pt & 8191, Je = pt >>> 13, dt = O[2] | 0, ze = dt & 8191, et = dt >>> 13, yt = O[3] | 0, Ke = yt & 8191, Ye = yt >>> 13, gt = O[4] | 0, We = gt & 8191, Xe = gt >>> 13, bt = O[5] | 0, se = bt & 8191, J = bt >>> 13, ie = O[6] | 0, le = ie & 8191, we = ie >>> 13, Ce = O[7] | 0, Ee = Ce & 8191, Fe = Ce >>> 13, ut = O[8] | 0, Ne = ut & 8191, Ve = ut >>> 13, ht = O[9] | 0, Ze = ht & 8191, tt = ht >>> 13;
      A.negative = y.negative ^ E.negative, A.length = 19, P = Math.imul(Y, Le), _ = Math.imul(Y, Ge), _ = _ + Math.imul(te, Le) | 0, I = Math.imul(te, Ge);
      var vt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, P = Math.imul(re, Le), _ = Math.imul(re, Ge), _ = _ + Math.imul(ee, Le) | 0, I = Math.imul(ee, Ge), P = P + Math.imul(Y, je) | 0, _ = _ + Math.imul(Y, Je) | 0, _ = _ + Math.imul(te, je) | 0, I = I + Math.imul(te, Je) | 0;
      var mt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, P = Math.imul(ue, Le), _ = Math.imul(ue, Ge), _ = _ + Math.imul(ye, Le) | 0, I = Math.imul(ye, Ge), P = P + Math.imul(re, je) | 0, _ = _ + Math.imul(re, Je) | 0, _ = _ + Math.imul(ee, je) | 0, I = I + Math.imul(ee, Je) | 0, P = P + Math.imul(Y, ze) | 0, _ = _ + Math.imul(Y, et) | 0, _ = _ + Math.imul(te, ze) | 0, I = I + Math.imul(te, et) | 0;
      var wt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, P = Math.imul(he, Le), _ = Math.imul(he, Ge), _ = _ + Math.imul(Me, Le) | 0, I = Math.imul(Me, Ge), P = P + Math.imul(ue, je) | 0, _ = _ + Math.imul(ue, Je) | 0, _ = _ + Math.imul(ye, je) | 0, I = I + Math.imul(ye, Je) | 0, P = P + Math.imul(re, ze) | 0, _ = _ + Math.imul(re, et) | 0, _ = _ + Math.imul(ee, ze) | 0, I = I + Math.imul(ee, et) | 0, P = P + Math.imul(Y, Ke) | 0, _ = _ + Math.imul(Y, Ye) | 0, _ = _ + Math.imul(te, Ke) | 0, I = I + Math.imul(te, Ye) | 0;
      var Mt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, P = Math.imul(Ie, Le), _ = Math.imul(Ie, Ge), _ = _ + Math.imul(De, Le) | 0, I = Math.imul(De, Ge), P = P + Math.imul(he, je) | 0, _ = _ + Math.imul(he, Je) | 0, _ = _ + Math.imul(Me, je) | 0, I = I + Math.imul(Me, Je) | 0, P = P + Math.imul(ue, ze) | 0, _ = _ + Math.imul(ue, et) | 0, _ = _ + Math.imul(ye, ze) | 0, I = I + Math.imul(ye, et) | 0, P = P + Math.imul(re, Ke) | 0, _ = _ + Math.imul(re, Ye) | 0, _ = _ + Math.imul(ee, Ke) | 0, I = I + Math.imul(ee, Ye) | 0, P = P + Math.imul(Y, We) | 0, _ = _ + Math.imul(Y, Xe) | 0, _ = _ + Math.imul(te, We) | 0, I = I + Math.imul(te, Xe) | 0;
      var _t = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, P = Math.imul(ke, Le), _ = Math.imul(ke, Ge), _ = _ + Math.imul(Se, Le) | 0, I = Math.imul(Se, Ge), P = P + Math.imul(Ie, je) | 0, _ = _ + Math.imul(Ie, Je) | 0, _ = _ + Math.imul(De, je) | 0, I = I + Math.imul(De, Je) | 0, P = P + Math.imul(he, ze) | 0, _ = _ + Math.imul(he, et) | 0, _ = _ + Math.imul(Me, ze) | 0, I = I + Math.imul(Me, et) | 0, P = P + Math.imul(ue, Ke) | 0, _ = _ + Math.imul(ue, Ye) | 0, _ = _ + Math.imul(ye, Ke) | 0, I = I + Math.imul(ye, Ye) | 0, P = P + Math.imul(re, We) | 0, _ = _ + Math.imul(re, Xe) | 0, _ = _ + Math.imul(ee, We) | 0, I = I + Math.imul(ee, Xe) | 0, P = P + Math.imul(Y, se) | 0, _ = _ + Math.imul(Y, J) | 0, _ = _ + Math.imul(te, se) | 0, I = I + Math.imul(te, J) | 0;
      var xt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, P = Math.imul(qe, Le), _ = Math.imul(qe, Ge), _ = _ + Math.imul(He, Le) | 0, I = Math.imul(He, Ge), P = P + Math.imul(ke, je) | 0, _ = _ + Math.imul(ke, Je) | 0, _ = _ + Math.imul(Se, je) | 0, I = I + Math.imul(Se, Je) | 0, P = P + Math.imul(Ie, ze) | 0, _ = _ + Math.imul(Ie, et) | 0, _ = _ + Math.imul(De, ze) | 0, I = I + Math.imul(De, et) | 0, P = P + Math.imul(he, Ke) | 0, _ = _ + Math.imul(he, Ye) | 0, _ = _ + Math.imul(Me, Ke) | 0, I = I + Math.imul(Me, Ye) | 0, P = P + Math.imul(ue, We) | 0, _ = _ + Math.imul(ue, Xe) | 0, _ = _ + Math.imul(ye, We) | 0, I = I + Math.imul(ye, Xe) | 0, P = P + Math.imul(re, se) | 0, _ = _ + Math.imul(re, J) | 0, _ = _ + Math.imul(ee, se) | 0, I = I + Math.imul(ee, J) | 0, P = P + Math.imul(Y, le) | 0, _ = _ + Math.imul(Y, we) | 0, _ = _ + Math.imul(te, le) | 0, I = I + Math.imul(te, we) | 0;
      var Et = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, P = Math.imul(be, Le), _ = Math.imul(be, Ge), _ = _ + Math.imul(_e, Le) | 0, I = Math.imul(_e, Ge), P = P + Math.imul(qe, je) | 0, _ = _ + Math.imul(qe, Je) | 0, _ = _ + Math.imul(He, je) | 0, I = I + Math.imul(He, Je) | 0, P = P + Math.imul(ke, ze) | 0, _ = _ + Math.imul(ke, et) | 0, _ = _ + Math.imul(Se, ze) | 0, I = I + Math.imul(Se, et) | 0, P = P + Math.imul(Ie, Ke) | 0, _ = _ + Math.imul(Ie, Ye) | 0, _ = _ + Math.imul(De, Ke) | 0, I = I + Math.imul(De, Ye) | 0, P = P + Math.imul(he, We) | 0, _ = _ + Math.imul(he, Xe) | 0, _ = _ + Math.imul(Me, We) | 0, I = I + Math.imul(Me, Xe) | 0, P = P + Math.imul(ue, se) | 0, _ = _ + Math.imul(ue, J) | 0, _ = _ + Math.imul(ye, se) | 0, I = I + Math.imul(ye, J) | 0, P = P + Math.imul(re, le) | 0, _ = _ + Math.imul(re, we) | 0, _ = _ + Math.imul(ee, le) | 0, I = I + Math.imul(ee, we) | 0, P = P + Math.imul(Y, Ee) | 0, _ = _ + Math.imul(Y, Fe) | 0, _ = _ + Math.imul(te, Ee) | 0, I = I + Math.imul(te, Fe) | 0;
      var St = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, P = Math.imul(Ae, Le), _ = Math.imul(Ae, Ge), _ = _ + Math.imul(Be, Le) | 0, I = Math.imul(Be, Ge), P = P + Math.imul(be, je) | 0, _ = _ + Math.imul(be, Je) | 0, _ = _ + Math.imul(_e, je) | 0, I = I + Math.imul(_e, Je) | 0, P = P + Math.imul(qe, ze) | 0, _ = _ + Math.imul(qe, et) | 0, _ = _ + Math.imul(He, ze) | 0, I = I + Math.imul(He, et) | 0, P = P + Math.imul(ke, Ke) | 0, _ = _ + Math.imul(ke, Ye) | 0, _ = _ + Math.imul(Se, Ke) | 0, I = I + Math.imul(Se, Ye) | 0, P = P + Math.imul(Ie, We) | 0, _ = _ + Math.imul(Ie, Xe) | 0, _ = _ + Math.imul(De, We) | 0, I = I + Math.imul(De, Xe) | 0, P = P + Math.imul(he, se) | 0, _ = _ + Math.imul(he, J) | 0, _ = _ + Math.imul(Me, se) | 0, I = I + Math.imul(Me, J) | 0, P = P + Math.imul(ue, le) | 0, _ = _ + Math.imul(ue, we) | 0, _ = _ + Math.imul(ye, le) | 0, I = I + Math.imul(ye, we) | 0, P = P + Math.imul(re, Ee) | 0, _ = _ + Math.imul(re, Fe) | 0, _ = _ + Math.imul(ee, Ee) | 0, I = I + Math.imul(ee, Fe) | 0, P = P + Math.imul(Y, Ne) | 0, _ = _ + Math.imul(Y, Ve) | 0, _ = _ + Math.imul(te, Ne) | 0, I = I + Math.imul(te, Ve) | 0;
      var $t = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, P = Math.imul(Te, Le), _ = Math.imul(Te, Ge), _ = _ + Math.imul(Ue, Le) | 0, I = Math.imul(Ue, Ge), P = P + Math.imul(Ae, je) | 0, _ = _ + Math.imul(Ae, Je) | 0, _ = _ + Math.imul(Be, je) | 0, I = I + Math.imul(Be, Je) | 0, P = P + Math.imul(be, ze) | 0, _ = _ + Math.imul(be, et) | 0, _ = _ + Math.imul(_e, ze) | 0, I = I + Math.imul(_e, et) | 0, P = P + Math.imul(qe, Ke) | 0, _ = _ + Math.imul(qe, Ye) | 0, _ = _ + Math.imul(He, Ke) | 0, I = I + Math.imul(He, Ye) | 0, P = P + Math.imul(ke, We) | 0, _ = _ + Math.imul(ke, Xe) | 0, _ = _ + Math.imul(Se, We) | 0, I = I + Math.imul(Se, Xe) | 0, P = P + Math.imul(Ie, se) | 0, _ = _ + Math.imul(Ie, J) | 0, _ = _ + Math.imul(De, se) | 0, I = I + Math.imul(De, J) | 0, P = P + Math.imul(he, le) | 0, _ = _ + Math.imul(he, we) | 0, _ = _ + Math.imul(Me, le) | 0, I = I + Math.imul(Me, we) | 0, P = P + Math.imul(ue, Ee) | 0, _ = _ + Math.imul(ue, Fe) | 0, _ = _ + Math.imul(ye, Ee) | 0, I = I + Math.imul(ye, Fe) | 0, P = P + Math.imul(re, Ne) | 0, _ = _ + Math.imul(re, Ve) | 0, _ = _ + Math.imul(ee, Ne) | 0, I = I + Math.imul(ee, Ve) | 0, P = P + Math.imul(Y, Ze) | 0, _ = _ + Math.imul(Y, tt) | 0, _ = _ + Math.imul(te, Ze) | 0, I = I + Math.imul(te, tt) | 0;
      var At = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, P = Math.imul(Te, je), _ = Math.imul(Te, Je), _ = _ + Math.imul(Ue, je) | 0, I = Math.imul(Ue, Je), P = P + Math.imul(Ae, ze) | 0, _ = _ + Math.imul(Ae, et) | 0, _ = _ + Math.imul(Be, ze) | 0, I = I + Math.imul(Be, et) | 0, P = P + Math.imul(be, Ke) | 0, _ = _ + Math.imul(be, Ye) | 0, _ = _ + Math.imul(_e, Ke) | 0, I = I + Math.imul(_e, Ye) | 0, P = P + Math.imul(qe, We) | 0, _ = _ + Math.imul(qe, Xe) | 0, _ = _ + Math.imul(He, We) | 0, I = I + Math.imul(He, Xe) | 0, P = P + Math.imul(ke, se) | 0, _ = _ + Math.imul(ke, J) | 0, _ = _ + Math.imul(Se, se) | 0, I = I + Math.imul(Se, J) | 0, P = P + Math.imul(Ie, le) | 0, _ = _ + Math.imul(Ie, we) | 0, _ = _ + Math.imul(De, le) | 0, I = I + Math.imul(De, we) | 0, P = P + Math.imul(he, Ee) | 0, _ = _ + Math.imul(he, Fe) | 0, _ = _ + Math.imul(Me, Ee) | 0, I = I + Math.imul(Me, Fe) | 0, P = P + Math.imul(ue, Ne) | 0, _ = _ + Math.imul(ue, Ve) | 0, _ = _ + Math.imul(ye, Ne) | 0, I = I + Math.imul(ye, Ve) | 0, P = P + Math.imul(re, Ze) | 0, _ = _ + Math.imul(re, tt) | 0, _ = _ + Math.imul(ee, Ze) | 0, I = I + Math.imul(ee, tt) | 0;
      var Rt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, P = Math.imul(Te, ze), _ = Math.imul(Te, et), _ = _ + Math.imul(Ue, ze) | 0, I = Math.imul(Ue, et), P = P + Math.imul(Ae, Ke) | 0, _ = _ + Math.imul(Ae, Ye) | 0, _ = _ + Math.imul(Be, Ke) | 0, I = I + Math.imul(Be, Ye) | 0, P = P + Math.imul(be, We) | 0, _ = _ + Math.imul(be, Xe) | 0, _ = _ + Math.imul(_e, We) | 0, I = I + Math.imul(_e, Xe) | 0, P = P + Math.imul(qe, se) | 0, _ = _ + Math.imul(qe, J) | 0, _ = _ + Math.imul(He, se) | 0, I = I + Math.imul(He, J) | 0, P = P + Math.imul(ke, le) | 0, _ = _ + Math.imul(ke, we) | 0, _ = _ + Math.imul(Se, le) | 0, I = I + Math.imul(Se, we) | 0, P = P + Math.imul(Ie, Ee) | 0, _ = _ + Math.imul(Ie, Fe) | 0, _ = _ + Math.imul(De, Ee) | 0, I = I + Math.imul(De, Fe) | 0, P = P + Math.imul(he, Ne) | 0, _ = _ + Math.imul(he, Ve) | 0, _ = _ + Math.imul(Me, Ne) | 0, I = I + Math.imul(Me, Ve) | 0, P = P + Math.imul(ue, Ze) | 0, _ = _ + Math.imul(ue, tt) | 0, _ = _ + Math.imul(ye, Ze) | 0, I = I + Math.imul(ye, tt) | 0;
      var Bt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, P = Math.imul(Te, Ke), _ = Math.imul(Te, Ye), _ = _ + Math.imul(Ue, Ke) | 0, I = Math.imul(Ue, Ye), P = P + Math.imul(Ae, We) | 0, _ = _ + Math.imul(Ae, Xe) | 0, _ = _ + Math.imul(Be, We) | 0, I = I + Math.imul(Be, Xe) | 0, P = P + Math.imul(be, se) | 0, _ = _ + Math.imul(be, J) | 0, _ = _ + Math.imul(_e, se) | 0, I = I + Math.imul(_e, J) | 0, P = P + Math.imul(qe, le) | 0, _ = _ + Math.imul(qe, we) | 0, _ = _ + Math.imul(He, le) | 0, I = I + Math.imul(He, we) | 0, P = P + Math.imul(ke, Ee) | 0, _ = _ + Math.imul(ke, Fe) | 0, _ = _ + Math.imul(Se, Ee) | 0, I = I + Math.imul(Se, Fe) | 0, P = P + Math.imul(Ie, Ne) | 0, _ = _ + Math.imul(Ie, Ve) | 0, _ = _ + Math.imul(De, Ne) | 0, I = I + Math.imul(De, Ve) | 0, P = P + Math.imul(he, Ze) | 0, _ = _ + Math.imul(he, tt) | 0, _ = _ + Math.imul(Me, Ze) | 0, I = I + Math.imul(Me, tt) | 0;
      var Tt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, P = Math.imul(Te, We), _ = Math.imul(Te, Xe), _ = _ + Math.imul(Ue, We) | 0, I = Math.imul(Ue, Xe), P = P + Math.imul(Ae, se) | 0, _ = _ + Math.imul(Ae, J) | 0, _ = _ + Math.imul(Be, se) | 0, I = I + Math.imul(Be, J) | 0, P = P + Math.imul(be, le) | 0, _ = _ + Math.imul(be, we) | 0, _ = _ + Math.imul(_e, le) | 0, I = I + Math.imul(_e, we) | 0, P = P + Math.imul(qe, Ee) | 0, _ = _ + Math.imul(qe, Fe) | 0, _ = _ + Math.imul(He, Ee) | 0, I = I + Math.imul(He, Fe) | 0, P = P + Math.imul(ke, Ne) | 0, _ = _ + Math.imul(ke, Ve) | 0, _ = _ + Math.imul(Se, Ne) | 0, I = I + Math.imul(Se, Ve) | 0, P = P + Math.imul(Ie, Ze) | 0, _ = _ + Math.imul(Ie, tt) | 0, _ = _ + Math.imul(De, Ze) | 0, I = I + Math.imul(De, tt) | 0;
      var Pt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, P = Math.imul(Te, se), _ = Math.imul(Te, J), _ = _ + Math.imul(Ue, se) | 0, I = Math.imul(Ue, J), P = P + Math.imul(Ae, le) | 0, _ = _ + Math.imul(Ae, we) | 0, _ = _ + Math.imul(Be, le) | 0, I = I + Math.imul(Be, we) | 0, P = P + Math.imul(be, Ee) | 0, _ = _ + Math.imul(be, Fe) | 0, _ = _ + Math.imul(_e, Ee) | 0, I = I + Math.imul(_e, Fe) | 0, P = P + Math.imul(qe, Ne) | 0, _ = _ + Math.imul(qe, Ve) | 0, _ = _ + Math.imul(He, Ne) | 0, I = I + Math.imul(He, Ve) | 0, P = P + Math.imul(ke, Ze) | 0, _ = _ + Math.imul(ke, tt) | 0, _ = _ + Math.imul(Se, Ze) | 0, I = I + Math.imul(Se, tt) | 0;
      var It = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, P = Math.imul(Te, le), _ = Math.imul(Te, we), _ = _ + Math.imul(Ue, le) | 0, I = Math.imul(Ue, we), P = P + Math.imul(Ae, Ee) | 0, _ = _ + Math.imul(Ae, Fe) | 0, _ = _ + Math.imul(Be, Ee) | 0, I = I + Math.imul(Be, Fe) | 0, P = P + Math.imul(be, Ne) | 0, _ = _ + Math.imul(be, Ve) | 0, _ = _ + Math.imul(_e, Ne) | 0, I = I + Math.imul(_e, Ve) | 0, P = P + Math.imul(qe, Ze) | 0, _ = _ + Math.imul(qe, tt) | 0, _ = _ + Math.imul(He, Ze) | 0, I = I + Math.imul(He, tt) | 0;
      var Ot = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, P = Math.imul(Te, Ee), _ = Math.imul(Te, Fe), _ = _ + Math.imul(Ue, Ee) | 0, I = Math.imul(Ue, Fe), P = P + Math.imul(Ae, Ne) | 0, _ = _ + Math.imul(Ae, Ve) | 0, _ = _ + Math.imul(Be, Ne) | 0, I = I + Math.imul(Be, Ve) | 0, P = P + Math.imul(be, Ze) | 0, _ = _ + Math.imul(be, tt) | 0, _ = _ + Math.imul(_e, Ze) | 0, I = I + Math.imul(_e, tt) | 0;
      var Ct = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, P = Math.imul(Te, Ne), _ = Math.imul(Te, Ve), _ = _ + Math.imul(Ue, Ne) | 0, I = Math.imul(Ue, Ve), P = P + Math.imul(Ae, Ze) | 0, _ = _ + Math.imul(Ae, tt) | 0, _ = _ + Math.imul(Be, Ze) | 0, I = I + Math.imul(Be, tt) | 0;
      var Dt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, P = Math.imul(Te, Ze), _ = Math.imul(Te, tt), _ = _ + Math.imul(Ue, Ze) | 0, I = Math.imul(Ue, tt);
      var kt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      return L = (I + (_ >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, C[0] = vt, C[1] = mt, C[2] = wt, C[3] = Mt, C[4] = _t, C[5] = xt, C[6] = Et, C[7] = St, C[8] = $t, C[9] = At, C[10] = Rt, C[11] = Bt, C[12] = Tt, C[13] = Pt, C[14] = It, C[15] = Ot, C[16] = Ct, C[17] = Dt, C[18] = kt, L !== 0 && (C[19] = L, A.length++), A;
    };
    Math.imul || (ce = fe);
    function me(N, y, E) {
      E.negative = y.negative ^ N.negative, E.length = N.length + y.length;
      for (var A = 0, B = 0, O = 0; O < E.length - 1; O++) {
        var C = B;
        B = 0;
        for (var L = A & 67108863, P = Math.min(O, y.length - 1), _ = Math.max(0, O - N.length + 1); _ <= P; _++) {
          var I = O - _, U = N.words[I] | 0, Y = y.words[_] | 0, te = U * Y, oe = te & 67108863;
          C = C + (te / 67108864 | 0) | 0, oe = oe + L | 0, L = oe & 67108863, C = C + (oe >>> 26) | 0, B += C >>> 26, C &= 67108863;
        }
        E.words[O] = L, A = C, C = B;
      }
      return A !== 0 ? E.words[O] = A : E.length--, E.strip();
    }
    function de(N, y, E) {
      var A = new ne();
      return A.mulp(N, y, E);
    }
    S.prototype.mulTo = function(y, E) {
      var A, B = this.length + y.length;
      return this.length === 10 && y.length === 10 ? A = ce(this, y, E) : B < 63 ? A = fe(this, y, E) : B < 1024 ? A = me(this, y, E) : A = de(this, y, E), A;
    };
    function ne(N, y) {
      this.x = N, this.y = y;
    }
    ne.prototype.makeRBT = function(y) {
      for (var E = new Array(y), A = S.prototype._countBits(y) - 1, B = 0; B < y; B++)
        E[B] = this.revBin(B, A, y);
      return E;
    }, ne.prototype.revBin = function(y, E, A) {
      if (y === 0 || y === A - 1) return y;
      for (var B = 0, O = 0; O < E; O++)
        B |= (y & 1) << E - O - 1, y >>= 1;
      return B;
    }, ne.prototype.permute = function(y, E, A, B, O, C) {
      for (var L = 0; L < C; L++)
        B[L] = E[y[L]], O[L] = A[y[L]];
    }, ne.prototype.transform = function(y, E, A, B, O, C) {
      this.permute(C, y, E, A, B, O);
      for (var L = 1; L < O; L <<= 1)
        for (var P = L << 1, _ = Math.cos(2 * Math.PI / P), I = Math.sin(2 * Math.PI / P), U = 0; U < O; U += P)
          for (var Y = _, te = I, oe = 0; oe < L; oe++) {
            var re = A[U + oe], ee = B[U + oe], ae = A[U + oe + L], ue = B[U + oe + L], ye = Y * ae - te * ue;
            ue = Y * ue + te * ae, ae = ye, A[U + oe] = re + ae, B[U + oe] = ee + ue, A[U + oe + L] = re - ae, B[U + oe + L] = ee - ue, oe !== P && (ye = _ * Y - I * te, te = _ * te + I * Y, Y = ye);
          }
    }, ne.prototype.guessLen13b = function(y, E) {
      var A = Math.max(E, y) | 1, B = A & 1, O = 0;
      for (A = A / 2 | 0; A; A = A >>> 1)
        O++;
      return 1 << O + 1 + B;
    }, ne.prototype.conjugate = function(y, E, A) {
      if (!(A <= 1))
        for (var B = 0; B < A / 2; B++) {
          var O = y[B];
          y[B] = y[A - B - 1], y[A - B - 1] = O, O = E[B], E[B] = -E[A - B - 1], E[A - B - 1] = -O;
        }
    }, ne.prototype.normalize13b = function(y, E) {
      for (var A = 0, B = 0; B < E / 2; B++) {
        var O = Math.round(y[2 * B + 1] / E) * 8192 + Math.round(y[2 * B] / E) + A;
        y[B] = O & 67108863, O < 67108864 ? A = 0 : A = O / 67108864 | 0;
      }
      return y;
    }, ne.prototype.convert13b = function(y, E, A, B) {
      for (var O = 0, C = 0; C < E; C++)
        O = O + (y[C] | 0), A[2 * C] = O & 8191, O = O >>> 13, A[2 * C + 1] = O & 8191, O = O >>> 13;
      for (C = 2 * E; C < B; ++C)
        A[C] = 0;
      $(O === 0), $((O & -8192) === 0);
    }, ne.prototype.stub = function(y) {
      for (var E = new Array(y), A = 0; A < y; A++)
        E[A] = 0;
      return E;
    }, ne.prototype.mulp = function(y, E, A) {
      var B = 2 * this.guessLen13b(y.length, E.length), O = this.makeRBT(B), C = this.stub(B), L = new Array(B), P = new Array(B), _ = new Array(B), I = new Array(B), U = new Array(B), Y = new Array(B), te = A.words;
      te.length = B, this.convert13b(y.words, y.length, L, B), this.convert13b(E.words, E.length, I, B), this.transform(L, C, P, _, B, O), this.transform(I, C, U, Y, B, O);
      for (var oe = 0; oe < B; oe++) {
        var re = P[oe] * U[oe] - _[oe] * Y[oe];
        _[oe] = P[oe] * Y[oe] + _[oe] * U[oe], P[oe] = re;
      }
      return this.conjugate(P, _, B), this.transform(P, _, te, C, B, O), this.conjugate(te, C, B), this.normalize13b(te, B), A.negative = y.negative ^ E.negative, A.length = y.length + E.length, A.strip();
    }, S.prototype.mul = function(y) {
      var E = new S(null);
      return E.words = new Array(this.length + y.length), this.mulTo(y, E);
    }, S.prototype.mulf = function(y) {
      var E = new S(null);
      return E.words = new Array(this.length + y.length), de(this, y, E);
    }, S.prototype.imul = function(y) {
      return this.clone().mulTo(y, this);
    }, S.prototype.imuln = function(y) {
      $(typeof y == "number"), $(y < 67108864);
      for (var E = 0, A = 0; A < this.length; A++) {
        var B = (this.words[A] | 0) * y, O = (B & 67108863) + (E & 67108863);
        E >>= 26, E += B / 67108864 | 0, E += O >>> 26, this.words[A] = O & 67108863;
      }
      return E !== 0 && (this.words[A] = E, this.length++), this.length = y === 0 ? 1 : this.length, this;
    }, S.prototype.muln = function(y) {
      return this.clone().imuln(y);
    }, S.prototype.sqr = function() {
      return this.mul(this);
    }, S.prototype.isqr = function() {
      return this.imul(this.clone());
    }, S.prototype.pow = function(y) {
      var E = Q(y);
      if (E.length === 0) return new S(1);
      for (var A = this, B = 0; B < E.length && E[B] === 0; B++, A = A.sqr())
        ;
      if (++B < E.length)
        for (var O = A.sqr(); B < E.length; B++, O = O.sqr())
          E[B] !== 0 && (A = A.mul(O));
      return A;
    }, S.prototype.iushln = function(y) {
      $(typeof y == "number" && y >= 0);
      var E = y % 26, A = (y - E) / 26, B = 67108863 >>> 26 - E << 26 - E, O;
      if (E !== 0) {
        var C = 0;
        for (O = 0; O < this.length; O++) {
          var L = this.words[O] & B, P = (this.words[O] | 0) - L << E;
          this.words[O] = P | C, C = L >>> 26 - E;
        }
        C && (this.words[O] = C, this.length++);
      }
      if (A !== 0) {
        for (O = this.length - 1; O >= 0; O--)
          this.words[O + A] = this.words[O];
        for (O = 0; O < A; O++)
          this.words[O] = 0;
        this.length += A;
      }
      return this.strip();
    }, S.prototype.ishln = function(y) {
      return $(this.negative === 0), this.iushln(y);
    }, S.prototype.iushrn = function(y, E, A) {
      $(typeof y == "number" && y >= 0);
      var B;
      E ? B = (E - E % 26) / 26 : B = 0;
      var O = y % 26, C = Math.min((y - O) / 26, this.length), L = 67108863 ^ 67108863 >>> O << O, P = A;
      if (B -= C, B = Math.max(0, B), P) {
        for (var _ = 0; _ < C; _++)
          P.words[_] = this.words[_];
        P.length = C;
      }
      if (C !== 0) if (this.length > C)
        for (this.length -= C, _ = 0; _ < this.length; _++)
          this.words[_] = this.words[_ + C];
      else
        this.words[0] = 0, this.length = 1;
      var I = 0;
      for (_ = this.length - 1; _ >= 0 && (I !== 0 || _ >= B); _--) {
        var U = this.words[_] | 0;
        this.words[_] = I << 26 - O | U >>> O, I = U & L;
      }
      return P && I !== 0 && (P.words[P.length++] = I), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, S.prototype.ishrn = function(y, E, A) {
      return $(this.negative === 0), this.iushrn(y, E, A);
    }, S.prototype.shln = function(y) {
      return this.clone().ishln(y);
    }, S.prototype.ushln = function(y) {
      return this.clone().iushln(y);
    }, S.prototype.shrn = function(y) {
      return this.clone().ishrn(y);
    }, S.prototype.ushrn = function(y) {
      return this.clone().iushrn(y);
    }, S.prototype.testn = function(y) {
      $(typeof y == "number" && y >= 0);
      var E = y % 26, A = (y - E) / 26, B = 1 << E;
      if (this.length <= A) return !1;
      var O = this.words[A];
      return !!(O & B);
    }, S.prototype.imaskn = function(y) {
      $(typeof y == "number" && y >= 0);
      var E = y % 26, A = (y - E) / 26;
      if ($(this.negative === 0, "imaskn works only with positive numbers"), this.length <= A)
        return this;
      if (E !== 0 && A++, this.length = Math.min(A, this.length), E !== 0) {
        var B = 67108863 ^ 67108863 >>> E << E;
        this.words[this.length - 1] &= B;
      }
      return this.strip();
    }, S.prototype.maskn = function(y) {
      return this.clone().imaskn(y);
    }, S.prototype.iaddn = function(y) {
      return $(typeof y == "number"), $(y < 67108864), y < 0 ? this.isubn(-y) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < y ? (this.words[0] = y - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(y), this.negative = 1, this) : this._iaddn(y);
    }, S.prototype._iaddn = function(y) {
      this.words[0] += y;
      for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
        this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
      return this.length = Math.max(this.length, E + 1), this;
    }, S.prototype.isubn = function(y) {
      if ($(typeof y == "number"), $(y < 67108864), y < 0) return this.iaddn(-y);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(y), this.negative = 1, this;
      if (this.words[0] -= y, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var E = 0; E < this.length && this.words[E] < 0; E++)
          this.words[E] += 67108864, this.words[E + 1] -= 1;
      return this.strip();
    }, S.prototype.addn = function(y) {
      return this.clone().iaddn(y);
    }, S.prototype.subn = function(y) {
      return this.clone().isubn(y);
    }, S.prototype.iabs = function() {
      return this.negative = 0, this;
    }, S.prototype.abs = function() {
      return this.clone().iabs();
    }, S.prototype._ishlnsubmul = function(y, E, A) {
      var B = y.length + A, O;
      this._expand(B);
      var C, L = 0;
      for (O = 0; O < y.length; O++) {
        C = (this.words[O + A] | 0) + L;
        var P = (y.words[O] | 0) * E;
        C -= P & 67108863, L = (C >> 26) - (P / 67108864 | 0), this.words[O + A] = C & 67108863;
      }
      for (; O < this.length - A; O++)
        C = (this.words[O + A] | 0) + L, L = C >> 26, this.words[O + A] = C & 67108863;
      if (L === 0) return this.strip();
      for ($(L === -1), L = 0, O = 0; O < this.length; O++)
        C = -(this.words[O] | 0) + L, L = C >> 26, this.words[O] = C & 67108863;
      return this.negative = 1, this.strip();
    }, S.prototype._wordDiv = function(y, E) {
      var A = this.length - y.length, B = this.clone(), O = y, C = O.words[O.length - 1] | 0, L = this._countBits(C);
      A = 26 - L, A !== 0 && (O = O.ushln(A), B.iushln(A), C = O.words[O.length - 1] | 0);
      var P = B.length - O.length, _;
      if (E !== "mod") {
        _ = new S(null), _.length = P + 1, _.words = new Array(_.length);
        for (var I = 0; I < _.length; I++)
          _.words[I] = 0;
      }
      var U = B.clone()._ishlnsubmul(O, 1, P);
      U.negative === 0 && (B = U, _ && (_.words[P] = 1));
      for (var Y = P - 1; Y >= 0; Y--) {
        var te = (B.words[O.length + Y] | 0) * 67108864 + (B.words[O.length + Y - 1] | 0);
        for (te = Math.min(te / C | 0, 67108863), B._ishlnsubmul(O, te, Y); B.negative !== 0; )
          te--, B.negative = 0, B._ishlnsubmul(O, 1, Y), B.isZero() || (B.negative ^= 1);
        _ && (_.words[Y] = te);
      }
      return _ && _.strip(), B.strip(), E !== "div" && A !== 0 && B.iushrn(A), {
        div: _ || null,
        mod: B
      };
    }, S.prototype.divmod = function(y, E, A) {
      if ($(!y.isZero()), this.isZero())
        return {
          div: new S(0),
          mod: new S(0)
        };
      var B, O, C;
      return this.negative !== 0 && y.negative === 0 ? (C = this.neg().divmod(y, E), E !== "mod" && (B = C.div.neg()), E !== "div" && (O = C.mod.neg(), A && O.negative !== 0 && O.iadd(y)), {
        div: B,
        mod: O
      }) : this.negative === 0 && y.negative !== 0 ? (C = this.divmod(y.neg(), E), E !== "mod" && (B = C.div.neg()), {
        div: B,
        mod: C.mod
      }) : this.negative & y.negative ? (C = this.neg().divmod(y.neg(), E), E !== "div" && (O = C.mod.neg(), A && O.negative !== 0 && O.isub(y)), {
        div: C.div,
        mod: O
      }) : y.length > this.length || this.cmp(y) < 0 ? {
        div: new S(0),
        mod: this
      } : y.length === 1 ? E === "div" ? {
        div: this.divn(y.words[0]),
        mod: null
      } : E === "mod" ? {
        div: null,
        mod: new S(this.modn(y.words[0]))
      } : {
        div: this.divn(y.words[0]),
        mod: new S(this.modn(y.words[0]))
      } : this._wordDiv(y, E);
    }, S.prototype.div = function(y) {
      return this.divmod(y, "div", !1).div;
    }, S.prototype.mod = function(y) {
      return this.divmod(y, "mod", !1).mod;
    }, S.prototype.umod = function(y) {
      return this.divmod(y, "mod", !0).mod;
    }, S.prototype.divRound = function(y) {
      var E = this.divmod(y);
      if (E.mod.isZero()) return E.div;
      var A = E.div.negative !== 0 ? E.mod.isub(y) : E.mod, B = y.ushrn(1), O = y.andln(1), C = A.cmp(B);
      return C < 0 || O === 1 && C === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
    }, S.prototype.modn = function(y) {
      $(y <= 67108863);
      for (var E = (1 << 26) % y, A = 0, B = this.length - 1; B >= 0; B--)
        A = (E * A + (this.words[B] | 0)) % y;
      return A;
    }, S.prototype.idivn = function(y) {
      $(y <= 67108863);
      for (var E = 0, A = this.length - 1; A >= 0; A--) {
        var B = (this.words[A] | 0) + E * 67108864;
        this.words[A] = B / y | 0, E = B % y;
      }
      return this.strip();
    }, S.prototype.divn = function(y) {
      return this.clone().idivn(y);
    }, S.prototype.egcd = function(y) {
      $(y.negative === 0), $(!y.isZero());
      var E = this, A = y.clone();
      E.negative !== 0 ? E = E.umod(y) : E = E.clone();
      for (var B = new S(1), O = new S(0), C = new S(0), L = new S(1), P = 0; E.isEven() && A.isEven(); )
        E.iushrn(1), A.iushrn(1), ++P;
      for (var _ = A.clone(), I = E.clone(); !E.isZero(); ) {
        for (var U = 0, Y = 1; !(E.words[0] & Y) && U < 26; ++U, Y <<= 1) ;
        if (U > 0)
          for (E.iushrn(U); U-- > 0; )
            (B.isOdd() || O.isOdd()) && (B.iadd(_), O.isub(I)), B.iushrn(1), O.iushrn(1);
        for (var te = 0, oe = 1; !(A.words[0] & oe) && te < 26; ++te, oe <<= 1) ;
        if (te > 0)
          for (A.iushrn(te); te-- > 0; )
            (C.isOdd() || L.isOdd()) && (C.iadd(_), L.isub(I)), C.iushrn(1), L.iushrn(1);
        E.cmp(A) >= 0 ? (E.isub(A), B.isub(C), O.isub(L)) : (A.isub(E), C.isub(B), L.isub(O));
      }
      return {
        a: C,
        b: L,
        gcd: A.iushln(P)
      };
    }, S.prototype._invmp = function(y) {
      $(y.negative === 0), $(!y.isZero());
      var E = this, A = y.clone();
      E.negative !== 0 ? E = E.umod(y) : E = E.clone();
      for (var B = new S(1), O = new S(0), C = A.clone(); E.cmpn(1) > 0 && A.cmpn(1) > 0; ) {
        for (var L = 0, P = 1; !(E.words[0] & P) && L < 26; ++L, P <<= 1) ;
        if (L > 0)
          for (E.iushrn(L); L-- > 0; )
            B.isOdd() && B.iadd(C), B.iushrn(1);
        for (var _ = 0, I = 1; !(A.words[0] & I) && _ < 26; ++_, I <<= 1) ;
        if (_ > 0)
          for (A.iushrn(_); _-- > 0; )
            O.isOdd() && O.iadd(C), O.iushrn(1);
        E.cmp(A) >= 0 ? (E.isub(A), B.isub(O)) : (A.isub(E), O.isub(B));
      }
      var U;
      return E.cmpn(1) === 0 ? U = B : U = O, U.cmpn(0) < 0 && U.iadd(y), U;
    }, S.prototype.gcd = function(y) {
      if (this.isZero()) return y.abs();
      if (y.isZero()) return this.abs();
      var E = this.clone(), A = y.clone();
      E.negative = 0, A.negative = 0;
      for (var B = 0; E.isEven() && A.isEven(); B++)
        E.iushrn(1), A.iushrn(1);
      do {
        for (; E.isEven(); )
          E.iushrn(1);
        for (; A.isEven(); )
          A.iushrn(1);
        var O = E.cmp(A);
        if (O < 0) {
          var C = E;
          E = A, A = C;
        } else if (O === 0 || A.cmpn(1) === 0)
          break;
        E.isub(A);
      } while (!0);
      return A.iushln(B);
    }, S.prototype.invm = function(y) {
      return this.egcd(y).a.umod(y);
    }, S.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, S.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, S.prototype.andln = function(y) {
      return this.words[0] & y;
    }, S.prototype.bincn = function(y) {
      $(typeof y == "number");
      var E = y % 26, A = (y - E) / 26, B = 1 << E;
      if (this.length <= A)
        return this._expand(A + 1), this.words[A] |= B, this;
      for (var O = B, C = A; O !== 0 && C < this.length; C++) {
        var L = this.words[C] | 0;
        L += O, O = L >>> 26, L &= 67108863, this.words[C] = L;
      }
      return O !== 0 && (this.words[C] = O, this.length++), this;
    }, S.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, S.prototype.cmpn = function(y) {
      var E = y < 0;
      if (this.negative !== 0 && !E) return -1;
      if (this.negative === 0 && E) return 1;
      this.strip();
      var A;
      if (this.length > 1)
        A = 1;
      else {
        E && (y = -y), $(y <= 67108863, "Number is too big");
        var B = this.words[0] | 0;
        A = B === y ? 0 : B < y ? -1 : 1;
      }
      return this.negative !== 0 ? -A | 0 : A;
    }, S.prototype.cmp = function(y) {
      if (this.negative !== 0 && y.negative === 0) return -1;
      if (this.negative === 0 && y.negative !== 0) return 1;
      var E = this.ucmp(y);
      return this.negative !== 0 ? -E | 0 : E;
    }, S.prototype.ucmp = function(y) {
      if (this.length > y.length) return 1;
      if (this.length < y.length) return -1;
      for (var E = 0, A = this.length - 1; A >= 0; A--) {
        var B = this.words[A] | 0, O = y.words[A] | 0;
        if (B !== O) {
          B < O ? E = -1 : B > O && (E = 1);
          break;
        }
      }
      return E;
    }, S.prototype.gtn = function(y) {
      return this.cmpn(y) === 1;
    }, S.prototype.gt = function(y) {
      return this.cmp(y) === 1;
    }, S.prototype.gten = function(y) {
      return this.cmpn(y) >= 0;
    }, S.prototype.gte = function(y) {
      return this.cmp(y) >= 0;
    }, S.prototype.ltn = function(y) {
      return this.cmpn(y) === -1;
    }, S.prototype.lt = function(y) {
      return this.cmp(y) === -1;
    }, S.prototype.lten = function(y) {
      return this.cmpn(y) <= 0;
    }, S.prototype.lte = function(y) {
      return this.cmp(y) <= 0;
    }, S.prototype.eqn = function(y) {
      return this.cmpn(y) === 0;
    }, S.prototype.eq = function(y) {
      return this.cmp(y) === 0;
    }, S.red = function(y) {
      return new xe(y);
    }, S.prototype.toRed = function(y) {
      return $(!this.red, "Already a number in reduction context"), $(this.negative === 0, "red works only with positives"), y.convertTo(this)._forceRed(y);
    }, S.prototype.fromRed = function() {
      return $(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, S.prototype._forceRed = function(y) {
      return this.red = y, this;
    }, S.prototype.forceRed = function(y) {
      return $(!this.red, "Already a number in reduction context"), this._forceRed(y);
    }, S.prototype.redAdd = function(y) {
      return $(this.red, "redAdd works only with red numbers"), this.red.add(this, y);
    }, S.prototype.redIAdd = function(y) {
      return $(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, y);
    }, S.prototype.redSub = function(y) {
      return $(this.red, "redSub works only with red numbers"), this.red.sub(this, y);
    }, S.prototype.redISub = function(y) {
      return $(this.red, "redISub works only with red numbers"), this.red.isub(this, y);
    }, S.prototype.redShl = function(y) {
      return $(this.red, "redShl works only with red numbers"), this.red.shl(this, y);
    }, S.prototype.redMul = function(y) {
      return $(this.red, "redMul works only with red numbers"), this.red._verify2(this, y), this.red.mul(this, y);
    }, S.prototype.redIMul = function(y) {
      return $(this.red, "redMul works only with red numbers"), this.red._verify2(this, y), this.red.imul(this, y);
    }, S.prototype.redSqr = function() {
      return $(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, S.prototype.redISqr = function() {
      return $(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, S.prototype.redSqrt = function() {
      return $(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, S.prototype.redInvm = function() {
      return $(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, S.prototype.redNeg = function() {
      return $(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, S.prototype.redPow = function(y) {
      return $(this.red && !y.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, y);
    };
    var ge = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function pe(N, y) {
      this.name = N, this.p = new S(y, 16), this.n = this.p.bitLength(), this.k = new S(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    pe.prototype._tmp = function() {
      var y = new S(null);
      return y.words = new Array(Math.ceil(this.n / 13)), y;
    }, pe.prototype.ireduce = function(y) {
      var E = y, A;
      do
        this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), A = E.bitLength();
      while (A > this.n);
      var B = A < this.n ? -1 : E.ucmp(this.p);
      return B === 0 ? (E.words[0] = 0, E.length = 1) : B > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
    }, pe.prototype.split = function(y, E) {
      y.iushrn(this.n, 0, E);
    }, pe.prototype.imulK = function(y) {
      return y.imul(this.k);
    };
    function $e() {
      pe.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    T($e, pe), $e.prototype.split = function(y, E) {
      for (var A = 4194303, B = Math.min(y.length, 9), O = 0; O < B; O++)
        E.words[O] = y.words[O];
      if (E.length = B, y.length <= 9) {
        y.words[0] = 0, y.length = 1;
        return;
      }
      var C = y.words[9];
      for (E.words[E.length++] = C & A, O = 10; O < y.length; O++) {
        var L = y.words[O] | 0;
        y.words[O - 10] = (L & A) << 4 | C >>> 22, C = L;
      }
      C >>>= 22, y.words[O - 10] = C, C === 0 && y.length > 10 ? y.length -= 10 : y.length -= 9;
    }, $e.prototype.imulK = function(y) {
      y.words[y.length] = 0, y.words[y.length + 1] = 0, y.length += 2;
      for (var E = 0, A = 0; A < y.length; A++) {
        var B = y.words[A] | 0;
        E += B * 977, y.words[A] = E & 67108863, E = B * 64 + (E / 67108864 | 0);
      }
      return y.words[y.length - 1] === 0 && (y.length--, y.words[y.length - 1] === 0 && y.length--), y;
    };
    function Re() {
      pe.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    T(Re, pe);
    function Pe() {
      pe.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    T(Pe, pe);
    function Oe() {
      pe.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    T(Oe, pe), Oe.prototype.imulK = function(y) {
      for (var E = 0, A = 0; A < y.length; A++) {
        var B = (y.words[A] | 0) * 19 + E, O = B & 67108863;
        B >>>= 26, y.words[A] = O, E = B;
      }
      return E !== 0 && (y.words[y.length++] = E), y;
    }, S._prime = function(y) {
      if (ge[y]) return ge[y];
      var E;
      if (y === "k256")
        E = new $e();
      else if (y === "p224")
        E = new Re();
      else if (y === "p192")
        E = new Pe();
      else if (y === "p25519")
        E = new Oe();
      else
        throw new Error("Unknown prime " + y);
      return ge[y] = E, E;
    };
    function xe(N) {
      if (typeof N == "string") {
        var y = S._prime(N);
        this.m = y.p, this.prime = y;
      } else
        $(N.gtn(1), "modulus must be greater than 1"), this.m = N, this.prime = null;
    }
    xe.prototype._verify1 = function(y) {
      $(y.negative === 0, "red works only with positives"), $(y.red, "red works only with red numbers");
    }, xe.prototype._verify2 = function(y, E) {
      $((y.negative | E.negative) === 0, "red works only with positives"), $(
        y.red && y.red === E.red,
        "red works only with red numbers"
      );
    }, xe.prototype.imod = function(y) {
      return this.prime ? this.prime.ireduce(y)._forceRed(this) : y.umod(this.m)._forceRed(this);
    }, xe.prototype.neg = function(y) {
      return y.isZero() ? y.clone() : this.m.sub(y)._forceRed(this);
    }, xe.prototype.add = function(y, E) {
      this._verify2(y, E);
      var A = y.add(E);
      return A.cmp(this.m) >= 0 && A.isub(this.m), A._forceRed(this);
    }, xe.prototype.iadd = function(y, E) {
      this._verify2(y, E);
      var A = y.iadd(E);
      return A.cmp(this.m) >= 0 && A.isub(this.m), A;
    }, xe.prototype.sub = function(y, E) {
      this._verify2(y, E);
      var A = y.sub(E);
      return A.cmpn(0) < 0 && A.iadd(this.m), A._forceRed(this);
    }, xe.prototype.isub = function(y, E) {
      this._verify2(y, E);
      var A = y.isub(E);
      return A.cmpn(0) < 0 && A.iadd(this.m), A;
    }, xe.prototype.shl = function(y, E) {
      return this._verify1(y), this.imod(y.ushln(E));
    }, xe.prototype.imul = function(y, E) {
      return this._verify2(y, E), this.imod(y.imul(E));
    }, xe.prototype.mul = function(y, E) {
      return this._verify2(y, E), this.imod(y.mul(E));
    }, xe.prototype.isqr = function(y) {
      return this.imul(y, y.clone());
    }, xe.prototype.sqr = function(y) {
      return this.mul(y, y);
    }, xe.prototype.sqrt = function(y) {
      if (y.isZero()) return y.clone();
      var E = this.m.andln(3);
      if ($(E % 2 === 1), E === 3) {
        var A = this.m.add(new S(1)).iushrn(2);
        return this.pow(y, A);
      }
      for (var B = this.m.subn(1), O = 0; !B.isZero() && B.andln(1) === 0; )
        O++, B.iushrn(1);
      $(!B.isZero());
      var C = new S(1).toRed(this), L = C.redNeg(), P = this.m.subn(1).iushrn(1), _ = this.m.bitLength();
      for (_ = new S(2 * _ * _).toRed(this); this.pow(_, P).cmp(L) !== 0; )
        _.redIAdd(L);
      for (var I = this.pow(_, B), U = this.pow(y, B.addn(1).iushrn(1)), Y = this.pow(y, B), te = O; Y.cmp(C) !== 0; ) {
        for (var oe = Y, re = 0; oe.cmp(C) !== 0; re++)
          oe = oe.redSqr();
        $(re < te);
        var ee = this.pow(I, new S(1).iushln(te - re - 1));
        U = U.redMul(ee), I = ee.redSqr(), Y = Y.redMul(I), te = re;
      }
      return U;
    }, xe.prototype.invm = function(y) {
      var E = y._invmp(this.m);
      return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
    }, xe.prototype.pow = function(y, E) {
      if (E.isZero()) return new S(1).toRed(this);
      if (E.cmpn(1) === 0) return y.clone();
      var A = 4, B = new Array(1 << A);
      B[0] = new S(1).toRed(this), B[1] = y;
      for (var O = 2; O < B.length; O++)
        B[O] = this.mul(B[O - 1], y);
      var C = B[0], L = 0, P = 0, _ = E.bitLength() % 26;
      for (_ === 0 && (_ = 26), O = E.length - 1; O >= 0; O--) {
        for (var I = E.words[O], U = _ - 1; U >= 0; U--) {
          var Y = I >> U & 1;
          if (C !== B[0] && (C = this.sqr(C)), Y === 0 && L === 0) {
            P = 0;
            continue;
          }
          L <<= 1, L |= Y, P++, !(P !== A && (O !== 0 || U !== 0)) && (C = this.mul(C, B[L]), P = 0, L = 0);
        }
        _ = 26;
      }
      return C;
    }, xe.prototype.convertTo = function(y) {
      var E = y.umod(this.m);
      return E === y ? E.clone() : E;
    }, xe.prototype.convertFrom = function(y) {
      var E = y.clone();
      return E.red = null, E;
    }, S.mont = function(y) {
      return new rt(y);
    };
    function rt(N) {
      xe.call(this, N), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new S(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    T(rt, xe), rt.prototype.convertTo = function(y) {
      return this.imod(y.ushln(this.shift));
    }, rt.prototype.convertFrom = function(y) {
      var E = this.imod(y.mul(this.rinv));
      return E.red = null, E;
    }, rt.prototype.imul = function(y, E) {
      if (y.isZero() || E.isZero())
        return y.words[0] = 0, y.length = 1, y;
      var A = y.imul(E), B = A.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), O = A.isub(B).iushrn(this.shift), C = O;
      return O.cmp(this.m) >= 0 ? C = O.isub(this.m) : O.cmpn(0) < 0 && (C = O.iadd(this.m)), C._forceRed(this);
    }, rt.prototype.mul = function(y, E) {
      if (y.isZero() || E.isZero()) return new S(0)._forceRed(this);
      var A = y.mul(E), B = A.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), O = A.isub(B).iushrn(this.shift), C = O;
      return O.cmp(this.m) >= 0 ? C = O.isub(this.m) : O.cmpn(0) < 0 && (C = O.iadd(this.m)), C._forceRed(this);
    }, rt.prototype.invm = function(y) {
      var E = this.imod(y._invmp(this.m).mul(this.r2));
      return E._forceRed(this);
    };
  })(w, commonjsGlobal);
})(bn$5);
var bnExports$5 = bn$5.exports, brorand = { exports: {} }, hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand) return brorand.exports;
  hasRequiredBrorand = 1;
  var w;
  brorand.exports = function(T) {
    return w || (w = new M(null)), w.generate(T);
  };
  function M($) {
    this.rand = $;
  }
  if (brorand.exports.Rand = M, M.prototype.generate = function(T) {
    return this._rand(T);
  }, M.prototype._rand = function(T) {
    if (this.rand.getBytes)
      return this.rand.getBytes(T);
    for (var S = new Uint8Array(T), D = 0; D < S.length; D++)
      S[D] = this.rand.getByte();
    return S;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? M.prototype._rand = function(T) {
      var S = new Uint8Array(T);
      return self.crypto.getRandomValues(S), S;
    } : self.msCrypto && self.msCrypto.getRandomValues ? M.prototype._rand = function(T) {
      var S = new Uint8Array(T);
      return self.msCrypto.getRandomValues(S), S;
    } : typeof window == "object" && (M.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var x = requireCryptoBrowserify();
      if (typeof x.randomBytes != "function")
        throw new Error("Not supported");
      M.prototype._rand = function(T) {
        return x.randomBytes(T);
      };
    } catch {
    }
  return brorand.exports;
}
var mr, hasRequiredMr;
function requireMr() {
  if (hasRequiredMr) return mr;
  hasRequiredMr = 1;
  var w = bnExports$5, M = requireBrorand();
  function x($) {
    this.rand = $ || new M.Rand();
  }
  return mr = x, x.create = function(T) {
    return new x(T);
  }, x.prototype._randbelow = function(T) {
    var S = T.bitLength(), D = Math.ceil(S / 8);
    do
      var F = new w(this.rand.generate(D));
    while (F.cmp(T) >= 0);
    return F;
  }, x.prototype._randrange = function(T, S) {
    var D = S.sub(T);
    return T.add(this._randbelow(D));
  }, x.prototype.test = function(T, S, D) {
    var F = T.bitLength(), z = w.mont(T), Z = new w(1).toRed(z);
    S || (S = Math.max(1, F / 48 | 0));
    for (var H = T.subn(1), V = 0; !H.testn(V); V++)
      ;
    for (var X = T.shrn(V), Q = H.toRed(z), fe = !0; S > 0; S--) {
      var ce = this._randrange(new w(2), H);
      D && D(ce);
      var me = ce.toRed(z).redPow(X);
      if (!(me.cmp(Z) === 0 || me.cmp(Q) === 0)) {
        for (var de = 1; de < V; de++) {
          if (me = me.redSqr(), me.cmp(Z) === 0)
            return !1;
          if (me.cmp(Q) === 0)
            break;
        }
        if (de === V)
          return !1;
      }
    }
    return fe;
  }, x.prototype.getDivisor = function(T, S) {
    var D = T.bitLength(), F = w.mont(T), z = new w(1).toRed(F);
    S || (S = Math.max(1, D / 48 | 0));
    for (var Z = T.subn(1), H = 0; !Z.testn(H); H++)
      ;
    for (var V = T.shrn(H), X = Z.toRed(F); S > 0; S--) {
      var Q = this._randrange(new w(2), Z), fe = T.gcd(Q);
      if (fe.cmpn(1) !== 0)
        return fe;
      var ce = Q.toRed(F).redPow(V);
      if (!(ce.cmp(z) === 0 || ce.cmp(X) === 0)) {
        for (var me = 1; me < H; me++) {
          if (ce = ce.redSqr(), ce.cmp(z) === 0)
            return ce.fromRed().subn(1).gcd(T);
          if (ce.cmp(X) === 0)
            break;
        }
        if (me === H)
          return ce = ce.redSqr(), ce.fromRed().subn(1).gcd(T);
      }
    }
    return !1;
  }, mr;
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime) return generatePrime;
  hasRequiredGeneratePrime = 1;
  var w = browserExports;
  generatePrime = me, me.simpleSieve = fe, me.fermatTest = ce;
  var M = bnExports$6, x = new M(24), $ = requireMr(), T = new $(), S = new M(1), D = new M(2), F = new M(5);
  new M(16), new M(8);
  var z = new M(10), Z = new M(3);
  new M(7);
  var H = new M(11), V = new M(4);
  new M(12);
  var X = null;
  function Q() {
    if (X !== null)
      return X;
    var de = 1048576, ne = [];
    ne[0] = 2;
    for (var ge = 1, pe = 3; pe < de; pe += 2) {
      for (var $e = Math.ceil(Math.sqrt(pe)), Re = 0; Re < ge && ne[Re] <= $e && pe % ne[Re] !== 0; Re++)
        ;
      ge !== Re && ne[Re] <= $e || (ne[ge++] = pe);
    }
    return X = ne, ne;
  }
  function fe(de) {
    for (var ne = Q(), ge = 0; ge < ne.length; ge++)
      if (de.modn(ne[ge]) === 0)
        return de.cmpn(ne[ge]) === 0;
    return !0;
  }
  function ce(de) {
    var ne = M.mont(de);
    return D.toRed(ne).redPow(de.subn(1)).fromRed().cmpn(1) === 0;
  }
  function me(de, ne) {
    if (de < 16)
      return ne === 2 || ne === 5 ? new M([140, 123]) : new M([140, 39]);
    ne = new M(ne);
    for (var ge, pe; ; ) {
      for (ge = new M(w(Math.ceil(de / 8))); ge.bitLength() > de; )
        ge.ishrn(1);
      if (ge.isEven() && ge.iadd(S), ge.testn(1) || ge.iadd(D), ne.cmp(D)) {
        if (!ne.cmp(F))
          for (; ge.mod(z).cmp(Z); )
            ge.iadd(V);
      } else for (; ge.mod(x).cmp(H); )
        ge.iadd(V);
      if (pe = ge.shrn(1), fe(pe) && fe(ge) && ce(pe) && ce(ge) && T.test(pe) && T.test(ge))
        return ge;
    }
  }
  return generatePrime;
}
const modp1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, modp2 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, modp5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, modp14 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, modp15 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, modp16 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, modp17 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, modp18 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, require$$1$1 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh, hasRequiredDh;
function requireDh() {
  if (hasRequiredDh) return dh;
  hasRequiredDh = 1;
  var w = bnExports$6, M = requireMr(), x = new M(), $ = new w(24), T = new w(11), S = new w(10), D = new w(3), F = new w(7), z = requireGeneratePrime(), Z = browserExports;
  dh = fe;
  function H(me, de) {
    return de = de || "utf8", Buffer$D.isBuffer(me) || (me = new Buffer$D(me, de)), this._pub = new w(me), this;
  }
  function V(me, de) {
    return de = de || "utf8", Buffer$D.isBuffer(me) || (me = new Buffer$D(me, de)), this._priv = new w(me), this;
  }
  var X = {};
  function Q(me, de) {
    var ne = de.toString("hex"), ge = [ne, me.toString(16)].join("_");
    if (ge in X)
      return X[ge];
    var pe = 0;
    if (me.isEven() || !z.simpleSieve || !z.fermatTest(me) || !x.test(me))
      return pe += 1, ne === "02" || ne === "05" ? pe += 8 : pe += 4, X[ge] = pe, pe;
    x.test(me.shrn(1)) || (pe += 2);
    var $e;
    switch (ne) {
      case "02":
        me.mod($).cmp(T) && (pe += 8);
        break;
      case "05":
        $e = me.mod(S), $e.cmp(D) && $e.cmp(F) && (pe += 8);
        break;
      default:
        pe += 4;
    }
    return X[ge] = pe, pe;
  }
  function fe(me, de, ne) {
    this.setGenerator(de), this.__prime = new w(me), this._prime = w.mont(this.__prime), this._primeLen = me.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, ne ? (this.setPublicKey = H, this.setPrivateKey = V) : this._primeCode = 8;
  }
  Object.defineProperty(fe.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = Q(this.__prime, this.__gen)), this._primeCode;
    }
  }), fe.prototype.generateKeys = function() {
    return this._priv || (this._priv = new w(Z(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, fe.prototype.computeSecret = function(me) {
    me = new w(me), me = me.toRed(this._prime);
    var de = me.redPow(this._priv).fromRed(), ne = new Buffer$D(de.toArray()), ge = this.getPrime();
    if (ne.length < ge.length) {
      var pe = new Buffer$D(ge.length - ne.length);
      pe.fill(0), ne = Buffer$D.concat([pe, ne]);
    }
    return ne;
  }, fe.prototype.getPublicKey = function(de) {
    return ce(this._pub, de);
  }, fe.prototype.getPrivateKey = function(de) {
    return ce(this._priv, de);
  }, fe.prototype.getPrime = function(me) {
    return ce(this.__prime, me);
  }, fe.prototype.getGenerator = function(me) {
    return ce(this._gen, me);
  }, fe.prototype.setGenerator = function(me, de) {
    return de = de || "utf8", Buffer$D.isBuffer(me) || (me = new Buffer$D(me, de)), this.__gen = me, this._gen = new w(me), this;
  };
  function ce(me, de) {
    var ne = new Buffer$D(me.toArray());
    return de ? ne.toString(de) : ne;
  }
  return dh;
}
var hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2) return browser$4;
  hasRequiredBrowser$2 = 1;
  var w = requireGeneratePrime(), M = require$$1$1, x = requireDh();
  function $(D) {
    var F = new Buffer$D(M[D].prime, "hex"), z = new Buffer$D(M[D].gen, "hex");
    return new x(F, z);
  }
  var T = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function S(D, F, z, Z) {
    return Buffer$D.isBuffer(F) || T[F] === void 0 ? S(D, "binary", F, z) : (F = F || "binary", Z = Z || "binary", z = z || new Buffer$D([2]), Buffer$D.isBuffer(z) || (z = new Buffer$D(z, Z)), typeof D == "number" ? new x(w(D, z), z, !0) : (Buffer$D.isBuffer(D) || (D = new Buffer$D(D, F)), new x(D, z, !0)));
  }
  return browser$4.DiffieHellmanGroup = browser$4.createDiffieHellmanGroup = browser$4.getDiffieHellman = $, browser$4.createDiffieHellman = browser$4.DiffieHellman = S, browser$4;
}
var readableBrowser = { exports: {} }, processNextickArgs = { exports: {} };
typeof process$1 > "u" || !process$1.version || process$1.version.indexOf("v0.") === 0 || process$1.version.indexOf("v1.") === 0 && process$1.version.indexOf("v1.8.") !== 0 ? processNextickArgs.exports = { nextTick } : processNextickArgs.exports = process$1;
function nextTick(w, M, x, $) {
  if (typeof w != "function")
    throw new TypeError('"callback" argument must be a function');
  var T = arguments.length, S, D;
  switch (T) {
    case 0:
    case 1:
      return process$1.nextTick(w);
    case 2:
      return process$1.nextTick(function() {
        w.call(null, M);
      });
    case 3:
      return process$1.nextTick(function() {
        w.call(null, M, x);
      });
    case 4:
      return process$1.nextTick(function() {
        w.call(null, M, x, $);
      });
    default:
      for (S = new Array(T - 1), D = 0; D < S.length; )
        S[D++] = arguments[D];
      return process$1.nextTick(function() {
        w.apply(null, S);
      });
  }
}
var processNextickArgsExports = processNextickArgs.exports, toString = {}.toString, isarray = Array.isArray || function(w) {
  return toString.call(w) == "[object Array]";
}, streamBrowser = eventsExports.EventEmitter, safeBuffer$1 = { exports: {} };
(function(w, M) {
  var x = dist, $ = x.Buffer;
  function T(D, F) {
    for (var z in D)
      F[z] = D[z];
  }
  $.from && $.alloc && $.allocUnsafe && $.allocUnsafeSlow ? w.exports = x : (T(x, M), M.Buffer = S);
  function S(D, F, z) {
    return $(D, F, z);
  }
  T($, S), S.from = function(D, F, z) {
    if (typeof D == "number")
      throw new TypeError("Argument must not be a number");
    return $(D, F, z);
  }, S.alloc = function(D, F, z) {
    if (typeof D != "number")
      throw new TypeError("Argument must be a number");
    var Z = $(D);
    return F !== void 0 ? typeof z == "string" ? Z.fill(F, z) : Z.fill(F) : Z.fill(0), Z;
  }, S.allocUnsafe = function(D) {
    if (typeof D != "number")
      throw new TypeError("Argument must be a number");
    return $(D);
  }, S.allocUnsafeSlow = function(D) {
    if (typeof D != "number")
      throw new TypeError("Argument must be a number");
    return x.SlowBuffer(D);
  };
})(safeBuffer$1, safeBuffer$1.exports);
var safeBufferExports = safeBuffer$1.exports, util$2 = {};
function isArray(w) {
  return Array.isArray ? Array.isArray(w) : objectToString(w) === "[object Array]";
}
util$2.isArray = isArray;
function isBoolean(w) {
  return typeof w == "boolean";
}
util$2.isBoolean = isBoolean;
function isNull(w) {
  return w === null;
}
util$2.isNull = isNull;
function isNullOrUndefined(w) {
  return w == null;
}
util$2.isNullOrUndefined = isNullOrUndefined;
function isNumber(w) {
  return typeof w == "number";
}
util$2.isNumber = isNumber;
function isString(w) {
  return typeof w == "string";
}
util$2.isString = isString;
function isSymbol(w) {
  return typeof w == "symbol";
}
util$2.isSymbol = isSymbol;
function isUndefined(w) {
  return w === void 0;
}
util$2.isUndefined = isUndefined;
function isRegExp(w) {
  return objectToString(w) === "[object RegExp]";
}
util$2.isRegExp = isRegExp;
function isObject(w) {
  return typeof w == "object" && w !== null;
}
util$2.isObject = isObject;
function isDate(w) {
  return objectToString(w) === "[object Date]";
}
util$2.isDate = isDate;
function isError(w) {
  return objectToString(w) === "[object Error]" || w instanceof Error;
}
util$2.isError = isError;
function isFunction(w) {
  return typeof w == "function";
}
util$2.isFunction = isFunction;
function isPrimitive(w) {
  return w === null || typeof w == "boolean" || typeof w == "number" || typeof w == "string" || typeof w == "symbol" || // ES6 symbol
  typeof w > "u";
}
util$2.isPrimitive = isPrimitive;
util$2.isBuffer = dist.Buffer.isBuffer;
function objectToString(w) {
  return Object.prototype.toString.call(w);
}
var BufferList = { exports: {} }, hasRequiredBufferList;
function requireBufferList() {
  return hasRequiredBufferList || (hasRequiredBufferList = 1, function(w) {
    function M(S, D) {
      if (!(S instanceof D))
        throw new TypeError("Cannot call a class as a function");
    }
    var x = safeBufferExports.Buffer, $ = util$3;
    function T(S, D, F) {
      S.copy(D, F);
    }
    w.exports = function() {
      function S() {
        M(this, S), this.head = null, this.tail = null, this.length = 0;
      }
      return S.prototype.push = function(F) {
        var z = { data: F, next: null };
        this.length > 0 ? this.tail.next = z : this.head = z, this.tail = z, ++this.length;
      }, S.prototype.unshift = function(F) {
        var z = { data: F, next: this.head };
        this.length === 0 && (this.tail = z), this.head = z, ++this.length;
      }, S.prototype.shift = function() {
        if (this.length !== 0) {
          var F = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, F;
        }
      }, S.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, S.prototype.join = function(F) {
        if (this.length === 0) return "";
        for (var z = this.head, Z = "" + z.data; z = z.next; )
          Z += F + z.data;
        return Z;
      }, S.prototype.concat = function(F) {
        if (this.length === 0) return x.alloc(0);
        for (var z = x.allocUnsafe(F >>> 0), Z = this.head, H = 0; Z; )
          T(Z.data, z, H), H += Z.data.length, Z = Z.next;
        return z;
      }, S;
    }(), $ && $.inspect && $.inspect.custom && (w.exports.prototype[$.inspect.custom] = function() {
      var S = $.inspect({ length: this.length });
      return this.constructor.name + " " + S;
    });
  }(BufferList)), BufferList.exports;
}
var pna = processNextickArgsExports;
function destroy(w, M) {
  var x = this, $ = this._readableState && this._readableState.destroyed, T = this._writableState && this._writableState.destroyed;
  return $ || T ? (M ? M(w) : w && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, pna.nextTick(emitErrorNT, this, w)) : pna.nextTick(emitErrorNT, this, w)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(w || null, function(S) {
    !M && S ? x._writableState ? x._writableState.errorEmitted || (x._writableState.errorEmitted = !0, pna.nextTick(emitErrorNT, x, S)) : pna.nextTick(emitErrorNT, x, S) : M && M(S);
  }), this);
}
function undestroy() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function emitErrorNT(w, M) {
  w.emit("error", M);
}
var destroy_1 = {
  destroy,
  undestroy
}, _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable) return _stream_writable;
  hasRequired_stream_writable = 1;
  var w = processNextickArgsExports;
  _stream_writable = ce;
  function M(C) {
    var L = this;
    this.next = null, this.entry = null, this.finish = function() {
      O(L, C);
    };
  }
  var x = !process$1.browser && ["v0.10", "v0.9."].indexOf(process$1.version.slice(0, 5)) > -1 ? setImmediate : w.nextTick, $;
  ce.WritableState = Q;
  var T = Object.create(util$2);
  T.inherits = inherits_browserExports;
  var S = {
    deprecate: browser$a
  }, D = streamBrowser, F = safeBufferExports.Buffer, z = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function Z(C) {
    return F.from(C);
  }
  function H(C) {
    return F.isBuffer(C) || C instanceof z;
  }
  var V = destroy_1;
  T.inherits(ce, D);
  function X() {
  }
  function Q(C, L) {
    $ = $ || require_stream_duplex(), C = C || {};
    var P = L instanceof $;
    this.objectMode = !!C.objectMode, P && (this.objectMode = this.objectMode || !!C.writableObjectMode);
    var _ = C.highWaterMark, I = C.writableHighWaterMark, U = this.objectMode ? 16 : 16 * 1024;
    _ || _ === 0 ? this.highWaterMark = _ : P && (I || I === 0) ? this.highWaterMark = I : this.highWaterMark = U, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Y = C.decodeStrings === !1;
    this.decodeStrings = !Y, this.defaultEncoding = C.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(te) {
      Pe(L, te);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new M(this);
  }
  Q.prototype.getBuffer = function() {
    for (var L = this.bufferedRequest, P = []; L; )
      P.push(L), L = L.next;
    return P;
  }, function() {
    try {
      Object.defineProperty(Q.prototype, "buffer", {
        get: S.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var fe;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (fe = Function.prototype[Symbol.hasInstance], Object.defineProperty(ce, Symbol.hasInstance, {
    value: function(C) {
      return fe.call(this, C) ? !0 : this !== ce ? !1 : C && C._writableState instanceof Q;
    }
  })) : fe = function(C) {
    return C instanceof this;
  };
  function ce(C) {
    if ($ = $ || require_stream_duplex(), !fe.call(ce, this) && !(this instanceof $))
      return new ce(C);
    this._writableState = new Q(C, this), this.writable = !0, C && (typeof C.write == "function" && (this._write = C.write), typeof C.writev == "function" && (this._writev = C.writev), typeof C.destroy == "function" && (this._destroy = C.destroy), typeof C.final == "function" && (this._final = C.final)), D.call(this);
  }
  ce.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function me(C, L) {
    var P = new Error("write after end");
    C.emit("error", P), w.nextTick(L, P);
  }
  function de(C, L, P, _) {
    var I = !0, U = !1;
    return P === null ? U = new TypeError("May not write null values to stream") : typeof P != "string" && P !== void 0 && !L.objectMode && (U = new TypeError("Invalid non-string/buffer chunk")), U && (C.emit("error", U), w.nextTick(_, U), I = !1), I;
  }
  ce.prototype.write = function(C, L, P) {
    var _ = this._writableState, I = !1, U = !_.objectMode && H(C);
    return U && !F.isBuffer(C) && (C = Z(C)), typeof L == "function" && (P = L, L = null), U ? L = "buffer" : L || (L = _.defaultEncoding), typeof P != "function" && (P = X), _.ended ? me(this, P) : (U || de(this, _, C, P)) && (_.pendingcb++, I = ge(this, _, U, C, L, P)), I;
  }, ce.prototype.cork = function() {
    var C = this._writableState;
    C.corked++;
  }, ce.prototype.uncork = function() {
    var C = this._writableState;
    C.corked && (C.corked--, !C.writing && !C.corked && !C.bufferProcessing && C.bufferedRequest && rt(this, C));
  }, ce.prototype.setDefaultEncoding = function(L) {
    if (typeof L == "string" && (L = L.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((L + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + L);
    return this._writableState.defaultEncoding = L, this;
  };
  function ne(C, L, P) {
    return !C.objectMode && C.decodeStrings !== !1 && typeof L == "string" && (L = F.from(L, P)), L;
  }
  Object.defineProperty(ce.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function ge(C, L, P, _, I, U) {
    if (!P) {
      var Y = ne(L, _, I);
      _ !== Y && (P = !0, I = "buffer", _ = Y);
    }
    var te = L.objectMode ? 1 : _.length;
    L.length += te;
    var oe = L.length < L.highWaterMark;
    if (oe || (L.needDrain = !0), L.writing || L.corked) {
      var re = L.lastBufferedRequest;
      L.lastBufferedRequest = {
        chunk: _,
        encoding: I,
        isBuf: P,
        callback: U,
        next: null
      }, re ? re.next = L.lastBufferedRequest : L.bufferedRequest = L.lastBufferedRequest, L.bufferedRequestCount += 1;
    } else
      pe(C, L, !1, te, _, I, U);
    return oe;
  }
  function pe(C, L, P, _, I, U, Y) {
    L.writelen = _, L.writecb = Y, L.writing = !0, L.sync = !0, P ? C._writev(I, L.onwrite) : C._write(I, U, L.onwrite), L.sync = !1;
  }
  function $e(C, L, P, _, I) {
    --L.pendingcb, P ? (w.nextTick(I, _), w.nextTick(A, C, L), C._writableState.errorEmitted = !0, C.emit("error", _)) : (I(_), C._writableState.errorEmitted = !0, C.emit("error", _), A(C, L));
  }
  function Re(C) {
    C.writing = !1, C.writecb = null, C.length -= C.writelen, C.writelen = 0;
  }
  function Pe(C, L) {
    var P = C._writableState, _ = P.sync, I = P.writecb;
    if (Re(P), L) $e(C, P, _, L, I);
    else {
      var U = N(P);
      !U && !P.corked && !P.bufferProcessing && P.bufferedRequest && rt(C, P), _ ? x(Oe, C, P, U, I) : Oe(C, P, U, I);
    }
  }
  function Oe(C, L, P, _) {
    P || xe(C, L), L.pendingcb--, _(), A(C, L);
  }
  function xe(C, L) {
    L.length === 0 && L.needDrain && (L.needDrain = !1, C.emit("drain"));
  }
  function rt(C, L) {
    L.bufferProcessing = !0;
    var P = L.bufferedRequest;
    if (C._writev && P && P.next) {
      var _ = L.bufferedRequestCount, I = new Array(_), U = L.corkedRequestsFree;
      U.entry = P;
      for (var Y = 0, te = !0; P; )
        I[Y] = P, P.isBuf || (te = !1), P = P.next, Y += 1;
      I.allBuffers = te, pe(C, L, !0, L.length, I, "", U.finish), L.pendingcb++, L.lastBufferedRequest = null, U.next ? (L.corkedRequestsFree = U.next, U.next = null) : L.corkedRequestsFree = new M(L), L.bufferedRequestCount = 0;
    } else {
      for (; P; ) {
        var oe = P.chunk, re = P.encoding, ee = P.callback, ae = L.objectMode ? 1 : oe.length;
        if (pe(C, L, !1, ae, oe, re, ee), P = P.next, L.bufferedRequestCount--, L.writing)
          break;
      }
      P === null && (L.lastBufferedRequest = null);
    }
    L.bufferedRequest = P, L.bufferProcessing = !1;
  }
  ce.prototype._write = function(C, L, P) {
    P(new Error("_write() is not implemented"));
  }, ce.prototype._writev = null, ce.prototype.end = function(C, L, P) {
    var _ = this._writableState;
    typeof C == "function" ? (P = C, C = null, L = null) : typeof L == "function" && (P = L, L = null), C != null && this.write(C, L), _.corked && (_.corked = 1, this.uncork()), _.ending || B(this, _, P);
  };
  function N(C) {
    return C.ending && C.length === 0 && C.bufferedRequest === null && !C.finished && !C.writing;
  }
  function y(C, L) {
    C._final(function(P) {
      L.pendingcb--, P && C.emit("error", P), L.prefinished = !0, C.emit("prefinish"), A(C, L);
    });
  }
  function E(C, L) {
    !L.prefinished && !L.finalCalled && (typeof C._final == "function" ? (L.pendingcb++, L.finalCalled = !0, w.nextTick(y, C, L)) : (L.prefinished = !0, C.emit("prefinish")));
  }
  function A(C, L) {
    var P = N(L);
    return P && (E(C, L), L.pendingcb === 0 && (L.finished = !0, C.emit("finish"))), P;
  }
  function B(C, L, P) {
    L.ending = !0, A(C, L), P && (L.finished ? w.nextTick(P) : C.once("finish", P)), L.ended = !0, C.writable = !1;
  }
  function O(C, L, P) {
    var _ = C.entry;
    for (C.entry = null; _; ) {
      var I = _.callback;
      L.pendingcb--, I(P), _ = _.next;
    }
    L.corkedRequestsFree.next = C;
  }
  return Object.defineProperty(ce.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(C) {
      this._writableState && (this._writableState.destroyed = C);
    }
  }), ce.prototype.destroy = V.destroy, ce.prototype._undestroy = V.undestroy, ce.prototype._destroy = function(C, L) {
    this.end(), L(C);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex) return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var w = processNextickArgsExports, M = Object.keys || function(V) {
    var X = [];
    for (var Q in V)
      X.push(Q);
    return X;
  };
  _stream_duplex = z;
  var x = Object.create(util$2);
  x.inherits = inherits_browserExports;
  var $ = require_stream_readable(), T = require_stream_writable();
  x.inherits(z, $);
  for (var S = M(T.prototype), D = 0; D < S.length; D++) {
    var F = S[D];
    z.prototype[F] || (z.prototype[F] = T.prototype[F]);
  }
  function z(V) {
    if (!(this instanceof z)) return new z(V);
    $.call(this, V), T.call(this, V), V && V.readable === !1 && (this.readable = !1), V && V.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, V && V.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", Z);
  }
  Object.defineProperty(z.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function Z() {
    this.allowHalfOpen || this._writableState.ended || w.nextTick(H, this);
  }
  function H(V) {
    V.end();
  }
  return Object.defineProperty(z.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(V) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = V, this._writableState.destroyed = V);
    }
  }), z.prototype._destroy = function(V, X) {
    this.push(null), this.end(), w.nextTick(X, V);
  }, _stream_duplex;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable) return _stream_readable;
  hasRequired_stream_readable = 1;
  var w = processNextickArgsExports;
  _stream_readable = ne;
  var M = isarray, x;
  ne.ReadableState = de, eventsExports.EventEmitter;
  var $ = function(ee, ae) {
    return ee.listeners(ae).length;
  }, T = streamBrowser, S = safeBufferExports.Buffer, D = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function F(ee) {
    return S.from(ee);
  }
  function z(ee) {
    return S.isBuffer(ee) || ee instanceof D;
  }
  var Z = Object.create(util$2);
  Z.inherits = inherits_browserExports;
  var H = util$3, V = void 0;
  H && H.debuglog ? V = H.debuglog("stream") : V = function() {
  };
  var X = requireBufferList(), Q = destroy_1, fe;
  Z.inherits(ne, T);
  var ce = ["error", "close", "destroy", "pause", "resume"];
  function me(ee, ae, ue) {
    if (typeof ee.prependListener == "function") return ee.prependListener(ae, ue);
    !ee._events || !ee._events[ae] ? ee.on(ae, ue) : M(ee._events[ae]) ? ee._events[ae].unshift(ue) : ee._events[ae] = [ue, ee._events[ae]];
  }
  function de(ee, ae) {
    x = x || require_stream_duplex(), ee = ee || {};
    var ue = ae instanceof x;
    this.objectMode = !!ee.objectMode, ue && (this.objectMode = this.objectMode || !!ee.readableObjectMode);
    var ye = ee.highWaterMark, ve = ee.readableHighWaterMark, he = this.objectMode ? 16 : 16 * 1024;
    ye || ye === 0 ? this.highWaterMark = ye : ue && (ve || ve === 0) ? this.highWaterMark = ve : this.highWaterMark = he, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new X(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = ee.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, ee.encoding && (fe || (fe = string_decoder.StringDecoder), this.decoder = new fe(ee.encoding), this.encoding = ee.encoding);
  }
  function ne(ee) {
    if (x = x || require_stream_duplex(), !(this instanceof ne)) return new ne(ee);
    this._readableState = new de(ee, this), this.readable = !0, ee && (typeof ee.read == "function" && (this._read = ee.read), typeof ee.destroy == "function" && (this._destroy = ee.destroy)), T.call(this);
  }
  Object.defineProperty(ne.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(ee) {
      this._readableState && (this._readableState.destroyed = ee);
    }
  }), ne.prototype.destroy = Q.destroy, ne.prototype._undestroy = Q.undestroy, ne.prototype._destroy = function(ee, ae) {
    this.push(null), ae(ee);
  }, ne.prototype.push = function(ee, ae) {
    var ue = this._readableState, ye;
    return ue.objectMode ? ye = !0 : typeof ee == "string" && (ae = ae || ue.defaultEncoding, ae !== ue.encoding && (ee = S.from(ee, ae), ae = ""), ye = !0), ge(this, ee, ae, !1, ye);
  }, ne.prototype.unshift = function(ee) {
    return ge(this, ee, null, !0, !1);
  };
  function ge(ee, ae, ue, ye, ve) {
    var he = ee._readableState;
    if (ae === null)
      he.reading = !1, rt(ee, he);
    else {
      var Me;
      ve || (Me = $e(he, ae)), Me ? ee.emit("error", Me) : he.objectMode || ae && ae.length > 0 ? (typeof ae != "string" && !he.objectMode && Object.getPrototypeOf(ae) !== S.prototype && (ae = F(ae)), ye ? he.endEmitted ? ee.emit("error", new Error("stream.unshift() after end event")) : pe(ee, he, ae, !0) : he.ended ? ee.emit("error", new Error("stream.push() after EOF")) : (he.reading = !1, he.decoder && !ue ? (ae = he.decoder.write(ae), he.objectMode || ae.length !== 0 ? pe(ee, he, ae, !1) : E(ee, he)) : pe(ee, he, ae, !1))) : ye || (he.reading = !1);
    }
    return Re(he);
  }
  function pe(ee, ae, ue, ye) {
    ae.flowing && ae.length === 0 && !ae.sync ? (ee.emit("data", ue), ee.read(0)) : (ae.length += ae.objectMode ? 1 : ue.length, ye ? ae.buffer.unshift(ue) : ae.buffer.push(ue), ae.needReadable && N(ee)), E(ee, ae);
  }
  function $e(ee, ae) {
    var ue;
    return !z(ae) && typeof ae != "string" && ae !== void 0 && !ee.objectMode && (ue = new TypeError("Invalid non-string/buffer chunk")), ue;
  }
  function Re(ee) {
    return !ee.ended && (ee.needReadable || ee.length < ee.highWaterMark || ee.length === 0);
  }
  ne.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, ne.prototype.setEncoding = function(ee) {
    return fe || (fe = string_decoder.StringDecoder), this._readableState.decoder = new fe(ee), this._readableState.encoding = ee, this;
  };
  var Pe = 8388608;
  function Oe(ee) {
    return ee >= Pe ? ee = Pe : (ee--, ee |= ee >>> 1, ee |= ee >>> 2, ee |= ee >>> 4, ee |= ee >>> 8, ee |= ee >>> 16, ee++), ee;
  }
  function xe(ee, ae) {
    return ee <= 0 || ae.length === 0 && ae.ended ? 0 : ae.objectMode ? 1 : ee !== ee ? ae.flowing && ae.length ? ae.buffer.head.data.length : ae.length : (ee > ae.highWaterMark && (ae.highWaterMark = Oe(ee)), ee <= ae.length ? ee : ae.ended ? ae.length : (ae.needReadable = !0, 0));
  }
  ne.prototype.read = function(ee) {
    V("read", ee), ee = parseInt(ee, 10);
    var ae = this._readableState, ue = ee;
    if (ee !== 0 && (ae.emittedReadable = !1), ee === 0 && ae.needReadable && (ae.length >= ae.highWaterMark || ae.ended))
      return V("read: emitReadable", ae.length, ae.ended), ae.length === 0 && ae.ended ? te(this) : N(this), null;
    if (ee = xe(ee, ae), ee === 0 && ae.ended)
      return ae.length === 0 && te(this), null;
    var ye = ae.needReadable;
    V("need readable", ye), (ae.length === 0 || ae.length - ee < ae.highWaterMark) && (ye = !0, V("length less than watermark", ye)), ae.ended || ae.reading ? (ye = !1, V("reading or ended", ye)) : ye && (V("do read"), ae.reading = !0, ae.sync = !0, ae.length === 0 && (ae.needReadable = !0), this._read(ae.highWaterMark), ae.sync = !1, ae.reading || (ee = xe(ue, ae)));
    var ve;
    return ee > 0 ? ve = _(ee, ae) : ve = null, ve === null ? (ae.needReadable = !0, ee = 0) : ae.length -= ee, ae.length === 0 && (ae.ended || (ae.needReadable = !0), ue !== ee && ae.ended && te(this)), ve !== null && this.emit("data", ve), ve;
  };
  function rt(ee, ae) {
    if (!ae.ended) {
      if (ae.decoder) {
        var ue = ae.decoder.end();
        ue && ue.length && (ae.buffer.push(ue), ae.length += ae.objectMode ? 1 : ue.length);
      }
      ae.ended = !0, N(ee);
    }
  }
  function N(ee) {
    var ae = ee._readableState;
    ae.needReadable = !1, ae.emittedReadable || (V("emitReadable", ae.flowing), ae.emittedReadable = !0, ae.sync ? w.nextTick(y, ee) : y(ee));
  }
  function y(ee) {
    V("emit readable"), ee.emit("readable"), P(ee);
  }
  function E(ee, ae) {
    ae.readingMore || (ae.readingMore = !0, w.nextTick(A, ee, ae));
  }
  function A(ee, ae) {
    for (var ue = ae.length; !ae.reading && !ae.flowing && !ae.ended && ae.length < ae.highWaterMark && (V("maybeReadMore read 0"), ee.read(0), ue !== ae.length); )
      ue = ae.length;
    ae.readingMore = !1;
  }
  ne.prototype._read = function(ee) {
    this.emit("error", new Error("_read() is not implemented"));
  }, ne.prototype.pipe = function(ee, ae) {
    var ue = this, ye = this._readableState;
    switch (ye.pipesCount) {
      case 0:
        ye.pipes = ee;
        break;
      case 1:
        ye.pipes = [ye.pipes, ee];
        break;
      default:
        ye.pipes.push(ee);
        break;
    }
    ye.pipesCount += 1, V("pipe count=%d opts=%j", ye.pipesCount, ae);
    var ve = (!ae || ae.end !== !1) && ee !== process$1.stdout && ee !== process$1.stderr, he = ve ? Qe : ot;
    ye.endEmitted ? w.nextTick(he) : ue.once("end", he), ee.on("unpipe", Me);
    function Me(be, _e) {
      V("onunpipe"), be === ue && _e && _e.hasUnpiped === !1 && (_e.hasUnpiped = !0, at());
    }
    function Qe() {
      V("onend"), ee.end();
    }
    var Ie = B(ue);
    ee.on("drain", Ie);
    var De = !1;
    function at() {
      V("cleanup"), ee.removeListener("close", qe), ee.removeListener("finish", He), ee.removeListener("drain", Ie), ee.removeListener("error", lt), ee.removeListener("unpipe", Me), ue.removeListener("end", Qe), ue.removeListener("end", ot), ue.removeListener("data", Se), De = !0, ye.awaitDrain && (!ee._writableState || ee._writableState.needDrain) && Ie();
    }
    var ke = !1;
    ue.on("data", Se);
    function Se(be) {
      V("ondata"), ke = !1;
      var _e = ee.write(be);
      _e === !1 && !ke && ((ye.pipesCount === 1 && ye.pipes === ee || ye.pipesCount > 1 && re(ye.pipes, ee) !== -1) && !De && (V("false write response, pause", ye.awaitDrain), ye.awaitDrain++, ke = !0), ue.pause());
    }
    function lt(be) {
      V("onerror", be), ot(), ee.removeListener("error", lt), $(ee, "error") === 0 && ee.emit("error", be);
    }
    me(ee, "error", lt);
    function qe() {
      ee.removeListener("finish", He), ot();
    }
    ee.once("close", qe);
    function He() {
      V("onfinish"), ee.removeListener("close", qe), ot();
    }
    ee.once("finish", He);
    function ot() {
      V("unpipe"), ue.unpipe(ee);
    }
    return ee.emit("pipe", ue), ye.flowing || (V("pipe resume"), ue.resume()), ee;
  };
  function B(ee) {
    return function() {
      var ae = ee._readableState;
      V("pipeOnDrain", ae.awaitDrain), ae.awaitDrain && ae.awaitDrain--, ae.awaitDrain === 0 && $(ee, "data") && (ae.flowing = !0, P(ee));
    };
  }
  ne.prototype.unpipe = function(ee) {
    var ae = this._readableState, ue = { hasUnpiped: !1 };
    if (ae.pipesCount === 0) return this;
    if (ae.pipesCount === 1)
      return ee && ee !== ae.pipes ? this : (ee || (ee = ae.pipes), ae.pipes = null, ae.pipesCount = 0, ae.flowing = !1, ee && ee.emit("unpipe", this, ue), this);
    if (!ee) {
      var ye = ae.pipes, ve = ae.pipesCount;
      ae.pipes = null, ae.pipesCount = 0, ae.flowing = !1;
      for (var he = 0; he < ve; he++)
        ye[he].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var Me = re(ae.pipes, ee);
    return Me === -1 ? this : (ae.pipes.splice(Me, 1), ae.pipesCount -= 1, ae.pipesCount === 1 && (ae.pipes = ae.pipes[0]), ee.emit("unpipe", this, ue), this);
  }, ne.prototype.on = function(ee, ae) {
    var ue = T.prototype.on.call(this, ee, ae);
    if (ee === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (ee === "readable") {
      var ye = this._readableState;
      !ye.endEmitted && !ye.readableListening && (ye.readableListening = ye.needReadable = !0, ye.emittedReadable = !1, ye.reading ? ye.length && N(this) : w.nextTick(O, this));
    }
    return ue;
  }, ne.prototype.addListener = ne.prototype.on;
  function O(ee) {
    V("readable nexttick read 0"), ee.read(0);
  }
  ne.prototype.resume = function() {
    var ee = this._readableState;
    return ee.flowing || (V("resume"), ee.flowing = !0, C(this, ee)), this;
  };
  function C(ee, ae) {
    ae.resumeScheduled || (ae.resumeScheduled = !0, w.nextTick(L, ee, ae));
  }
  function L(ee, ae) {
    ae.reading || (V("resume read 0"), ee.read(0)), ae.resumeScheduled = !1, ae.awaitDrain = 0, ee.emit("resume"), P(ee), ae.flowing && !ae.reading && ee.read(0);
  }
  ne.prototype.pause = function() {
    return V("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (V("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function P(ee) {
    var ae = ee._readableState;
    for (V("flow", ae.flowing); ae.flowing && ee.read() !== null; )
      ;
  }
  ne.prototype.wrap = function(ee) {
    var ae = this, ue = this._readableState, ye = !1;
    ee.on("end", function() {
      if (V("wrapped end"), ue.decoder && !ue.ended) {
        var Me = ue.decoder.end();
        Me && Me.length && ae.push(Me);
      }
      ae.push(null);
    }), ee.on("data", function(Me) {
      if (V("wrapped data"), ue.decoder && (Me = ue.decoder.write(Me)), !(ue.objectMode && Me == null) && !(!ue.objectMode && (!Me || !Me.length))) {
        var Qe = ae.push(Me);
        Qe || (ye = !0, ee.pause());
      }
    });
    for (var ve in ee)
      this[ve] === void 0 && typeof ee[ve] == "function" && (this[ve] = /* @__PURE__ */ function(Me) {
        return function() {
          return ee[Me].apply(ee, arguments);
        };
      }(ve));
    for (var he = 0; he < ce.length; he++)
      ee.on(ce[he], this.emit.bind(this, ce[he]));
    return this._read = function(Me) {
      V("wrapped _read", Me), ye && (ye = !1, ee.resume());
    }, this;
  }, Object.defineProperty(ne.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), ne._fromList = _;
  function _(ee, ae) {
    if (ae.length === 0) return null;
    var ue;
    return ae.objectMode ? ue = ae.buffer.shift() : !ee || ee >= ae.length ? (ae.decoder ? ue = ae.buffer.join("") : ae.buffer.length === 1 ? ue = ae.buffer.head.data : ue = ae.buffer.concat(ae.length), ae.buffer.clear()) : ue = I(ee, ae.buffer, ae.decoder), ue;
  }
  function I(ee, ae, ue) {
    var ye;
    return ee < ae.head.data.length ? (ye = ae.head.data.slice(0, ee), ae.head.data = ae.head.data.slice(ee)) : ee === ae.head.data.length ? ye = ae.shift() : ye = ue ? U(ee, ae) : Y(ee, ae), ye;
  }
  function U(ee, ae) {
    var ue = ae.head, ye = 1, ve = ue.data;
    for (ee -= ve.length; ue = ue.next; ) {
      var he = ue.data, Me = ee > he.length ? he.length : ee;
      if (Me === he.length ? ve += he : ve += he.slice(0, ee), ee -= Me, ee === 0) {
        Me === he.length ? (++ye, ue.next ? ae.head = ue.next : ae.head = ae.tail = null) : (ae.head = ue, ue.data = he.slice(Me));
        break;
      }
      ++ye;
    }
    return ae.length -= ye, ve;
  }
  function Y(ee, ae) {
    var ue = S.allocUnsafe(ee), ye = ae.head, ve = 1;
    for (ye.data.copy(ue), ee -= ye.data.length; ye = ye.next; ) {
      var he = ye.data, Me = ee > he.length ? he.length : ee;
      if (he.copy(ue, ue.length - ee, 0, Me), ee -= Me, ee === 0) {
        Me === he.length ? (++ve, ye.next ? ae.head = ye.next : ae.head = ae.tail = null) : (ae.head = ye, ye.data = he.slice(Me));
        break;
      }
      ++ve;
    }
    return ae.length -= ve, ue;
  }
  function te(ee) {
    var ae = ee._readableState;
    if (ae.length > 0) throw new Error('"endReadable()" called on non-empty stream');
    ae.endEmitted || (ae.ended = !0, w.nextTick(oe, ae, ee));
  }
  function oe(ee, ae) {
    !ee.endEmitted && ee.length === 0 && (ee.endEmitted = !0, ae.readable = !1, ae.emit("end"));
  }
  function re(ee, ae) {
    for (var ue = 0, ye = ee.length; ue < ye; ue++)
      if (ee[ue] === ae) return ue;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform = Transform$1, Duplex = require_stream_duplex(), util$1 = Object.create(util$2);
util$1.inherits = inherits_browserExports;
util$1.inherits(Transform$1, Duplex);
function afterTransform(w, M) {
  var x = this._transformState;
  x.transforming = !1;
  var $ = x.writecb;
  if (!$)
    return this.emit("error", new Error("write callback called multiple times"));
  x.writechunk = null, x.writecb = null, M != null && this.push(M), $(w);
  var T = this._readableState;
  T.reading = !1, (T.needReadable || T.length < T.highWaterMark) && this._read(T.highWaterMark);
}
function Transform$1(w) {
  if (!(this instanceof Transform$1)) return new Transform$1(w);
  Duplex.call(this, w), this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, w && (typeof w.transform == "function" && (this._transform = w.transform), typeof w.flush == "function" && (this._flush = w.flush)), this.on("prefinish", prefinish);
}
function prefinish() {
  var w = this;
  typeof this._flush == "function" ? this._flush(function(M, x) {
    done(w, M, x);
  }) : done(this, null, null);
}
Transform$1.prototype.push = function(w, M) {
  return this._transformState.needTransform = !1, Duplex.prototype.push.call(this, w, M);
};
Transform$1.prototype._transform = function(w, M, x) {
  throw new Error("_transform() is not implemented");
};
Transform$1.prototype._write = function(w, M, x) {
  var $ = this._transformState;
  if ($.writecb = x, $.writechunk = w, $.writeencoding = M, !$.transforming) {
    var T = this._readableState;
    ($.needTransform || T.needReadable || T.length < T.highWaterMark) && this._read(T.highWaterMark);
  }
};
Transform$1.prototype._read = function(w) {
  var M = this._transformState;
  M.writechunk !== null && M.writecb && !M.transforming ? (M.transforming = !0, this._transform(M.writechunk, M.writeencoding, M.afterTransform)) : M.needTransform = !0;
};
Transform$1.prototype._destroy = function(w, M) {
  var x = this;
  Duplex.prototype._destroy.call(this, w, function($) {
    M($), x.emit("close");
  });
};
function done(w, M, x) {
  if (M) return w.emit("error", M);
  if (x != null && w.push(x), w._writableState.length) throw new Error("Calling transform done when ws.length != 0");
  if (w._transformState.transforming) throw new Error("Calling transform done when still transforming");
  return w.push(null);
}
var _stream_passthrough = PassThrough, Transform = _stream_transform, util = Object.create(util$2);
util.inherits = inherits_browserExports;
util.inherits(PassThrough, Transform);
function PassThrough(w) {
  if (!(this instanceof PassThrough)) return new PassThrough(w);
  Transform.call(this, w);
}
PassThrough.prototype._transform = function(w, M, x) {
  x(null, w);
};
(function(w, M) {
  M = w.exports = require_stream_readable(), M.Stream = M, M.Readable = M, M.Writable = require_stream_writable(), M.Duplex = require_stream_duplex(), M.Transform = _stream_transform, M.PassThrough = _stream_passthrough;
})(readableBrowser, readableBrowser.exports);
var readableBrowserExports = readableBrowser.exports, sign = { exports: {} }, bn$4 = { exports: {} };
bn$4.exports;
(function(w) {
  (function(M, x) {
    function $(E, A) {
      if (!E) throw new Error(A || "Assertion failed");
    }
    function T(E, A) {
      E.super_ = A;
      var B = function() {
      };
      B.prototype = A.prototype, E.prototype = new B(), E.prototype.constructor = E;
    }
    function S(E, A, B) {
      if (S.isBN(E))
        return E;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, E !== null && ((A === "le" || A === "be") && (B = A, A = 10), this._init(E || 0, A || 10, B || "be"));
    }
    typeof M == "object" ? M.exports = S : x.BN = S, S.BN = S, S.wordSize = 26;
    var D;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? D = window.Buffer : D = dist.Buffer;
    } catch {
    }
    S.isBN = function(A) {
      return A instanceof S ? !0 : A !== null && typeof A == "object" && A.constructor.wordSize === S.wordSize && Array.isArray(A.words);
    }, S.max = function(A, B) {
      return A.cmp(B) > 0 ? A : B;
    }, S.min = function(A, B) {
      return A.cmp(B) < 0 ? A : B;
    }, S.prototype._init = function(A, B, O) {
      if (typeof A == "number")
        return this._initNumber(A, B, O);
      if (typeof A == "object")
        return this._initArray(A, B, O);
      B === "hex" && (B = 16), $(B === (B | 0) && B >= 2 && B <= 36), A = A.toString().replace(/\s+/g, "");
      var C = 0;
      A[0] === "-" && (C++, this.negative = 1), C < A.length && (B === 16 ? this._parseHex(A, C, O) : (this._parseBase(A, B, C), O === "le" && this._initArray(this.toArray(), B, O)));
    }, S.prototype._initNumber = function(A, B, O) {
      A < 0 && (this.negative = 1, A = -A), A < 67108864 ? (this.words = [A & 67108863], this.length = 1) : A < 4503599627370496 ? (this.words = [
        A & 67108863,
        A / 67108864 & 67108863
      ], this.length = 2) : ($(A < 9007199254740992), this.words = [
        A & 67108863,
        A / 67108864 & 67108863,
        1
      ], this.length = 3), O === "le" && this._initArray(this.toArray(), B, O);
    }, S.prototype._initArray = function(A, B, O) {
      if ($(typeof A.length == "number"), A.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(A.length / 3), this.words = new Array(this.length);
      for (var C = 0; C < this.length; C++)
        this.words[C] = 0;
      var L, P, _ = 0;
      if (O === "be")
        for (C = A.length - 1, L = 0; C >= 0; C -= 3)
          P = A[C] | A[C - 1] << 8 | A[C - 2] << 16, this.words[L] |= P << _ & 67108863, this.words[L + 1] = P >>> 26 - _ & 67108863, _ += 24, _ >= 26 && (_ -= 26, L++);
      else if (O === "le")
        for (C = 0, L = 0; C < A.length; C += 3)
          P = A[C] | A[C + 1] << 8 | A[C + 2] << 16, this.words[L] |= P << _ & 67108863, this.words[L + 1] = P >>> 26 - _ & 67108863, _ += 24, _ >= 26 && (_ -= 26, L++);
      return this._strip();
    };
    function F(E, A) {
      var B = E.charCodeAt(A);
      if (B >= 48 && B <= 57)
        return B - 48;
      if (B >= 65 && B <= 70)
        return B - 55;
      if (B >= 97 && B <= 102)
        return B - 87;
      $(!1, "Invalid character in " + E);
    }
    function z(E, A, B) {
      var O = F(E, B);
      return B - 1 >= A && (O |= F(E, B - 1) << 4), O;
    }
    S.prototype._parseHex = function(A, B, O) {
      this.length = Math.ceil((A.length - B) / 6), this.words = new Array(this.length);
      for (var C = 0; C < this.length; C++)
        this.words[C] = 0;
      var L = 0, P = 0, _;
      if (O === "be")
        for (C = A.length - 1; C >= B; C -= 2)
          _ = z(A, B, C) << L, this.words[P] |= _ & 67108863, L >= 18 ? (L -= 18, P += 1, this.words[P] |= _ >>> 26) : L += 8;
      else {
        var I = A.length - B;
        for (C = I % 2 === 0 ? B + 1 : B; C < A.length; C += 2)
          _ = z(A, B, C) << L, this.words[P] |= _ & 67108863, L >= 18 ? (L -= 18, P += 1, this.words[P] |= _ >>> 26) : L += 8;
      }
      this._strip();
    };
    function Z(E, A, B, O) {
      for (var C = 0, L = 0, P = Math.min(E.length, B), _ = A; _ < P; _++) {
        var I = E.charCodeAt(_) - 48;
        C *= O, I >= 49 ? L = I - 49 + 10 : I >= 17 ? L = I - 17 + 10 : L = I, $(I >= 0 && L < O, "Invalid character"), C += L;
      }
      return C;
    }
    S.prototype._parseBase = function(A, B, O) {
      this.words = [0], this.length = 1;
      for (var C = 0, L = 1; L <= 67108863; L *= B)
        C++;
      C--, L = L / B | 0;
      for (var P = A.length - O, _ = P % C, I = Math.min(P, P - _) + O, U = 0, Y = O; Y < I; Y += C)
        U = Z(A, Y, Y + C, B), this.imuln(L), this.words[0] + U < 67108864 ? this.words[0] += U : this._iaddn(U);
      if (_ !== 0) {
        var te = 1;
        for (U = Z(A, Y, A.length, B), Y = 0; Y < _; Y++)
          te *= B;
        this.imuln(te), this.words[0] + U < 67108864 ? this.words[0] += U : this._iaddn(U);
      }
      this._strip();
    }, S.prototype.copy = function(A) {
      A.words = new Array(this.length);
      for (var B = 0; B < this.length; B++)
        A.words[B] = this.words[B];
      A.length = this.length, A.negative = this.negative, A.red = this.red;
    };
    function H(E, A) {
      E.words = A.words, E.length = A.length, E.negative = A.negative, E.red = A.red;
    }
    if (S.prototype._move = function(A) {
      H(A, this);
    }, S.prototype.clone = function() {
      var A = new S(null);
      return this.copy(A), A;
    }, S.prototype._expand = function(A) {
      for (; this.length < A; )
        this.words[this.length++] = 0;
      return this;
    }, S.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, S.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        S.prototype[Symbol.for("nodejs.util.inspect.custom")] = V;
      } catch {
        S.prototype.inspect = V;
      }
    else
      S.prototype.inspect = V;
    function V() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var X = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], Q = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], fe = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    S.prototype.toString = function(A, B) {
      A = A || 10, B = B | 0 || 1;
      var O;
      if (A === 16 || A === "hex") {
        O = "";
        for (var C = 0, L = 0, P = 0; P < this.length; P++) {
          var _ = this.words[P], I = ((_ << C | L) & 16777215).toString(16);
          L = _ >>> 24 - C & 16777215, C += 2, C >= 26 && (C -= 26, P--), L !== 0 || P !== this.length - 1 ? O = X[6 - I.length] + I + O : O = I + O;
        }
        for (L !== 0 && (O = L.toString(16) + O); O.length % B !== 0; )
          O = "0" + O;
        return this.negative !== 0 && (O = "-" + O), O;
      }
      if (A === (A | 0) && A >= 2 && A <= 36) {
        var U = Q[A], Y = fe[A];
        O = "";
        var te = this.clone();
        for (te.negative = 0; !te.isZero(); ) {
          var oe = te.modrn(Y).toString(A);
          te = te.idivn(Y), te.isZero() ? O = oe + O : O = X[U - oe.length] + oe + O;
        }
        for (this.isZero() && (O = "0" + O); O.length % B !== 0; )
          O = "0" + O;
        return this.negative !== 0 && (O = "-" + O), O;
      }
      $(!1, "Base should be between 2 and 36");
    }, S.prototype.toNumber = function() {
      var A = this.words[0];
      return this.length === 2 ? A += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? A += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && $(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -A : A;
    }, S.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, D && (S.prototype.toBuffer = function(A, B) {
      return this.toArrayLike(D, A, B);
    }), S.prototype.toArray = function(A, B) {
      return this.toArrayLike(Array, A, B);
    };
    var ce = function(A, B) {
      return A.allocUnsafe ? A.allocUnsafe(B) : new A(B);
    };
    S.prototype.toArrayLike = function(A, B, O) {
      this._strip();
      var C = this.byteLength(), L = O || Math.max(1, C);
      $(C <= L, "byte array longer than desired length"), $(L > 0, "Requested array length <= 0");
      var P = ce(A, L), _ = B === "le" ? "LE" : "BE";
      return this["_toArrayLike" + _](P, C), P;
    }, S.prototype._toArrayLikeLE = function(A, B) {
      for (var O = 0, C = 0, L = 0, P = 0; L < this.length; L++) {
        var _ = this.words[L] << P | C;
        A[O++] = _ & 255, O < A.length && (A[O++] = _ >> 8 & 255), O < A.length && (A[O++] = _ >> 16 & 255), P === 6 ? (O < A.length && (A[O++] = _ >> 24 & 255), C = 0, P = 0) : (C = _ >>> 24, P += 2);
      }
      if (O < A.length)
        for (A[O++] = C; O < A.length; )
          A[O++] = 0;
    }, S.prototype._toArrayLikeBE = function(A, B) {
      for (var O = A.length - 1, C = 0, L = 0, P = 0; L < this.length; L++) {
        var _ = this.words[L] << P | C;
        A[O--] = _ & 255, O >= 0 && (A[O--] = _ >> 8 & 255), O >= 0 && (A[O--] = _ >> 16 & 255), P === 6 ? (O >= 0 && (A[O--] = _ >> 24 & 255), C = 0, P = 0) : (C = _ >>> 24, P += 2);
      }
      if (O >= 0)
        for (A[O--] = C; O >= 0; )
          A[O--] = 0;
    }, Math.clz32 ? S.prototype._countBits = function(A) {
      return 32 - Math.clz32(A);
    } : S.prototype._countBits = function(A) {
      var B = A, O = 0;
      return B >= 4096 && (O += 13, B >>>= 13), B >= 64 && (O += 7, B >>>= 7), B >= 8 && (O += 4, B >>>= 4), B >= 2 && (O += 2, B >>>= 2), O + B;
    }, S.prototype._zeroBits = function(A) {
      if (A === 0) return 26;
      var B = A, O = 0;
      return B & 8191 || (O += 13, B >>>= 13), B & 127 || (O += 7, B >>>= 7), B & 15 || (O += 4, B >>>= 4), B & 3 || (O += 2, B >>>= 2), B & 1 || O++, O;
    }, S.prototype.bitLength = function() {
      var A = this.words[this.length - 1], B = this._countBits(A);
      return (this.length - 1) * 26 + B;
    };
    function me(E) {
      for (var A = new Array(E.bitLength()), B = 0; B < A.length; B++) {
        var O = B / 26 | 0, C = B % 26;
        A[B] = E.words[O] >>> C & 1;
      }
      return A;
    }
    S.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var A = 0, B = 0; B < this.length; B++) {
        var O = this._zeroBits(this.words[B]);
        if (A += O, O !== 26) break;
      }
      return A;
    }, S.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, S.prototype.toTwos = function(A) {
      return this.negative !== 0 ? this.abs().inotn(A).iaddn(1) : this.clone();
    }, S.prototype.fromTwos = function(A) {
      return this.testn(A - 1) ? this.notn(A).iaddn(1).ineg() : this.clone();
    }, S.prototype.isNeg = function() {
      return this.negative !== 0;
    }, S.prototype.neg = function() {
      return this.clone().ineg();
    }, S.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, S.prototype.iuor = function(A) {
      for (; this.length < A.length; )
        this.words[this.length++] = 0;
      for (var B = 0; B < A.length; B++)
        this.words[B] = this.words[B] | A.words[B];
      return this._strip();
    }, S.prototype.ior = function(A) {
      return $((this.negative | A.negative) === 0), this.iuor(A);
    }, S.prototype.or = function(A) {
      return this.length > A.length ? this.clone().ior(A) : A.clone().ior(this);
    }, S.prototype.uor = function(A) {
      return this.length > A.length ? this.clone().iuor(A) : A.clone().iuor(this);
    }, S.prototype.iuand = function(A) {
      var B;
      this.length > A.length ? B = A : B = this;
      for (var O = 0; O < B.length; O++)
        this.words[O] = this.words[O] & A.words[O];
      return this.length = B.length, this._strip();
    }, S.prototype.iand = function(A) {
      return $((this.negative | A.negative) === 0), this.iuand(A);
    }, S.prototype.and = function(A) {
      return this.length > A.length ? this.clone().iand(A) : A.clone().iand(this);
    }, S.prototype.uand = function(A) {
      return this.length > A.length ? this.clone().iuand(A) : A.clone().iuand(this);
    }, S.prototype.iuxor = function(A) {
      var B, O;
      this.length > A.length ? (B = this, O = A) : (B = A, O = this);
      for (var C = 0; C < O.length; C++)
        this.words[C] = B.words[C] ^ O.words[C];
      if (this !== B)
        for (; C < B.length; C++)
          this.words[C] = B.words[C];
      return this.length = B.length, this._strip();
    }, S.prototype.ixor = function(A) {
      return $((this.negative | A.negative) === 0), this.iuxor(A);
    }, S.prototype.xor = function(A) {
      return this.length > A.length ? this.clone().ixor(A) : A.clone().ixor(this);
    }, S.prototype.uxor = function(A) {
      return this.length > A.length ? this.clone().iuxor(A) : A.clone().iuxor(this);
    }, S.prototype.inotn = function(A) {
      $(typeof A == "number" && A >= 0);
      var B = Math.ceil(A / 26) | 0, O = A % 26;
      this._expand(B), O > 0 && B--;
      for (var C = 0; C < B; C++)
        this.words[C] = ~this.words[C] & 67108863;
      return O > 0 && (this.words[C] = ~this.words[C] & 67108863 >> 26 - O), this._strip();
    }, S.prototype.notn = function(A) {
      return this.clone().inotn(A);
    }, S.prototype.setn = function(A, B) {
      $(typeof A == "number" && A >= 0);
      var O = A / 26 | 0, C = A % 26;
      return this._expand(O + 1), B ? this.words[O] = this.words[O] | 1 << C : this.words[O] = this.words[O] & ~(1 << C), this._strip();
    }, S.prototype.iadd = function(A) {
      var B;
      if (this.negative !== 0 && A.negative === 0)
        return this.negative = 0, B = this.isub(A), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && A.negative !== 0)
        return A.negative = 0, B = this.isub(A), A.negative = 1, B._normSign();
      var O, C;
      this.length > A.length ? (O = this, C = A) : (O = A, C = this);
      for (var L = 0, P = 0; P < C.length; P++)
        B = (O.words[P] | 0) + (C.words[P] | 0) + L, this.words[P] = B & 67108863, L = B >>> 26;
      for (; L !== 0 && P < O.length; P++)
        B = (O.words[P] | 0) + L, this.words[P] = B & 67108863, L = B >>> 26;
      if (this.length = O.length, L !== 0)
        this.words[this.length] = L, this.length++;
      else if (O !== this)
        for (; P < O.length; P++)
          this.words[P] = O.words[P];
      return this;
    }, S.prototype.add = function(A) {
      var B;
      return A.negative !== 0 && this.negative === 0 ? (A.negative = 0, B = this.sub(A), A.negative ^= 1, B) : A.negative === 0 && this.negative !== 0 ? (this.negative = 0, B = A.sub(this), this.negative = 1, B) : this.length > A.length ? this.clone().iadd(A) : A.clone().iadd(this);
    }, S.prototype.isub = function(A) {
      if (A.negative !== 0) {
        A.negative = 0;
        var B = this.iadd(A);
        return A.negative = 1, B._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(A), this.negative = 1, this._normSign();
      var O = this.cmp(A);
      if (O === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var C, L;
      O > 0 ? (C = this, L = A) : (C = A, L = this);
      for (var P = 0, _ = 0; _ < L.length; _++)
        B = (C.words[_] | 0) - (L.words[_] | 0) + P, P = B >> 26, this.words[_] = B & 67108863;
      for (; P !== 0 && _ < C.length; _++)
        B = (C.words[_] | 0) + P, P = B >> 26, this.words[_] = B & 67108863;
      if (P === 0 && _ < C.length && C !== this)
        for (; _ < C.length; _++)
          this.words[_] = C.words[_];
      return this.length = Math.max(this.length, _), C !== this && (this.negative = 1), this._strip();
    }, S.prototype.sub = function(A) {
      return this.clone().isub(A);
    };
    function de(E, A, B) {
      B.negative = A.negative ^ E.negative;
      var O = E.length + A.length | 0;
      B.length = O, O = O - 1 | 0;
      var C = E.words[0] | 0, L = A.words[0] | 0, P = C * L, _ = P & 67108863, I = P / 67108864 | 0;
      B.words[0] = _;
      for (var U = 1; U < O; U++) {
        for (var Y = I >>> 26, te = I & 67108863, oe = Math.min(U, A.length - 1), re = Math.max(0, U - E.length + 1); re <= oe; re++) {
          var ee = U - re | 0;
          C = E.words[ee] | 0, L = A.words[re] | 0, P = C * L + te, Y += P / 67108864 | 0, te = P & 67108863;
        }
        B.words[U] = te | 0, I = Y | 0;
      }
      return I !== 0 ? B.words[U] = I | 0 : B.length--, B._strip();
    }
    var ne = function(A, B, O) {
      var C = A.words, L = B.words, P = O.words, _ = 0, I, U, Y, te = C[0] | 0, oe = te & 8191, re = te >>> 13, ee = C[1] | 0, ae = ee & 8191, ue = ee >>> 13, ye = C[2] | 0, ve = ye & 8191, he = ye >>> 13, Me = C[3] | 0, Qe = Me & 8191, Ie = Me >>> 13, De = C[4] | 0, at = De & 8191, ke = De >>> 13, Se = C[5] | 0, lt = Se & 8191, qe = Se >>> 13, He = C[6] | 0, ot = He & 8191, be = He >>> 13, _e = C[7] | 0, it = _e & 8191, Ae = _e >>> 13, Be = C[8] | 0, nt = Be & 8191, Te = Be >>> 13, Ue = C[9] | 0, st = Ue & 8191, Le = Ue >>> 13, Ge = L[0] | 0, pt = Ge & 8191, je = Ge >>> 13, Je = L[1] | 0, dt = Je & 8191, ze = Je >>> 13, et = L[2] | 0, yt = et & 8191, Ke = et >>> 13, Ye = L[3] | 0, gt = Ye & 8191, We = Ye >>> 13, Xe = L[4] | 0, bt = Xe & 8191, se = Xe >>> 13, J = L[5] | 0, ie = J & 8191, le = J >>> 13, we = L[6] | 0, Ce = we & 8191, Ee = we >>> 13, Fe = L[7] | 0, ut = Fe & 8191, Ne = Fe >>> 13, Ve = L[8] | 0, ht = Ve & 8191, Ze = Ve >>> 13, tt = L[9] | 0, vt = tt & 8191, mt = tt >>> 13;
      O.negative = A.negative ^ B.negative, O.length = 19, I = Math.imul(oe, pt), U = Math.imul(oe, je), U = U + Math.imul(re, pt) | 0, Y = Math.imul(re, je);
      var wt = (_ + I | 0) + ((U & 8191) << 13) | 0;
      _ = (Y + (U >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, I = Math.imul(ae, pt), U = Math.imul(ae, je), U = U + Math.imul(ue, pt) | 0, Y = Math.imul(ue, je), I = I + Math.imul(oe, dt) | 0, U = U + Math.imul(oe, ze) | 0, U = U + Math.imul(re, dt) | 0, Y = Y + Math.imul(re, ze) | 0;
      var Mt = (_ + I | 0) + ((U & 8191) << 13) | 0;
      _ = (Y + (U >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, I = Math.imul(ve, pt), U = Math.imul(ve, je), U = U + Math.imul(he, pt) | 0, Y = Math.imul(he, je), I = I + Math.imul(ae, dt) | 0, U = U + Math.imul(ae, ze) | 0, U = U + Math.imul(ue, dt) | 0, Y = Y + Math.imul(ue, ze) | 0, I = I + Math.imul(oe, yt) | 0, U = U + Math.imul(oe, Ke) | 0, U = U + Math.imul(re, yt) | 0, Y = Y + Math.imul(re, Ke) | 0;
      var _t = (_ + I | 0) + ((U & 8191) << 13) | 0;
      _ = (Y + (U >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, I = Math.imul(Qe, pt), U = Math.imul(Qe, je), U = U + Math.imul(Ie, pt) | 0, Y = Math.imul(Ie, je), I = I + Math.imul(ve, dt) | 0, U = U + Math.imul(ve, ze) | 0, U = U + Math.imul(he, dt) | 0, Y = Y + Math.imul(he, ze) | 0, I = I + Math.imul(ae, yt) | 0, U = U + Math.imul(ae, Ke) | 0, U = U + Math.imul(ue, yt) | 0, Y = Y + Math.imul(ue, Ke) | 0, I = I + Math.imul(oe, gt) | 0, U = U + Math.imul(oe, We) | 0, U = U + Math.imul(re, gt) | 0, Y = Y + Math.imul(re, We) | 0;
      var xt = (_ + I | 0) + ((U & 8191) << 13) | 0;
      _ = (Y + (U >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, I = Math.imul(at, pt), U = Math.imul(at, je), U = U + Math.imul(ke, pt) | 0, Y = Math.imul(ke, je), I = I + Math.imul(Qe, dt) | 0, U = U + Math.imul(Qe, ze) | 0, U = U + Math.imul(Ie, dt) | 0, Y = Y + Math.imul(Ie, ze) | 0, I = I + Math.imul(ve, yt) | 0, U = U + Math.imul(ve, Ke) | 0, U = U + Math.imul(he, yt) | 0, Y = Y + Math.imul(he, Ke) | 0, I = I + Math.imul(ae, gt) | 0, U = U + Math.imul(ae, We) | 0, U = U + Math.imul(ue, gt) | 0, Y = Y + Math.imul(ue, We) | 0, I = I + Math.imul(oe, bt) | 0, U = U + Math.imul(oe, se) | 0, U = U + Math.imul(re, bt) | 0, Y = Y + Math.imul(re, se) | 0;
      var Et = (_ + I | 0) + ((U & 8191) << 13) | 0;
      _ = (Y + (U >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, I = Math.imul(lt, pt), U = Math.imul(lt, je), U = U + Math.imul(qe, pt) | 0, Y = Math.imul(qe, je), I = I + Math.imul(at, dt) | 0, U = U + Math.imul(at, ze) | 0, U = U + Math.imul(ke, dt) | 0, Y = Y + Math.imul(ke, ze) | 0, I = I + Math.imul(Qe, yt) | 0, U = U + Math.imul(Qe, Ke) | 0, U = U + Math.imul(Ie, yt) | 0, Y = Y + Math.imul(Ie, Ke) | 0, I = I + Math.imul(ve, gt) | 0, U = U + Math.imul(ve, We) | 0, U = U + Math.imul(he, gt) | 0, Y = Y + Math.imul(he, We) | 0, I = I + Math.imul(ae, bt) | 0, U = U + Math.imul(ae, se) | 0, U = U + Math.imul(ue, bt) | 0, Y = Y + Math.imul(ue, se) | 0, I = I + Math.imul(oe, ie) | 0, U = U + Math.imul(oe, le) | 0, U = U + Math.imul(re, ie) | 0, Y = Y + Math.imul(re, le) | 0;
      var St = (_ + I | 0) + ((U & 8191) << 13) | 0;
      _ = (Y + (U >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, I = Math.imul(ot, pt), U = Math.imul(ot, je), U = U + Math.imul(be, pt) | 0, Y = Math.imul(be, je), I = I + Math.imul(lt, dt) | 0, U = U + Math.imul(lt, ze) | 0, U = U + Math.imul(qe, dt) | 0, Y = Y + Math.imul(qe, ze) | 0, I = I + Math.imul(at, yt) | 0, U = U + Math.imul(at, Ke) | 0, U = U + Math.imul(ke, yt) | 0, Y = Y + Math.imul(ke, Ke) | 0, I = I + Math.imul(Qe, gt) | 0, U = U + Math.imul(Qe, We) | 0, U = U + Math.imul(Ie, gt) | 0, Y = Y + Math.imul(Ie, We) | 0, I = I + Math.imul(ve, bt) | 0, U = U + Math.imul(ve, se) | 0, U = U + Math.imul(he, bt) | 0, Y = Y + Math.imul(he, se) | 0, I = I + Math.imul(ae, ie) | 0, U = U + Math.imul(ae, le) | 0, U = U + Math.imul(ue, ie) | 0, Y = Y + Math.imul(ue, le) | 0, I = I + Math.imul(oe, Ce) | 0, U = U + Math.imul(oe, Ee) | 0, U = U + Math.imul(re, Ce) | 0, Y = Y + Math.imul(re, Ee) | 0;
      var $t = (_ + I | 0) + ((U & 8191) << 13) | 0;
      _ = (Y + (U >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, I = Math.imul(it, pt), U = Math.imul(it, je), U = U + Math.imul(Ae, pt) | 0, Y = Math.imul(Ae, je), I = I + Math.imul(ot, dt) | 0, U = U + Math.imul(ot, ze) | 0, U = U + Math.imul(be, dt) | 0, Y = Y + Math.imul(be, ze) | 0, I = I + Math.imul(lt, yt) | 0, U = U + Math.imul(lt, Ke) | 0, U = U + Math.imul(qe, yt) | 0, Y = Y + Math.imul(qe, Ke) | 0, I = I + Math.imul(at, gt) | 0, U = U + Math.imul(at, We) | 0, U = U + Math.imul(ke, gt) | 0, Y = Y + Math.imul(ke, We) | 0, I = I + Math.imul(Qe, bt) | 0, U = U + Math.imul(Qe, se) | 0, U = U + Math.imul(Ie, bt) | 0, Y = Y + Math.imul(Ie, se) | 0, I = I + Math.imul(ve, ie) | 0, U = U + Math.imul(ve, le) | 0, U = U + Math.imul(he, ie) | 0, Y = Y + Math.imul(he, le) | 0, I = I + Math.imul(ae, Ce) | 0, U = U + Math.imul(ae, Ee) | 0, U = U + Math.imul(ue, Ce) | 0, Y = Y + Math.imul(ue, Ee) | 0, I = I + Math.imul(oe, ut) | 0, U = U + Math.imul(oe, Ne) | 0, U = U + Math.imul(re, ut) | 0, Y = Y + Math.imul(re, Ne) | 0;
      var At = (_ + I | 0) + ((U & 8191) << 13) | 0;
      _ = (Y + (U >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, I = Math.imul(nt, pt), U = Math.imul(nt, je), U = U + Math.imul(Te, pt) | 0, Y = Math.imul(Te, je), I = I + Math.imul(it, dt) | 0, U = U + Math.imul(it, ze) | 0, U = U + Math.imul(Ae, dt) | 0, Y = Y + Math.imul(Ae, ze) | 0, I = I + Math.imul(ot, yt) | 0, U = U + Math.imul(ot, Ke) | 0, U = U + Math.imul(be, yt) | 0, Y = Y + Math.imul(be, Ke) | 0, I = I + Math.imul(lt, gt) | 0, U = U + Math.imul(lt, We) | 0, U = U + Math.imul(qe, gt) | 0, Y = Y + Math.imul(qe, We) | 0, I = I + Math.imul(at, bt) | 0, U = U + Math.imul(at, se) | 0, U = U + Math.imul(ke, bt) | 0, Y = Y + Math.imul(ke, se) | 0, I = I + Math.imul(Qe, ie) | 0, U = U + Math.imul(Qe, le) | 0, U = U + Math.imul(Ie, ie) | 0, Y = Y + Math.imul(Ie, le) | 0, I = I + Math.imul(ve, Ce) | 0, U = U + Math.imul(ve, Ee) | 0, U = U + Math.imul(he, Ce) | 0, Y = Y + Math.imul(he, Ee) | 0, I = I + Math.imul(ae, ut) | 0, U = U + Math.imul(ae, Ne) | 0, U = U + Math.imul(ue, ut) | 0, Y = Y + Math.imul(ue, Ne) | 0, I = I + Math.imul(oe, ht) | 0, U = U + Math.imul(oe, Ze) | 0, U = U + Math.imul(re, ht) | 0, Y = Y + Math.imul(re, Ze) | 0;
      var Rt = (_ + I | 0) + ((U & 8191) << 13) | 0;
      _ = (Y + (U >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, I = Math.imul(st, pt), U = Math.imul(st, je), U = U + Math.imul(Le, pt) | 0, Y = Math.imul(Le, je), I = I + Math.imul(nt, dt) | 0, U = U + Math.imul(nt, ze) | 0, U = U + Math.imul(Te, dt) | 0, Y = Y + Math.imul(Te, ze) | 0, I = I + Math.imul(it, yt) | 0, U = U + Math.imul(it, Ke) | 0, U = U + Math.imul(Ae, yt) | 0, Y = Y + Math.imul(Ae, Ke) | 0, I = I + Math.imul(ot, gt) | 0, U = U + Math.imul(ot, We) | 0, U = U + Math.imul(be, gt) | 0, Y = Y + Math.imul(be, We) | 0, I = I + Math.imul(lt, bt) | 0, U = U + Math.imul(lt, se) | 0, U = U + Math.imul(qe, bt) | 0, Y = Y + Math.imul(qe, se) | 0, I = I + Math.imul(at, ie) | 0, U = U + Math.imul(at, le) | 0, U = U + Math.imul(ke, ie) | 0, Y = Y + Math.imul(ke, le) | 0, I = I + Math.imul(Qe, Ce) | 0, U = U + Math.imul(Qe, Ee) | 0, U = U + Math.imul(Ie, Ce) | 0, Y = Y + Math.imul(Ie, Ee) | 0, I = I + Math.imul(ve, ut) | 0, U = U + Math.imul(ve, Ne) | 0, U = U + Math.imul(he, ut) | 0, Y = Y + Math.imul(he, Ne) | 0, I = I + Math.imul(ae, ht) | 0, U = U + Math.imul(ae, Ze) | 0, U = U + Math.imul(ue, ht) | 0, Y = Y + Math.imul(ue, Ze) | 0, I = I + Math.imul(oe, vt) | 0, U = U + Math.imul(oe, mt) | 0, U = U + Math.imul(re, vt) | 0, Y = Y + Math.imul(re, mt) | 0;
      var Bt = (_ + I | 0) + ((U & 8191) << 13) | 0;
      _ = (Y + (U >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, I = Math.imul(st, dt), U = Math.imul(st, ze), U = U + Math.imul(Le, dt) | 0, Y = Math.imul(Le, ze), I = I + Math.imul(nt, yt) | 0, U = U + Math.imul(nt, Ke) | 0, U = U + Math.imul(Te, yt) | 0, Y = Y + Math.imul(Te, Ke) | 0, I = I + Math.imul(it, gt) | 0, U = U + Math.imul(it, We) | 0, U = U + Math.imul(Ae, gt) | 0, Y = Y + Math.imul(Ae, We) | 0, I = I + Math.imul(ot, bt) | 0, U = U + Math.imul(ot, se) | 0, U = U + Math.imul(be, bt) | 0, Y = Y + Math.imul(be, se) | 0, I = I + Math.imul(lt, ie) | 0, U = U + Math.imul(lt, le) | 0, U = U + Math.imul(qe, ie) | 0, Y = Y + Math.imul(qe, le) | 0, I = I + Math.imul(at, Ce) | 0, U = U + Math.imul(at, Ee) | 0, U = U + Math.imul(ke, Ce) | 0, Y = Y + Math.imul(ke, Ee) | 0, I = I + Math.imul(Qe, ut) | 0, U = U + Math.imul(Qe, Ne) | 0, U = U + Math.imul(Ie, ut) | 0, Y = Y + Math.imul(Ie, Ne) | 0, I = I + Math.imul(ve, ht) | 0, U = U + Math.imul(ve, Ze) | 0, U = U + Math.imul(he, ht) | 0, Y = Y + Math.imul(he, Ze) | 0, I = I + Math.imul(ae, vt) | 0, U = U + Math.imul(ae, mt) | 0, U = U + Math.imul(ue, vt) | 0, Y = Y + Math.imul(ue, mt) | 0;
      var Tt = (_ + I | 0) + ((U & 8191) << 13) | 0;
      _ = (Y + (U >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, I = Math.imul(st, yt), U = Math.imul(st, Ke), U = U + Math.imul(Le, yt) | 0, Y = Math.imul(Le, Ke), I = I + Math.imul(nt, gt) | 0, U = U + Math.imul(nt, We) | 0, U = U + Math.imul(Te, gt) | 0, Y = Y + Math.imul(Te, We) | 0, I = I + Math.imul(it, bt) | 0, U = U + Math.imul(it, se) | 0, U = U + Math.imul(Ae, bt) | 0, Y = Y + Math.imul(Ae, se) | 0, I = I + Math.imul(ot, ie) | 0, U = U + Math.imul(ot, le) | 0, U = U + Math.imul(be, ie) | 0, Y = Y + Math.imul(be, le) | 0, I = I + Math.imul(lt, Ce) | 0, U = U + Math.imul(lt, Ee) | 0, U = U + Math.imul(qe, Ce) | 0, Y = Y + Math.imul(qe, Ee) | 0, I = I + Math.imul(at, ut) | 0, U = U + Math.imul(at, Ne) | 0, U = U + Math.imul(ke, ut) | 0, Y = Y + Math.imul(ke, Ne) | 0, I = I + Math.imul(Qe, ht) | 0, U = U + Math.imul(Qe, Ze) | 0, U = U + Math.imul(Ie, ht) | 0, Y = Y + Math.imul(Ie, Ze) | 0, I = I + Math.imul(ve, vt) | 0, U = U + Math.imul(ve, mt) | 0, U = U + Math.imul(he, vt) | 0, Y = Y + Math.imul(he, mt) | 0;
      var Pt = (_ + I | 0) + ((U & 8191) << 13) | 0;
      _ = (Y + (U >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, I = Math.imul(st, gt), U = Math.imul(st, We), U = U + Math.imul(Le, gt) | 0, Y = Math.imul(Le, We), I = I + Math.imul(nt, bt) | 0, U = U + Math.imul(nt, se) | 0, U = U + Math.imul(Te, bt) | 0, Y = Y + Math.imul(Te, se) | 0, I = I + Math.imul(it, ie) | 0, U = U + Math.imul(it, le) | 0, U = U + Math.imul(Ae, ie) | 0, Y = Y + Math.imul(Ae, le) | 0, I = I + Math.imul(ot, Ce) | 0, U = U + Math.imul(ot, Ee) | 0, U = U + Math.imul(be, Ce) | 0, Y = Y + Math.imul(be, Ee) | 0, I = I + Math.imul(lt, ut) | 0, U = U + Math.imul(lt, Ne) | 0, U = U + Math.imul(qe, ut) | 0, Y = Y + Math.imul(qe, Ne) | 0, I = I + Math.imul(at, ht) | 0, U = U + Math.imul(at, Ze) | 0, U = U + Math.imul(ke, ht) | 0, Y = Y + Math.imul(ke, Ze) | 0, I = I + Math.imul(Qe, vt) | 0, U = U + Math.imul(Qe, mt) | 0, U = U + Math.imul(Ie, vt) | 0, Y = Y + Math.imul(Ie, mt) | 0;
      var It = (_ + I | 0) + ((U & 8191) << 13) | 0;
      _ = (Y + (U >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, I = Math.imul(st, bt), U = Math.imul(st, se), U = U + Math.imul(Le, bt) | 0, Y = Math.imul(Le, se), I = I + Math.imul(nt, ie) | 0, U = U + Math.imul(nt, le) | 0, U = U + Math.imul(Te, ie) | 0, Y = Y + Math.imul(Te, le) | 0, I = I + Math.imul(it, Ce) | 0, U = U + Math.imul(it, Ee) | 0, U = U + Math.imul(Ae, Ce) | 0, Y = Y + Math.imul(Ae, Ee) | 0, I = I + Math.imul(ot, ut) | 0, U = U + Math.imul(ot, Ne) | 0, U = U + Math.imul(be, ut) | 0, Y = Y + Math.imul(be, Ne) | 0, I = I + Math.imul(lt, ht) | 0, U = U + Math.imul(lt, Ze) | 0, U = U + Math.imul(qe, ht) | 0, Y = Y + Math.imul(qe, Ze) | 0, I = I + Math.imul(at, vt) | 0, U = U + Math.imul(at, mt) | 0, U = U + Math.imul(ke, vt) | 0, Y = Y + Math.imul(ke, mt) | 0;
      var Ot = (_ + I | 0) + ((U & 8191) << 13) | 0;
      _ = (Y + (U >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, I = Math.imul(st, ie), U = Math.imul(st, le), U = U + Math.imul(Le, ie) | 0, Y = Math.imul(Le, le), I = I + Math.imul(nt, Ce) | 0, U = U + Math.imul(nt, Ee) | 0, U = U + Math.imul(Te, Ce) | 0, Y = Y + Math.imul(Te, Ee) | 0, I = I + Math.imul(it, ut) | 0, U = U + Math.imul(it, Ne) | 0, U = U + Math.imul(Ae, ut) | 0, Y = Y + Math.imul(Ae, Ne) | 0, I = I + Math.imul(ot, ht) | 0, U = U + Math.imul(ot, Ze) | 0, U = U + Math.imul(be, ht) | 0, Y = Y + Math.imul(be, Ze) | 0, I = I + Math.imul(lt, vt) | 0, U = U + Math.imul(lt, mt) | 0, U = U + Math.imul(qe, vt) | 0, Y = Y + Math.imul(qe, mt) | 0;
      var Ct = (_ + I | 0) + ((U & 8191) << 13) | 0;
      _ = (Y + (U >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, I = Math.imul(st, Ce), U = Math.imul(st, Ee), U = U + Math.imul(Le, Ce) | 0, Y = Math.imul(Le, Ee), I = I + Math.imul(nt, ut) | 0, U = U + Math.imul(nt, Ne) | 0, U = U + Math.imul(Te, ut) | 0, Y = Y + Math.imul(Te, Ne) | 0, I = I + Math.imul(it, ht) | 0, U = U + Math.imul(it, Ze) | 0, U = U + Math.imul(Ae, ht) | 0, Y = Y + Math.imul(Ae, Ze) | 0, I = I + Math.imul(ot, vt) | 0, U = U + Math.imul(ot, mt) | 0, U = U + Math.imul(be, vt) | 0, Y = Y + Math.imul(be, mt) | 0;
      var Dt = (_ + I | 0) + ((U & 8191) << 13) | 0;
      _ = (Y + (U >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, I = Math.imul(st, ut), U = Math.imul(st, Ne), U = U + Math.imul(Le, ut) | 0, Y = Math.imul(Le, Ne), I = I + Math.imul(nt, ht) | 0, U = U + Math.imul(nt, Ze) | 0, U = U + Math.imul(Te, ht) | 0, Y = Y + Math.imul(Te, Ze) | 0, I = I + Math.imul(it, vt) | 0, U = U + Math.imul(it, mt) | 0, U = U + Math.imul(Ae, vt) | 0, Y = Y + Math.imul(Ae, mt) | 0;
      var kt = (_ + I | 0) + ((U & 8191) << 13) | 0;
      _ = (Y + (U >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, I = Math.imul(st, ht), U = Math.imul(st, Ze), U = U + Math.imul(Le, ht) | 0, Y = Math.imul(Le, Ze), I = I + Math.imul(nt, vt) | 0, U = U + Math.imul(nt, mt) | 0, U = U + Math.imul(Te, vt) | 0, Y = Y + Math.imul(Te, mt) | 0;
      var Nt = (_ + I | 0) + ((U & 8191) << 13) | 0;
      _ = (Y + (U >>> 13) | 0) + (Nt >>> 26) | 0, Nt &= 67108863, I = Math.imul(st, vt), U = Math.imul(st, mt), U = U + Math.imul(Le, vt) | 0, Y = Math.imul(Le, mt);
      var qt = (_ + I | 0) + ((U & 8191) << 13) | 0;
      return _ = (Y + (U >>> 13) | 0) + (qt >>> 26) | 0, qt &= 67108863, P[0] = wt, P[1] = Mt, P[2] = _t, P[3] = xt, P[4] = Et, P[5] = St, P[6] = $t, P[7] = At, P[8] = Rt, P[9] = Bt, P[10] = Tt, P[11] = Pt, P[12] = It, P[13] = Ot, P[14] = Ct, P[15] = Dt, P[16] = kt, P[17] = Nt, P[18] = qt, _ !== 0 && (P[19] = _, O.length++), O;
    };
    Math.imul || (ne = de);
    function ge(E, A, B) {
      B.negative = A.negative ^ E.negative, B.length = E.length + A.length;
      for (var O = 0, C = 0, L = 0; L < B.length - 1; L++) {
        var P = C;
        C = 0;
        for (var _ = O & 67108863, I = Math.min(L, A.length - 1), U = Math.max(0, L - E.length + 1); U <= I; U++) {
          var Y = L - U, te = E.words[Y] | 0, oe = A.words[U] | 0, re = te * oe, ee = re & 67108863;
          P = P + (re / 67108864 | 0) | 0, ee = ee + _ | 0, _ = ee & 67108863, P = P + (ee >>> 26) | 0, C += P >>> 26, P &= 67108863;
        }
        B.words[L] = _, O = P, P = C;
      }
      return O !== 0 ? B.words[L] = O : B.length--, B._strip();
    }
    function pe(E, A, B) {
      return ge(E, A, B);
    }
    S.prototype.mulTo = function(A, B) {
      var O, C = this.length + A.length;
      return this.length === 10 && A.length === 10 ? O = ne(this, A, B) : C < 63 ? O = de(this, A, B) : C < 1024 ? O = ge(this, A, B) : O = pe(this, A, B), O;
    }, S.prototype.mul = function(A) {
      var B = new S(null);
      return B.words = new Array(this.length + A.length), this.mulTo(A, B);
    }, S.prototype.mulf = function(A) {
      var B = new S(null);
      return B.words = new Array(this.length + A.length), pe(this, A, B);
    }, S.prototype.imul = function(A) {
      return this.clone().mulTo(A, this);
    }, S.prototype.imuln = function(A) {
      var B = A < 0;
      B && (A = -A), $(typeof A == "number"), $(A < 67108864);
      for (var O = 0, C = 0; C < this.length; C++) {
        var L = (this.words[C] | 0) * A, P = (L & 67108863) + (O & 67108863);
        O >>= 26, O += L / 67108864 | 0, O += P >>> 26, this.words[C] = P & 67108863;
      }
      return O !== 0 && (this.words[C] = O, this.length++), this.length = A === 0 ? 1 : this.length, B ? this.ineg() : this;
    }, S.prototype.muln = function(A) {
      return this.clone().imuln(A);
    }, S.prototype.sqr = function() {
      return this.mul(this);
    }, S.prototype.isqr = function() {
      return this.imul(this.clone());
    }, S.prototype.pow = function(A) {
      var B = me(A);
      if (B.length === 0) return new S(1);
      for (var O = this, C = 0; C < B.length && B[C] === 0; C++, O = O.sqr())
        ;
      if (++C < B.length)
        for (var L = O.sqr(); C < B.length; C++, L = L.sqr())
          B[C] !== 0 && (O = O.mul(L));
      return O;
    }, S.prototype.iushln = function(A) {
      $(typeof A == "number" && A >= 0);
      var B = A % 26, O = (A - B) / 26, C = 67108863 >>> 26 - B << 26 - B, L;
      if (B !== 0) {
        var P = 0;
        for (L = 0; L < this.length; L++) {
          var _ = this.words[L] & C, I = (this.words[L] | 0) - _ << B;
          this.words[L] = I | P, P = _ >>> 26 - B;
        }
        P && (this.words[L] = P, this.length++);
      }
      if (O !== 0) {
        for (L = this.length - 1; L >= 0; L--)
          this.words[L + O] = this.words[L];
        for (L = 0; L < O; L++)
          this.words[L] = 0;
        this.length += O;
      }
      return this._strip();
    }, S.prototype.ishln = function(A) {
      return $(this.negative === 0), this.iushln(A);
    }, S.prototype.iushrn = function(A, B, O) {
      $(typeof A == "number" && A >= 0);
      var C;
      B ? C = (B - B % 26) / 26 : C = 0;
      var L = A % 26, P = Math.min((A - L) / 26, this.length), _ = 67108863 ^ 67108863 >>> L << L, I = O;
      if (C -= P, C = Math.max(0, C), I) {
        for (var U = 0; U < P; U++)
          I.words[U] = this.words[U];
        I.length = P;
      }
      if (P !== 0) if (this.length > P)
        for (this.length -= P, U = 0; U < this.length; U++)
          this.words[U] = this.words[U + P];
      else
        this.words[0] = 0, this.length = 1;
      var Y = 0;
      for (U = this.length - 1; U >= 0 && (Y !== 0 || U >= C); U--) {
        var te = this.words[U] | 0;
        this.words[U] = Y << 26 - L | te >>> L, Y = te & _;
      }
      return I && Y !== 0 && (I.words[I.length++] = Y), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, S.prototype.ishrn = function(A, B, O) {
      return $(this.negative === 0), this.iushrn(A, B, O);
    }, S.prototype.shln = function(A) {
      return this.clone().ishln(A);
    }, S.prototype.ushln = function(A) {
      return this.clone().iushln(A);
    }, S.prototype.shrn = function(A) {
      return this.clone().ishrn(A);
    }, S.prototype.ushrn = function(A) {
      return this.clone().iushrn(A);
    }, S.prototype.testn = function(A) {
      $(typeof A == "number" && A >= 0);
      var B = A % 26, O = (A - B) / 26, C = 1 << B;
      if (this.length <= O) return !1;
      var L = this.words[O];
      return !!(L & C);
    }, S.prototype.imaskn = function(A) {
      $(typeof A == "number" && A >= 0);
      var B = A % 26, O = (A - B) / 26;
      if ($(this.negative === 0, "imaskn works only with positive numbers"), this.length <= O)
        return this;
      if (B !== 0 && O++, this.length = Math.min(O, this.length), B !== 0) {
        var C = 67108863 ^ 67108863 >>> B << B;
        this.words[this.length - 1] &= C;
      }
      return this._strip();
    }, S.prototype.maskn = function(A) {
      return this.clone().imaskn(A);
    }, S.prototype.iaddn = function(A) {
      return $(typeof A == "number"), $(A < 67108864), A < 0 ? this.isubn(-A) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= A ? (this.words[0] = A - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(A), this.negative = 1, this) : this._iaddn(A);
    }, S.prototype._iaddn = function(A) {
      this.words[0] += A;
      for (var B = 0; B < this.length && this.words[B] >= 67108864; B++)
        this.words[B] -= 67108864, B === this.length - 1 ? this.words[B + 1] = 1 : this.words[B + 1]++;
      return this.length = Math.max(this.length, B + 1), this;
    }, S.prototype.isubn = function(A) {
      if ($(typeof A == "number"), $(A < 67108864), A < 0) return this.iaddn(-A);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(A), this.negative = 1, this;
      if (this.words[0] -= A, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var B = 0; B < this.length && this.words[B] < 0; B++)
          this.words[B] += 67108864, this.words[B + 1] -= 1;
      return this._strip();
    }, S.prototype.addn = function(A) {
      return this.clone().iaddn(A);
    }, S.prototype.subn = function(A) {
      return this.clone().isubn(A);
    }, S.prototype.iabs = function() {
      return this.negative = 0, this;
    }, S.prototype.abs = function() {
      return this.clone().iabs();
    }, S.prototype._ishlnsubmul = function(A, B, O) {
      var C = A.length + O, L;
      this._expand(C);
      var P, _ = 0;
      for (L = 0; L < A.length; L++) {
        P = (this.words[L + O] | 0) + _;
        var I = (A.words[L] | 0) * B;
        P -= I & 67108863, _ = (P >> 26) - (I / 67108864 | 0), this.words[L + O] = P & 67108863;
      }
      for (; L < this.length - O; L++)
        P = (this.words[L + O] | 0) + _, _ = P >> 26, this.words[L + O] = P & 67108863;
      if (_ === 0) return this._strip();
      for ($(_ === -1), _ = 0, L = 0; L < this.length; L++)
        P = -(this.words[L] | 0) + _, _ = P >> 26, this.words[L] = P & 67108863;
      return this.negative = 1, this._strip();
    }, S.prototype._wordDiv = function(A, B) {
      var O = this.length - A.length, C = this.clone(), L = A, P = L.words[L.length - 1] | 0, _ = this._countBits(P);
      O = 26 - _, O !== 0 && (L = L.ushln(O), C.iushln(O), P = L.words[L.length - 1] | 0);
      var I = C.length - L.length, U;
      if (B !== "mod") {
        U = new S(null), U.length = I + 1, U.words = new Array(U.length);
        for (var Y = 0; Y < U.length; Y++)
          U.words[Y] = 0;
      }
      var te = C.clone()._ishlnsubmul(L, 1, I);
      te.negative === 0 && (C = te, U && (U.words[I] = 1));
      for (var oe = I - 1; oe >= 0; oe--) {
        var re = (C.words[L.length + oe] | 0) * 67108864 + (C.words[L.length + oe - 1] | 0);
        for (re = Math.min(re / P | 0, 67108863), C._ishlnsubmul(L, re, oe); C.negative !== 0; )
          re--, C.negative = 0, C._ishlnsubmul(L, 1, oe), C.isZero() || (C.negative ^= 1);
        U && (U.words[oe] = re);
      }
      return U && U._strip(), C._strip(), B !== "div" && O !== 0 && C.iushrn(O), {
        div: U || null,
        mod: C
      };
    }, S.prototype.divmod = function(A, B, O) {
      if ($(!A.isZero()), this.isZero())
        return {
          div: new S(0),
          mod: new S(0)
        };
      var C, L, P;
      return this.negative !== 0 && A.negative === 0 ? (P = this.neg().divmod(A, B), B !== "mod" && (C = P.div.neg()), B !== "div" && (L = P.mod.neg(), O && L.negative !== 0 && L.iadd(A)), {
        div: C,
        mod: L
      }) : this.negative === 0 && A.negative !== 0 ? (P = this.divmod(A.neg(), B), B !== "mod" && (C = P.div.neg()), {
        div: C,
        mod: P.mod
      }) : this.negative & A.negative ? (P = this.neg().divmod(A.neg(), B), B !== "div" && (L = P.mod.neg(), O && L.negative !== 0 && L.isub(A)), {
        div: P.div,
        mod: L
      }) : A.length > this.length || this.cmp(A) < 0 ? {
        div: new S(0),
        mod: this
      } : A.length === 1 ? B === "div" ? {
        div: this.divn(A.words[0]),
        mod: null
      } : B === "mod" ? {
        div: null,
        mod: new S(this.modrn(A.words[0]))
      } : {
        div: this.divn(A.words[0]),
        mod: new S(this.modrn(A.words[0]))
      } : this._wordDiv(A, B);
    }, S.prototype.div = function(A) {
      return this.divmod(A, "div", !1).div;
    }, S.prototype.mod = function(A) {
      return this.divmod(A, "mod", !1).mod;
    }, S.prototype.umod = function(A) {
      return this.divmod(A, "mod", !0).mod;
    }, S.prototype.divRound = function(A) {
      var B = this.divmod(A);
      if (B.mod.isZero()) return B.div;
      var O = B.div.negative !== 0 ? B.mod.isub(A) : B.mod, C = A.ushrn(1), L = A.andln(1), P = O.cmp(C);
      return P < 0 || L === 1 && P === 0 ? B.div : B.div.negative !== 0 ? B.div.isubn(1) : B.div.iaddn(1);
    }, S.prototype.modrn = function(A) {
      var B = A < 0;
      B && (A = -A), $(A <= 67108863);
      for (var O = (1 << 26) % A, C = 0, L = this.length - 1; L >= 0; L--)
        C = (O * C + (this.words[L] | 0)) % A;
      return B ? -C : C;
    }, S.prototype.modn = function(A) {
      return this.modrn(A);
    }, S.prototype.idivn = function(A) {
      var B = A < 0;
      B && (A = -A), $(A <= 67108863);
      for (var O = 0, C = this.length - 1; C >= 0; C--) {
        var L = (this.words[C] | 0) + O * 67108864;
        this.words[C] = L / A | 0, O = L % A;
      }
      return this._strip(), B ? this.ineg() : this;
    }, S.prototype.divn = function(A) {
      return this.clone().idivn(A);
    }, S.prototype.egcd = function(A) {
      $(A.negative === 0), $(!A.isZero());
      var B = this, O = A.clone();
      B.negative !== 0 ? B = B.umod(A) : B = B.clone();
      for (var C = new S(1), L = new S(0), P = new S(0), _ = new S(1), I = 0; B.isEven() && O.isEven(); )
        B.iushrn(1), O.iushrn(1), ++I;
      for (var U = O.clone(), Y = B.clone(); !B.isZero(); ) {
        for (var te = 0, oe = 1; !(B.words[0] & oe) && te < 26; ++te, oe <<= 1) ;
        if (te > 0)
          for (B.iushrn(te); te-- > 0; )
            (C.isOdd() || L.isOdd()) && (C.iadd(U), L.isub(Y)), C.iushrn(1), L.iushrn(1);
        for (var re = 0, ee = 1; !(O.words[0] & ee) && re < 26; ++re, ee <<= 1) ;
        if (re > 0)
          for (O.iushrn(re); re-- > 0; )
            (P.isOdd() || _.isOdd()) && (P.iadd(U), _.isub(Y)), P.iushrn(1), _.iushrn(1);
        B.cmp(O) >= 0 ? (B.isub(O), C.isub(P), L.isub(_)) : (O.isub(B), P.isub(C), _.isub(L));
      }
      return {
        a: P,
        b: _,
        gcd: O.iushln(I)
      };
    }, S.prototype._invmp = function(A) {
      $(A.negative === 0), $(!A.isZero());
      var B = this, O = A.clone();
      B.negative !== 0 ? B = B.umod(A) : B = B.clone();
      for (var C = new S(1), L = new S(0), P = O.clone(); B.cmpn(1) > 0 && O.cmpn(1) > 0; ) {
        for (var _ = 0, I = 1; !(B.words[0] & I) && _ < 26; ++_, I <<= 1) ;
        if (_ > 0)
          for (B.iushrn(_); _-- > 0; )
            C.isOdd() && C.iadd(P), C.iushrn(1);
        for (var U = 0, Y = 1; !(O.words[0] & Y) && U < 26; ++U, Y <<= 1) ;
        if (U > 0)
          for (O.iushrn(U); U-- > 0; )
            L.isOdd() && L.iadd(P), L.iushrn(1);
        B.cmp(O) >= 0 ? (B.isub(O), C.isub(L)) : (O.isub(B), L.isub(C));
      }
      var te;
      return B.cmpn(1) === 0 ? te = C : te = L, te.cmpn(0) < 0 && te.iadd(A), te;
    }, S.prototype.gcd = function(A) {
      if (this.isZero()) return A.abs();
      if (A.isZero()) return this.abs();
      var B = this.clone(), O = A.clone();
      B.negative = 0, O.negative = 0;
      for (var C = 0; B.isEven() && O.isEven(); C++)
        B.iushrn(1), O.iushrn(1);
      do {
        for (; B.isEven(); )
          B.iushrn(1);
        for (; O.isEven(); )
          O.iushrn(1);
        var L = B.cmp(O);
        if (L < 0) {
          var P = B;
          B = O, O = P;
        } else if (L === 0 || O.cmpn(1) === 0)
          break;
        B.isub(O);
      } while (!0);
      return O.iushln(C);
    }, S.prototype.invm = function(A) {
      return this.egcd(A).a.umod(A);
    }, S.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, S.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, S.prototype.andln = function(A) {
      return this.words[0] & A;
    }, S.prototype.bincn = function(A) {
      $(typeof A == "number");
      var B = A % 26, O = (A - B) / 26, C = 1 << B;
      if (this.length <= O)
        return this._expand(O + 1), this.words[O] |= C, this;
      for (var L = C, P = O; L !== 0 && P < this.length; P++) {
        var _ = this.words[P] | 0;
        _ += L, L = _ >>> 26, _ &= 67108863, this.words[P] = _;
      }
      return L !== 0 && (this.words[P] = L, this.length++), this;
    }, S.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, S.prototype.cmpn = function(A) {
      var B = A < 0;
      if (this.negative !== 0 && !B) return -1;
      if (this.negative === 0 && B) return 1;
      this._strip();
      var O;
      if (this.length > 1)
        O = 1;
      else {
        B && (A = -A), $(A <= 67108863, "Number is too big");
        var C = this.words[0] | 0;
        O = C === A ? 0 : C < A ? -1 : 1;
      }
      return this.negative !== 0 ? -O | 0 : O;
    }, S.prototype.cmp = function(A) {
      if (this.negative !== 0 && A.negative === 0) return -1;
      if (this.negative === 0 && A.negative !== 0) return 1;
      var B = this.ucmp(A);
      return this.negative !== 0 ? -B | 0 : B;
    }, S.prototype.ucmp = function(A) {
      if (this.length > A.length) return 1;
      if (this.length < A.length) return -1;
      for (var B = 0, O = this.length - 1; O >= 0; O--) {
        var C = this.words[O] | 0, L = A.words[O] | 0;
        if (C !== L) {
          C < L ? B = -1 : C > L && (B = 1);
          break;
        }
      }
      return B;
    }, S.prototype.gtn = function(A) {
      return this.cmpn(A) === 1;
    }, S.prototype.gt = function(A) {
      return this.cmp(A) === 1;
    }, S.prototype.gten = function(A) {
      return this.cmpn(A) >= 0;
    }, S.prototype.gte = function(A) {
      return this.cmp(A) >= 0;
    }, S.prototype.ltn = function(A) {
      return this.cmpn(A) === -1;
    }, S.prototype.lt = function(A) {
      return this.cmp(A) === -1;
    }, S.prototype.lten = function(A) {
      return this.cmpn(A) <= 0;
    }, S.prototype.lte = function(A) {
      return this.cmp(A) <= 0;
    }, S.prototype.eqn = function(A) {
      return this.cmpn(A) === 0;
    }, S.prototype.eq = function(A) {
      return this.cmp(A) === 0;
    }, S.red = function(A) {
      return new N(A);
    }, S.prototype.toRed = function(A) {
      return $(!this.red, "Already a number in reduction context"), $(this.negative === 0, "red works only with positives"), A.convertTo(this)._forceRed(A);
    }, S.prototype.fromRed = function() {
      return $(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, S.prototype._forceRed = function(A) {
      return this.red = A, this;
    }, S.prototype.forceRed = function(A) {
      return $(!this.red, "Already a number in reduction context"), this._forceRed(A);
    }, S.prototype.redAdd = function(A) {
      return $(this.red, "redAdd works only with red numbers"), this.red.add(this, A);
    }, S.prototype.redIAdd = function(A) {
      return $(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, A);
    }, S.prototype.redSub = function(A) {
      return $(this.red, "redSub works only with red numbers"), this.red.sub(this, A);
    }, S.prototype.redISub = function(A) {
      return $(this.red, "redISub works only with red numbers"), this.red.isub(this, A);
    }, S.prototype.redShl = function(A) {
      return $(this.red, "redShl works only with red numbers"), this.red.shl(this, A);
    }, S.prototype.redMul = function(A) {
      return $(this.red, "redMul works only with red numbers"), this.red._verify2(this, A), this.red.mul(this, A);
    }, S.prototype.redIMul = function(A) {
      return $(this.red, "redMul works only with red numbers"), this.red._verify2(this, A), this.red.imul(this, A);
    }, S.prototype.redSqr = function() {
      return $(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, S.prototype.redISqr = function() {
      return $(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, S.prototype.redSqrt = function() {
      return $(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, S.prototype.redInvm = function() {
      return $(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, S.prototype.redNeg = function() {
      return $(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, S.prototype.redPow = function(A) {
      return $(this.red && !A.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, A);
    };
    var $e = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Re(E, A) {
      this.name = E, this.p = new S(A, 16), this.n = this.p.bitLength(), this.k = new S(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Re.prototype._tmp = function() {
      var A = new S(null);
      return A.words = new Array(Math.ceil(this.n / 13)), A;
    }, Re.prototype.ireduce = function(A) {
      var B = A, O;
      do
        this.split(B, this.tmp), B = this.imulK(B), B = B.iadd(this.tmp), O = B.bitLength();
      while (O > this.n);
      var C = O < this.n ? -1 : B.ucmp(this.p);
      return C === 0 ? (B.words[0] = 0, B.length = 1) : C > 0 ? B.isub(this.p) : B.strip !== void 0 ? B.strip() : B._strip(), B;
    }, Re.prototype.split = function(A, B) {
      A.iushrn(this.n, 0, B);
    }, Re.prototype.imulK = function(A) {
      return A.imul(this.k);
    };
    function Pe() {
      Re.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    T(Pe, Re), Pe.prototype.split = function(A, B) {
      for (var O = 4194303, C = Math.min(A.length, 9), L = 0; L < C; L++)
        B.words[L] = A.words[L];
      if (B.length = C, A.length <= 9) {
        A.words[0] = 0, A.length = 1;
        return;
      }
      var P = A.words[9];
      for (B.words[B.length++] = P & O, L = 10; L < A.length; L++) {
        var _ = A.words[L] | 0;
        A.words[L - 10] = (_ & O) << 4 | P >>> 22, P = _;
      }
      P >>>= 22, A.words[L - 10] = P, P === 0 && A.length > 10 ? A.length -= 10 : A.length -= 9;
    }, Pe.prototype.imulK = function(A) {
      A.words[A.length] = 0, A.words[A.length + 1] = 0, A.length += 2;
      for (var B = 0, O = 0; O < A.length; O++) {
        var C = A.words[O] | 0;
        B += C * 977, A.words[O] = B & 67108863, B = C * 64 + (B / 67108864 | 0);
      }
      return A.words[A.length - 1] === 0 && (A.length--, A.words[A.length - 1] === 0 && A.length--), A;
    };
    function Oe() {
      Re.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    T(Oe, Re);
    function xe() {
      Re.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    T(xe, Re);
    function rt() {
      Re.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    T(rt, Re), rt.prototype.imulK = function(A) {
      for (var B = 0, O = 0; O < A.length; O++) {
        var C = (A.words[O] | 0) * 19 + B, L = C & 67108863;
        C >>>= 26, A.words[O] = L, B = C;
      }
      return B !== 0 && (A.words[A.length++] = B), A;
    }, S._prime = function(A) {
      if ($e[A]) return $e[A];
      var B;
      if (A === "k256")
        B = new Pe();
      else if (A === "p224")
        B = new Oe();
      else if (A === "p192")
        B = new xe();
      else if (A === "p25519")
        B = new rt();
      else
        throw new Error("Unknown prime " + A);
      return $e[A] = B, B;
    };
    function N(E) {
      if (typeof E == "string") {
        var A = S._prime(E);
        this.m = A.p, this.prime = A;
      } else
        $(E.gtn(1), "modulus must be greater than 1"), this.m = E, this.prime = null;
    }
    N.prototype._verify1 = function(A) {
      $(A.negative === 0, "red works only with positives"), $(A.red, "red works only with red numbers");
    }, N.prototype._verify2 = function(A, B) {
      $((A.negative | B.negative) === 0, "red works only with positives"), $(
        A.red && A.red === B.red,
        "red works only with red numbers"
      );
    }, N.prototype.imod = function(A) {
      return this.prime ? this.prime.ireduce(A)._forceRed(this) : (H(A, A.umod(this.m)._forceRed(this)), A);
    }, N.prototype.neg = function(A) {
      return A.isZero() ? A.clone() : this.m.sub(A)._forceRed(this);
    }, N.prototype.add = function(A, B) {
      this._verify2(A, B);
      var O = A.add(B);
      return O.cmp(this.m) >= 0 && O.isub(this.m), O._forceRed(this);
    }, N.prototype.iadd = function(A, B) {
      this._verify2(A, B);
      var O = A.iadd(B);
      return O.cmp(this.m) >= 0 && O.isub(this.m), O;
    }, N.prototype.sub = function(A, B) {
      this._verify2(A, B);
      var O = A.sub(B);
      return O.cmpn(0) < 0 && O.iadd(this.m), O._forceRed(this);
    }, N.prototype.isub = function(A, B) {
      this._verify2(A, B);
      var O = A.isub(B);
      return O.cmpn(0) < 0 && O.iadd(this.m), O;
    }, N.prototype.shl = function(A, B) {
      return this._verify1(A), this.imod(A.ushln(B));
    }, N.prototype.imul = function(A, B) {
      return this._verify2(A, B), this.imod(A.imul(B));
    }, N.prototype.mul = function(A, B) {
      return this._verify2(A, B), this.imod(A.mul(B));
    }, N.prototype.isqr = function(A) {
      return this.imul(A, A.clone());
    }, N.prototype.sqr = function(A) {
      return this.mul(A, A);
    }, N.prototype.sqrt = function(A) {
      if (A.isZero()) return A.clone();
      var B = this.m.andln(3);
      if ($(B % 2 === 1), B === 3) {
        var O = this.m.add(new S(1)).iushrn(2);
        return this.pow(A, O);
      }
      for (var C = this.m.subn(1), L = 0; !C.isZero() && C.andln(1) === 0; )
        L++, C.iushrn(1);
      $(!C.isZero());
      var P = new S(1).toRed(this), _ = P.redNeg(), I = this.m.subn(1).iushrn(1), U = this.m.bitLength();
      for (U = new S(2 * U * U).toRed(this); this.pow(U, I).cmp(_) !== 0; )
        U.redIAdd(_);
      for (var Y = this.pow(U, C), te = this.pow(A, C.addn(1).iushrn(1)), oe = this.pow(A, C), re = L; oe.cmp(P) !== 0; ) {
        for (var ee = oe, ae = 0; ee.cmp(P) !== 0; ae++)
          ee = ee.redSqr();
        $(ae < re);
        var ue = this.pow(Y, new S(1).iushln(re - ae - 1));
        te = te.redMul(ue), Y = ue.redSqr(), oe = oe.redMul(Y), re = ae;
      }
      return te;
    }, N.prototype.invm = function(A) {
      var B = A._invmp(this.m);
      return B.negative !== 0 ? (B.negative = 0, this.imod(B).redNeg()) : this.imod(B);
    }, N.prototype.pow = function(A, B) {
      if (B.isZero()) return new S(1).toRed(this);
      if (B.cmpn(1) === 0) return A.clone();
      var O = 4, C = new Array(1 << O);
      C[0] = new S(1).toRed(this), C[1] = A;
      for (var L = 2; L < C.length; L++)
        C[L] = this.mul(C[L - 1], A);
      var P = C[0], _ = 0, I = 0, U = B.bitLength() % 26;
      for (U === 0 && (U = 26), L = B.length - 1; L >= 0; L--) {
        for (var Y = B.words[L], te = U - 1; te >= 0; te--) {
          var oe = Y >> te & 1;
          if (P !== C[0] && (P = this.sqr(P)), oe === 0 && _ === 0) {
            I = 0;
            continue;
          }
          _ <<= 1, _ |= oe, I++, !(I !== O && (L !== 0 || te !== 0)) && (P = this.mul(P, C[_]), I = 0, _ = 0);
        }
        U = 26;
      }
      return P;
    }, N.prototype.convertTo = function(A) {
      var B = A.umod(this.m);
      return B === A ? B.clone() : B;
    }, N.prototype.convertFrom = function(A) {
      var B = A.clone();
      return B.red = null, B;
    }, S.mont = function(A) {
      return new y(A);
    };
    function y(E) {
      N.call(this, E), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new S(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    T(y, N), y.prototype.convertTo = function(A) {
      return this.imod(A.ushln(this.shift));
    }, y.prototype.convertFrom = function(A) {
      var B = this.imod(A.mul(this.rinv));
      return B.red = null, B;
    }, y.prototype.imul = function(A, B) {
      if (A.isZero() || B.isZero())
        return A.words[0] = 0, A.length = 1, A;
      var O = A.imul(B), C = O.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), L = O.isub(C).iushrn(this.shift), P = L;
      return L.cmp(this.m) >= 0 ? P = L.isub(this.m) : L.cmpn(0) < 0 && (P = L.iadd(this.m)), P._forceRed(this);
    }, y.prototype.mul = function(A, B) {
      if (A.isZero() || B.isZero()) return new S(0)._forceRed(this);
      var O = A.mul(B), C = O.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), L = O.isub(C).iushrn(this.shift), P = L;
      return L.cmp(this.m) >= 0 ? P = L.isub(this.m) : L.cmpn(0) < 0 && (P = L.iadd(this.m)), P._forceRed(this);
    }, y.prototype.invm = function(A) {
      var B = this.imod(A._invmp(this.m).mul(this.r2));
      return B._forceRed(this);
    };
  })(w, commonjsGlobal);
})(bn$4);
var bnExports$4 = bn$4.exports, BN$a = bnExports$4, randomBytes$1 = browserExports, Buffer$7 = safeBufferExports$2.Buffer;
function getr(w) {
  var M = w.modulus.byteLength(), x;
  do
    x = new BN$a(randomBytes$1(M));
  while (x.cmp(w.modulus) >= 0 || !x.umod(w.prime1) || !x.umod(w.prime2));
  return x;
}
function blind(w) {
  var M = getr(w), x = M.toRed(BN$a.mont(w.modulus)).redPow(new BN$a(w.publicExponent)).fromRed();
  return { blinder: x, unblinder: M.invm(w.modulus) };
}
function crt$2(w, M) {
  var x = blind(M), $ = M.modulus.byteLength(), T = new BN$a(w).mul(x.blinder).umod(M.modulus), S = T.toRed(BN$a.mont(M.prime1)), D = T.toRed(BN$a.mont(M.prime2)), F = M.coefficient, z = M.prime1, Z = M.prime2, H = S.redPow(M.exponent1).fromRed(), V = D.redPow(M.exponent2).fromRed(), X = H.isub(V).imul(F).umod(z).imul(Z);
  return V.iadd(X).imul(x.unblinder).umod(M.modulus).toArrayLike(Buffer$7, "be", $);
}
crt$2.getr = getr;
var browserifyRsa = crt$2, elliptic = {};
const version$2 = "6.6.1", require$$0 = {
  version: version$2
};
var utils$l = {}, bn$3 = { exports: {} };
bn$3.exports;
(function(w) {
  (function(M, x) {
    function $(N, y) {
      if (!N) throw new Error(y || "Assertion failed");
    }
    function T(N, y) {
      N.super_ = y;
      var E = function() {
      };
      E.prototype = y.prototype, N.prototype = new E(), N.prototype.constructor = N;
    }
    function S(N, y, E) {
      if (S.isBN(N))
        return N;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, N !== null && ((y === "le" || y === "be") && (E = y, y = 10), this._init(N || 0, y || 10, E || "be"));
    }
    typeof M == "object" ? M.exports = S : x.BN = S, S.BN = S, S.wordSize = 26;
    var D;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? D = window.Buffer : D = dist.Buffer;
    } catch {
    }
    S.isBN = function(y) {
      return y instanceof S ? !0 : y !== null && typeof y == "object" && y.constructor.wordSize === S.wordSize && Array.isArray(y.words);
    }, S.max = function(y, E) {
      return y.cmp(E) > 0 ? y : E;
    }, S.min = function(y, E) {
      return y.cmp(E) < 0 ? y : E;
    }, S.prototype._init = function(y, E, A) {
      if (typeof y == "number")
        return this._initNumber(y, E, A);
      if (typeof y == "object")
        return this._initArray(y, E, A);
      E === "hex" && (E = 16), $(E === (E | 0) && E >= 2 && E <= 36), y = y.toString().replace(/\s+/g, "");
      var B = 0;
      y[0] === "-" && (B++, this.negative = 1), B < y.length && (E === 16 ? this._parseHex(y, B, A) : (this._parseBase(y, E, B), A === "le" && this._initArray(this.toArray(), E, A)));
    }, S.prototype._initNumber = function(y, E, A) {
      y < 0 && (this.negative = 1, y = -y), y < 67108864 ? (this.words = [y & 67108863], this.length = 1) : y < 4503599627370496 ? (this.words = [
        y & 67108863,
        y / 67108864 & 67108863
      ], this.length = 2) : ($(y < 9007199254740992), this.words = [
        y & 67108863,
        y / 67108864 & 67108863,
        1
      ], this.length = 3), A === "le" && this._initArray(this.toArray(), E, A);
    }, S.prototype._initArray = function(y, E, A) {
      if ($(typeof y.length == "number"), y.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(y.length / 3), this.words = new Array(this.length);
      for (var B = 0; B < this.length; B++)
        this.words[B] = 0;
      var O, C, L = 0;
      if (A === "be")
        for (B = y.length - 1, O = 0; B >= 0; B -= 3)
          C = y[B] | y[B - 1] << 8 | y[B - 2] << 16, this.words[O] |= C << L & 67108863, this.words[O + 1] = C >>> 26 - L & 67108863, L += 24, L >= 26 && (L -= 26, O++);
      else if (A === "le")
        for (B = 0, O = 0; B < y.length; B += 3)
          C = y[B] | y[B + 1] << 8 | y[B + 2] << 16, this.words[O] |= C << L & 67108863, this.words[O + 1] = C >>> 26 - L & 67108863, L += 24, L >= 26 && (L -= 26, O++);
      return this.strip();
    };
    function F(N, y) {
      var E = N.charCodeAt(y);
      return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
    }
    function z(N, y, E) {
      var A = F(N, E);
      return E - 1 >= y && (A |= F(N, E - 1) << 4), A;
    }
    S.prototype._parseHex = function(y, E, A) {
      this.length = Math.ceil((y.length - E) / 6), this.words = new Array(this.length);
      for (var B = 0; B < this.length; B++)
        this.words[B] = 0;
      var O = 0, C = 0, L;
      if (A === "be")
        for (B = y.length - 1; B >= E; B -= 2)
          L = z(y, E, B) << O, this.words[C] |= L & 67108863, O >= 18 ? (O -= 18, C += 1, this.words[C] |= L >>> 26) : O += 8;
      else {
        var P = y.length - E;
        for (B = P % 2 === 0 ? E + 1 : E; B < y.length; B += 2)
          L = z(y, E, B) << O, this.words[C] |= L & 67108863, O >= 18 ? (O -= 18, C += 1, this.words[C] |= L >>> 26) : O += 8;
      }
      this.strip();
    };
    function Z(N, y, E, A) {
      for (var B = 0, O = Math.min(N.length, E), C = y; C < O; C++) {
        var L = N.charCodeAt(C) - 48;
        B *= A, L >= 49 ? B += L - 49 + 10 : L >= 17 ? B += L - 17 + 10 : B += L;
      }
      return B;
    }
    S.prototype._parseBase = function(y, E, A) {
      this.words = [0], this.length = 1;
      for (var B = 0, O = 1; O <= 67108863; O *= E)
        B++;
      B--, O = O / E | 0;
      for (var C = y.length - A, L = C % B, P = Math.min(C, C - L) + A, _ = 0, I = A; I < P; I += B)
        _ = Z(y, I, I + B, E), this.imuln(O), this.words[0] + _ < 67108864 ? this.words[0] += _ : this._iaddn(_);
      if (L !== 0) {
        var U = 1;
        for (_ = Z(y, I, y.length, E), I = 0; I < L; I++)
          U *= E;
        this.imuln(U), this.words[0] + _ < 67108864 ? this.words[0] += _ : this._iaddn(_);
      }
      this.strip();
    }, S.prototype.copy = function(y) {
      y.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        y.words[E] = this.words[E];
      y.length = this.length, y.negative = this.negative, y.red = this.red;
    }, S.prototype.clone = function() {
      var y = new S(null);
      return this.copy(y), y;
    }, S.prototype._expand = function(y) {
      for (; this.length < y; )
        this.words[this.length++] = 0;
      return this;
    }, S.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, S.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, S.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var H = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], V = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], X = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    S.prototype.toString = function(y, E) {
      y = y || 10, E = E | 0 || 1;
      var A;
      if (y === 16 || y === "hex") {
        A = "";
        for (var B = 0, O = 0, C = 0; C < this.length; C++) {
          var L = this.words[C], P = ((L << B | O) & 16777215).toString(16);
          O = L >>> 24 - B & 16777215, B += 2, B >= 26 && (B -= 26, C--), O !== 0 || C !== this.length - 1 ? A = H[6 - P.length] + P + A : A = P + A;
        }
        for (O !== 0 && (A = O.toString(16) + A); A.length % E !== 0; )
          A = "0" + A;
        return this.negative !== 0 && (A = "-" + A), A;
      }
      if (y === (y | 0) && y >= 2 && y <= 36) {
        var _ = V[y], I = X[y];
        A = "";
        var U = this.clone();
        for (U.negative = 0; !U.isZero(); ) {
          var Y = U.modn(I).toString(y);
          U = U.idivn(I), U.isZero() ? A = Y + A : A = H[_ - Y.length] + Y + A;
        }
        for (this.isZero() && (A = "0" + A); A.length % E !== 0; )
          A = "0" + A;
        return this.negative !== 0 && (A = "-" + A), A;
      }
      $(!1, "Base should be between 2 and 36");
    }, S.prototype.toNumber = function() {
      var y = this.words[0];
      return this.length === 2 ? y += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? y += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && $(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -y : y;
    }, S.prototype.toJSON = function() {
      return this.toString(16);
    }, S.prototype.toBuffer = function(y, E) {
      return $(typeof D < "u"), this.toArrayLike(D, y, E);
    }, S.prototype.toArray = function(y, E) {
      return this.toArrayLike(Array, y, E);
    }, S.prototype.toArrayLike = function(y, E, A) {
      var B = this.byteLength(), O = A || Math.max(1, B);
      $(B <= O, "byte array longer than desired length"), $(O > 0, "Requested array length <= 0"), this.strip();
      var C = E === "le", L = new y(O), P, _, I = this.clone();
      if (C) {
        for (_ = 0; !I.isZero(); _++)
          P = I.andln(255), I.iushrn(8), L[_] = P;
        for (; _ < O; _++)
          L[_] = 0;
      } else {
        for (_ = 0; _ < O - B; _++)
          L[_] = 0;
        for (_ = 0; !I.isZero(); _++)
          P = I.andln(255), I.iushrn(8), L[O - _ - 1] = P;
      }
      return L;
    }, Math.clz32 ? S.prototype._countBits = function(y) {
      return 32 - Math.clz32(y);
    } : S.prototype._countBits = function(y) {
      var E = y, A = 0;
      return E >= 4096 && (A += 13, E >>>= 13), E >= 64 && (A += 7, E >>>= 7), E >= 8 && (A += 4, E >>>= 4), E >= 2 && (A += 2, E >>>= 2), A + E;
    }, S.prototype._zeroBits = function(y) {
      if (y === 0) return 26;
      var E = y, A = 0;
      return E & 8191 || (A += 13, E >>>= 13), E & 127 || (A += 7, E >>>= 7), E & 15 || (A += 4, E >>>= 4), E & 3 || (A += 2, E >>>= 2), E & 1 || A++, A;
    }, S.prototype.bitLength = function() {
      var y = this.words[this.length - 1], E = this._countBits(y);
      return (this.length - 1) * 26 + E;
    };
    function Q(N) {
      for (var y = new Array(N.bitLength()), E = 0; E < y.length; E++) {
        var A = E / 26 | 0, B = E % 26;
        y[E] = (N.words[A] & 1 << B) >>> B;
      }
      return y;
    }
    S.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var y = 0, E = 0; E < this.length; E++) {
        var A = this._zeroBits(this.words[E]);
        if (y += A, A !== 26) break;
      }
      return y;
    }, S.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, S.prototype.toTwos = function(y) {
      return this.negative !== 0 ? this.abs().inotn(y).iaddn(1) : this.clone();
    }, S.prototype.fromTwos = function(y) {
      return this.testn(y - 1) ? this.notn(y).iaddn(1).ineg() : this.clone();
    }, S.prototype.isNeg = function() {
      return this.negative !== 0;
    }, S.prototype.neg = function() {
      return this.clone().ineg();
    }, S.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, S.prototype.iuor = function(y) {
      for (; this.length < y.length; )
        this.words[this.length++] = 0;
      for (var E = 0; E < y.length; E++)
        this.words[E] = this.words[E] | y.words[E];
      return this.strip();
    }, S.prototype.ior = function(y) {
      return $((this.negative | y.negative) === 0), this.iuor(y);
    }, S.prototype.or = function(y) {
      return this.length > y.length ? this.clone().ior(y) : y.clone().ior(this);
    }, S.prototype.uor = function(y) {
      return this.length > y.length ? this.clone().iuor(y) : y.clone().iuor(this);
    }, S.prototype.iuand = function(y) {
      var E;
      this.length > y.length ? E = y : E = this;
      for (var A = 0; A < E.length; A++)
        this.words[A] = this.words[A] & y.words[A];
      return this.length = E.length, this.strip();
    }, S.prototype.iand = function(y) {
      return $((this.negative | y.negative) === 0), this.iuand(y);
    }, S.prototype.and = function(y) {
      return this.length > y.length ? this.clone().iand(y) : y.clone().iand(this);
    }, S.prototype.uand = function(y) {
      return this.length > y.length ? this.clone().iuand(y) : y.clone().iuand(this);
    }, S.prototype.iuxor = function(y) {
      var E, A;
      this.length > y.length ? (E = this, A = y) : (E = y, A = this);
      for (var B = 0; B < A.length; B++)
        this.words[B] = E.words[B] ^ A.words[B];
      if (this !== E)
        for (; B < E.length; B++)
          this.words[B] = E.words[B];
      return this.length = E.length, this.strip();
    }, S.prototype.ixor = function(y) {
      return $((this.negative | y.negative) === 0), this.iuxor(y);
    }, S.prototype.xor = function(y) {
      return this.length > y.length ? this.clone().ixor(y) : y.clone().ixor(this);
    }, S.prototype.uxor = function(y) {
      return this.length > y.length ? this.clone().iuxor(y) : y.clone().iuxor(this);
    }, S.prototype.inotn = function(y) {
      $(typeof y == "number" && y >= 0);
      var E = Math.ceil(y / 26) | 0, A = y % 26;
      this._expand(E), A > 0 && E--;
      for (var B = 0; B < E; B++)
        this.words[B] = ~this.words[B] & 67108863;
      return A > 0 && (this.words[B] = ~this.words[B] & 67108863 >> 26 - A), this.strip();
    }, S.prototype.notn = function(y) {
      return this.clone().inotn(y);
    }, S.prototype.setn = function(y, E) {
      $(typeof y == "number" && y >= 0);
      var A = y / 26 | 0, B = y % 26;
      return this._expand(A + 1), E ? this.words[A] = this.words[A] | 1 << B : this.words[A] = this.words[A] & ~(1 << B), this.strip();
    }, S.prototype.iadd = function(y) {
      var E;
      if (this.negative !== 0 && y.negative === 0)
        return this.negative = 0, E = this.isub(y), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && y.negative !== 0)
        return y.negative = 0, E = this.isub(y), y.negative = 1, E._normSign();
      var A, B;
      this.length > y.length ? (A = this, B = y) : (A = y, B = this);
      for (var O = 0, C = 0; C < B.length; C++)
        E = (A.words[C] | 0) + (B.words[C] | 0) + O, this.words[C] = E & 67108863, O = E >>> 26;
      for (; O !== 0 && C < A.length; C++)
        E = (A.words[C] | 0) + O, this.words[C] = E & 67108863, O = E >>> 26;
      if (this.length = A.length, O !== 0)
        this.words[this.length] = O, this.length++;
      else if (A !== this)
        for (; C < A.length; C++)
          this.words[C] = A.words[C];
      return this;
    }, S.prototype.add = function(y) {
      var E;
      return y.negative !== 0 && this.negative === 0 ? (y.negative = 0, E = this.sub(y), y.negative ^= 1, E) : y.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = y.sub(this), this.negative = 1, E) : this.length > y.length ? this.clone().iadd(y) : y.clone().iadd(this);
    }, S.prototype.isub = function(y) {
      if (y.negative !== 0) {
        y.negative = 0;
        var E = this.iadd(y);
        return y.negative = 1, E._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(y), this.negative = 1, this._normSign();
      var A = this.cmp(y);
      if (A === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var B, O;
      A > 0 ? (B = this, O = y) : (B = y, O = this);
      for (var C = 0, L = 0; L < O.length; L++)
        E = (B.words[L] | 0) - (O.words[L] | 0) + C, C = E >> 26, this.words[L] = E & 67108863;
      for (; C !== 0 && L < B.length; L++)
        E = (B.words[L] | 0) + C, C = E >> 26, this.words[L] = E & 67108863;
      if (C === 0 && L < B.length && B !== this)
        for (; L < B.length; L++)
          this.words[L] = B.words[L];
      return this.length = Math.max(this.length, L), B !== this && (this.negative = 1), this.strip();
    }, S.prototype.sub = function(y) {
      return this.clone().isub(y);
    };
    function fe(N, y, E) {
      E.negative = y.negative ^ N.negative;
      var A = N.length + y.length | 0;
      E.length = A, A = A - 1 | 0;
      var B = N.words[0] | 0, O = y.words[0] | 0, C = B * O, L = C & 67108863, P = C / 67108864 | 0;
      E.words[0] = L;
      for (var _ = 1; _ < A; _++) {
        for (var I = P >>> 26, U = P & 67108863, Y = Math.min(_, y.length - 1), te = Math.max(0, _ - N.length + 1); te <= Y; te++) {
          var oe = _ - te | 0;
          B = N.words[oe] | 0, O = y.words[te] | 0, C = B * O + U, I += C / 67108864 | 0, U = C & 67108863;
        }
        E.words[_] = U | 0, P = I | 0;
      }
      return P !== 0 ? E.words[_] = P | 0 : E.length--, E.strip();
    }
    var ce = function(y, E, A) {
      var B = y.words, O = E.words, C = A.words, L = 0, P, _, I, U = B[0] | 0, Y = U & 8191, te = U >>> 13, oe = B[1] | 0, re = oe & 8191, ee = oe >>> 13, ae = B[2] | 0, ue = ae & 8191, ye = ae >>> 13, ve = B[3] | 0, he = ve & 8191, Me = ve >>> 13, Qe = B[4] | 0, Ie = Qe & 8191, De = Qe >>> 13, at = B[5] | 0, ke = at & 8191, Se = at >>> 13, lt = B[6] | 0, qe = lt & 8191, He = lt >>> 13, ot = B[7] | 0, be = ot & 8191, _e = ot >>> 13, it = B[8] | 0, Ae = it & 8191, Be = it >>> 13, nt = B[9] | 0, Te = nt & 8191, Ue = nt >>> 13, st = O[0] | 0, Le = st & 8191, Ge = st >>> 13, pt = O[1] | 0, je = pt & 8191, Je = pt >>> 13, dt = O[2] | 0, ze = dt & 8191, et = dt >>> 13, yt = O[3] | 0, Ke = yt & 8191, Ye = yt >>> 13, gt = O[4] | 0, We = gt & 8191, Xe = gt >>> 13, bt = O[5] | 0, se = bt & 8191, J = bt >>> 13, ie = O[6] | 0, le = ie & 8191, we = ie >>> 13, Ce = O[7] | 0, Ee = Ce & 8191, Fe = Ce >>> 13, ut = O[8] | 0, Ne = ut & 8191, Ve = ut >>> 13, ht = O[9] | 0, Ze = ht & 8191, tt = ht >>> 13;
      A.negative = y.negative ^ E.negative, A.length = 19, P = Math.imul(Y, Le), _ = Math.imul(Y, Ge), _ = _ + Math.imul(te, Le) | 0, I = Math.imul(te, Ge);
      var vt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, P = Math.imul(re, Le), _ = Math.imul(re, Ge), _ = _ + Math.imul(ee, Le) | 0, I = Math.imul(ee, Ge), P = P + Math.imul(Y, je) | 0, _ = _ + Math.imul(Y, Je) | 0, _ = _ + Math.imul(te, je) | 0, I = I + Math.imul(te, Je) | 0;
      var mt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, P = Math.imul(ue, Le), _ = Math.imul(ue, Ge), _ = _ + Math.imul(ye, Le) | 0, I = Math.imul(ye, Ge), P = P + Math.imul(re, je) | 0, _ = _ + Math.imul(re, Je) | 0, _ = _ + Math.imul(ee, je) | 0, I = I + Math.imul(ee, Je) | 0, P = P + Math.imul(Y, ze) | 0, _ = _ + Math.imul(Y, et) | 0, _ = _ + Math.imul(te, ze) | 0, I = I + Math.imul(te, et) | 0;
      var wt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, P = Math.imul(he, Le), _ = Math.imul(he, Ge), _ = _ + Math.imul(Me, Le) | 0, I = Math.imul(Me, Ge), P = P + Math.imul(ue, je) | 0, _ = _ + Math.imul(ue, Je) | 0, _ = _ + Math.imul(ye, je) | 0, I = I + Math.imul(ye, Je) | 0, P = P + Math.imul(re, ze) | 0, _ = _ + Math.imul(re, et) | 0, _ = _ + Math.imul(ee, ze) | 0, I = I + Math.imul(ee, et) | 0, P = P + Math.imul(Y, Ke) | 0, _ = _ + Math.imul(Y, Ye) | 0, _ = _ + Math.imul(te, Ke) | 0, I = I + Math.imul(te, Ye) | 0;
      var Mt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, P = Math.imul(Ie, Le), _ = Math.imul(Ie, Ge), _ = _ + Math.imul(De, Le) | 0, I = Math.imul(De, Ge), P = P + Math.imul(he, je) | 0, _ = _ + Math.imul(he, Je) | 0, _ = _ + Math.imul(Me, je) | 0, I = I + Math.imul(Me, Je) | 0, P = P + Math.imul(ue, ze) | 0, _ = _ + Math.imul(ue, et) | 0, _ = _ + Math.imul(ye, ze) | 0, I = I + Math.imul(ye, et) | 0, P = P + Math.imul(re, Ke) | 0, _ = _ + Math.imul(re, Ye) | 0, _ = _ + Math.imul(ee, Ke) | 0, I = I + Math.imul(ee, Ye) | 0, P = P + Math.imul(Y, We) | 0, _ = _ + Math.imul(Y, Xe) | 0, _ = _ + Math.imul(te, We) | 0, I = I + Math.imul(te, Xe) | 0;
      var _t = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, P = Math.imul(ke, Le), _ = Math.imul(ke, Ge), _ = _ + Math.imul(Se, Le) | 0, I = Math.imul(Se, Ge), P = P + Math.imul(Ie, je) | 0, _ = _ + Math.imul(Ie, Je) | 0, _ = _ + Math.imul(De, je) | 0, I = I + Math.imul(De, Je) | 0, P = P + Math.imul(he, ze) | 0, _ = _ + Math.imul(he, et) | 0, _ = _ + Math.imul(Me, ze) | 0, I = I + Math.imul(Me, et) | 0, P = P + Math.imul(ue, Ke) | 0, _ = _ + Math.imul(ue, Ye) | 0, _ = _ + Math.imul(ye, Ke) | 0, I = I + Math.imul(ye, Ye) | 0, P = P + Math.imul(re, We) | 0, _ = _ + Math.imul(re, Xe) | 0, _ = _ + Math.imul(ee, We) | 0, I = I + Math.imul(ee, Xe) | 0, P = P + Math.imul(Y, se) | 0, _ = _ + Math.imul(Y, J) | 0, _ = _ + Math.imul(te, se) | 0, I = I + Math.imul(te, J) | 0;
      var xt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, P = Math.imul(qe, Le), _ = Math.imul(qe, Ge), _ = _ + Math.imul(He, Le) | 0, I = Math.imul(He, Ge), P = P + Math.imul(ke, je) | 0, _ = _ + Math.imul(ke, Je) | 0, _ = _ + Math.imul(Se, je) | 0, I = I + Math.imul(Se, Je) | 0, P = P + Math.imul(Ie, ze) | 0, _ = _ + Math.imul(Ie, et) | 0, _ = _ + Math.imul(De, ze) | 0, I = I + Math.imul(De, et) | 0, P = P + Math.imul(he, Ke) | 0, _ = _ + Math.imul(he, Ye) | 0, _ = _ + Math.imul(Me, Ke) | 0, I = I + Math.imul(Me, Ye) | 0, P = P + Math.imul(ue, We) | 0, _ = _ + Math.imul(ue, Xe) | 0, _ = _ + Math.imul(ye, We) | 0, I = I + Math.imul(ye, Xe) | 0, P = P + Math.imul(re, se) | 0, _ = _ + Math.imul(re, J) | 0, _ = _ + Math.imul(ee, se) | 0, I = I + Math.imul(ee, J) | 0, P = P + Math.imul(Y, le) | 0, _ = _ + Math.imul(Y, we) | 0, _ = _ + Math.imul(te, le) | 0, I = I + Math.imul(te, we) | 0;
      var Et = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, P = Math.imul(be, Le), _ = Math.imul(be, Ge), _ = _ + Math.imul(_e, Le) | 0, I = Math.imul(_e, Ge), P = P + Math.imul(qe, je) | 0, _ = _ + Math.imul(qe, Je) | 0, _ = _ + Math.imul(He, je) | 0, I = I + Math.imul(He, Je) | 0, P = P + Math.imul(ke, ze) | 0, _ = _ + Math.imul(ke, et) | 0, _ = _ + Math.imul(Se, ze) | 0, I = I + Math.imul(Se, et) | 0, P = P + Math.imul(Ie, Ke) | 0, _ = _ + Math.imul(Ie, Ye) | 0, _ = _ + Math.imul(De, Ke) | 0, I = I + Math.imul(De, Ye) | 0, P = P + Math.imul(he, We) | 0, _ = _ + Math.imul(he, Xe) | 0, _ = _ + Math.imul(Me, We) | 0, I = I + Math.imul(Me, Xe) | 0, P = P + Math.imul(ue, se) | 0, _ = _ + Math.imul(ue, J) | 0, _ = _ + Math.imul(ye, se) | 0, I = I + Math.imul(ye, J) | 0, P = P + Math.imul(re, le) | 0, _ = _ + Math.imul(re, we) | 0, _ = _ + Math.imul(ee, le) | 0, I = I + Math.imul(ee, we) | 0, P = P + Math.imul(Y, Ee) | 0, _ = _ + Math.imul(Y, Fe) | 0, _ = _ + Math.imul(te, Ee) | 0, I = I + Math.imul(te, Fe) | 0;
      var St = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, P = Math.imul(Ae, Le), _ = Math.imul(Ae, Ge), _ = _ + Math.imul(Be, Le) | 0, I = Math.imul(Be, Ge), P = P + Math.imul(be, je) | 0, _ = _ + Math.imul(be, Je) | 0, _ = _ + Math.imul(_e, je) | 0, I = I + Math.imul(_e, Je) | 0, P = P + Math.imul(qe, ze) | 0, _ = _ + Math.imul(qe, et) | 0, _ = _ + Math.imul(He, ze) | 0, I = I + Math.imul(He, et) | 0, P = P + Math.imul(ke, Ke) | 0, _ = _ + Math.imul(ke, Ye) | 0, _ = _ + Math.imul(Se, Ke) | 0, I = I + Math.imul(Se, Ye) | 0, P = P + Math.imul(Ie, We) | 0, _ = _ + Math.imul(Ie, Xe) | 0, _ = _ + Math.imul(De, We) | 0, I = I + Math.imul(De, Xe) | 0, P = P + Math.imul(he, se) | 0, _ = _ + Math.imul(he, J) | 0, _ = _ + Math.imul(Me, se) | 0, I = I + Math.imul(Me, J) | 0, P = P + Math.imul(ue, le) | 0, _ = _ + Math.imul(ue, we) | 0, _ = _ + Math.imul(ye, le) | 0, I = I + Math.imul(ye, we) | 0, P = P + Math.imul(re, Ee) | 0, _ = _ + Math.imul(re, Fe) | 0, _ = _ + Math.imul(ee, Ee) | 0, I = I + Math.imul(ee, Fe) | 0, P = P + Math.imul(Y, Ne) | 0, _ = _ + Math.imul(Y, Ve) | 0, _ = _ + Math.imul(te, Ne) | 0, I = I + Math.imul(te, Ve) | 0;
      var $t = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, P = Math.imul(Te, Le), _ = Math.imul(Te, Ge), _ = _ + Math.imul(Ue, Le) | 0, I = Math.imul(Ue, Ge), P = P + Math.imul(Ae, je) | 0, _ = _ + Math.imul(Ae, Je) | 0, _ = _ + Math.imul(Be, je) | 0, I = I + Math.imul(Be, Je) | 0, P = P + Math.imul(be, ze) | 0, _ = _ + Math.imul(be, et) | 0, _ = _ + Math.imul(_e, ze) | 0, I = I + Math.imul(_e, et) | 0, P = P + Math.imul(qe, Ke) | 0, _ = _ + Math.imul(qe, Ye) | 0, _ = _ + Math.imul(He, Ke) | 0, I = I + Math.imul(He, Ye) | 0, P = P + Math.imul(ke, We) | 0, _ = _ + Math.imul(ke, Xe) | 0, _ = _ + Math.imul(Se, We) | 0, I = I + Math.imul(Se, Xe) | 0, P = P + Math.imul(Ie, se) | 0, _ = _ + Math.imul(Ie, J) | 0, _ = _ + Math.imul(De, se) | 0, I = I + Math.imul(De, J) | 0, P = P + Math.imul(he, le) | 0, _ = _ + Math.imul(he, we) | 0, _ = _ + Math.imul(Me, le) | 0, I = I + Math.imul(Me, we) | 0, P = P + Math.imul(ue, Ee) | 0, _ = _ + Math.imul(ue, Fe) | 0, _ = _ + Math.imul(ye, Ee) | 0, I = I + Math.imul(ye, Fe) | 0, P = P + Math.imul(re, Ne) | 0, _ = _ + Math.imul(re, Ve) | 0, _ = _ + Math.imul(ee, Ne) | 0, I = I + Math.imul(ee, Ve) | 0, P = P + Math.imul(Y, Ze) | 0, _ = _ + Math.imul(Y, tt) | 0, _ = _ + Math.imul(te, Ze) | 0, I = I + Math.imul(te, tt) | 0;
      var At = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, P = Math.imul(Te, je), _ = Math.imul(Te, Je), _ = _ + Math.imul(Ue, je) | 0, I = Math.imul(Ue, Je), P = P + Math.imul(Ae, ze) | 0, _ = _ + Math.imul(Ae, et) | 0, _ = _ + Math.imul(Be, ze) | 0, I = I + Math.imul(Be, et) | 0, P = P + Math.imul(be, Ke) | 0, _ = _ + Math.imul(be, Ye) | 0, _ = _ + Math.imul(_e, Ke) | 0, I = I + Math.imul(_e, Ye) | 0, P = P + Math.imul(qe, We) | 0, _ = _ + Math.imul(qe, Xe) | 0, _ = _ + Math.imul(He, We) | 0, I = I + Math.imul(He, Xe) | 0, P = P + Math.imul(ke, se) | 0, _ = _ + Math.imul(ke, J) | 0, _ = _ + Math.imul(Se, se) | 0, I = I + Math.imul(Se, J) | 0, P = P + Math.imul(Ie, le) | 0, _ = _ + Math.imul(Ie, we) | 0, _ = _ + Math.imul(De, le) | 0, I = I + Math.imul(De, we) | 0, P = P + Math.imul(he, Ee) | 0, _ = _ + Math.imul(he, Fe) | 0, _ = _ + Math.imul(Me, Ee) | 0, I = I + Math.imul(Me, Fe) | 0, P = P + Math.imul(ue, Ne) | 0, _ = _ + Math.imul(ue, Ve) | 0, _ = _ + Math.imul(ye, Ne) | 0, I = I + Math.imul(ye, Ve) | 0, P = P + Math.imul(re, Ze) | 0, _ = _ + Math.imul(re, tt) | 0, _ = _ + Math.imul(ee, Ze) | 0, I = I + Math.imul(ee, tt) | 0;
      var Rt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, P = Math.imul(Te, ze), _ = Math.imul(Te, et), _ = _ + Math.imul(Ue, ze) | 0, I = Math.imul(Ue, et), P = P + Math.imul(Ae, Ke) | 0, _ = _ + Math.imul(Ae, Ye) | 0, _ = _ + Math.imul(Be, Ke) | 0, I = I + Math.imul(Be, Ye) | 0, P = P + Math.imul(be, We) | 0, _ = _ + Math.imul(be, Xe) | 0, _ = _ + Math.imul(_e, We) | 0, I = I + Math.imul(_e, Xe) | 0, P = P + Math.imul(qe, se) | 0, _ = _ + Math.imul(qe, J) | 0, _ = _ + Math.imul(He, se) | 0, I = I + Math.imul(He, J) | 0, P = P + Math.imul(ke, le) | 0, _ = _ + Math.imul(ke, we) | 0, _ = _ + Math.imul(Se, le) | 0, I = I + Math.imul(Se, we) | 0, P = P + Math.imul(Ie, Ee) | 0, _ = _ + Math.imul(Ie, Fe) | 0, _ = _ + Math.imul(De, Ee) | 0, I = I + Math.imul(De, Fe) | 0, P = P + Math.imul(he, Ne) | 0, _ = _ + Math.imul(he, Ve) | 0, _ = _ + Math.imul(Me, Ne) | 0, I = I + Math.imul(Me, Ve) | 0, P = P + Math.imul(ue, Ze) | 0, _ = _ + Math.imul(ue, tt) | 0, _ = _ + Math.imul(ye, Ze) | 0, I = I + Math.imul(ye, tt) | 0;
      var Bt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, P = Math.imul(Te, Ke), _ = Math.imul(Te, Ye), _ = _ + Math.imul(Ue, Ke) | 0, I = Math.imul(Ue, Ye), P = P + Math.imul(Ae, We) | 0, _ = _ + Math.imul(Ae, Xe) | 0, _ = _ + Math.imul(Be, We) | 0, I = I + Math.imul(Be, Xe) | 0, P = P + Math.imul(be, se) | 0, _ = _ + Math.imul(be, J) | 0, _ = _ + Math.imul(_e, se) | 0, I = I + Math.imul(_e, J) | 0, P = P + Math.imul(qe, le) | 0, _ = _ + Math.imul(qe, we) | 0, _ = _ + Math.imul(He, le) | 0, I = I + Math.imul(He, we) | 0, P = P + Math.imul(ke, Ee) | 0, _ = _ + Math.imul(ke, Fe) | 0, _ = _ + Math.imul(Se, Ee) | 0, I = I + Math.imul(Se, Fe) | 0, P = P + Math.imul(Ie, Ne) | 0, _ = _ + Math.imul(Ie, Ve) | 0, _ = _ + Math.imul(De, Ne) | 0, I = I + Math.imul(De, Ve) | 0, P = P + Math.imul(he, Ze) | 0, _ = _ + Math.imul(he, tt) | 0, _ = _ + Math.imul(Me, Ze) | 0, I = I + Math.imul(Me, tt) | 0;
      var Tt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, P = Math.imul(Te, We), _ = Math.imul(Te, Xe), _ = _ + Math.imul(Ue, We) | 0, I = Math.imul(Ue, Xe), P = P + Math.imul(Ae, se) | 0, _ = _ + Math.imul(Ae, J) | 0, _ = _ + Math.imul(Be, se) | 0, I = I + Math.imul(Be, J) | 0, P = P + Math.imul(be, le) | 0, _ = _ + Math.imul(be, we) | 0, _ = _ + Math.imul(_e, le) | 0, I = I + Math.imul(_e, we) | 0, P = P + Math.imul(qe, Ee) | 0, _ = _ + Math.imul(qe, Fe) | 0, _ = _ + Math.imul(He, Ee) | 0, I = I + Math.imul(He, Fe) | 0, P = P + Math.imul(ke, Ne) | 0, _ = _ + Math.imul(ke, Ve) | 0, _ = _ + Math.imul(Se, Ne) | 0, I = I + Math.imul(Se, Ve) | 0, P = P + Math.imul(Ie, Ze) | 0, _ = _ + Math.imul(Ie, tt) | 0, _ = _ + Math.imul(De, Ze) | 0, I = I + Math.imul(De, tt) | 0;
      var Pt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, P = Math.imul(Te, se), _ = Math.imul(Te, J), _ = _ + Math.imul(Ue, se) | 0, I = Math.imul(Ue, J), P = P + Math.imul(Ae, le) | 0, _ = _ + Math.imul(Ae, we) | 0, _ = _ + Math.imul(Be, le) | 0, I = I + Math.imul(Be, we) | 0, P = P + Math.imul(be, Ee) | 0, _ = _ + Math.imul(be, Fe) | 0, _ = _ + Math.imul(_e, Ee) | 0, I = I + Math.imul(_e, Fe) | 0, P = P + Math.imul(qe, Ne) | 0, _ = _ + Math.imul(qe, Ve) | 0, _ = _ + Math.imul(He, Ne) | 0, I = I + Math.imul(He, Ve) | 0, P = P + Math.imul(ke, Ze) | 0, _ = _ + Math.imul(ke, tt) | 0, _ = _ + Math.imul(Se, Ze) | 0, I = I + Math.imul(Se, tt) | 0;
      var It = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, P = Math.imul(Te, le), _ = Math.imul(Te, we), _ = _ + Math.imul(Ue, le) | 0, I = Math.imul(Ue, we), P = P + Math.imul(Ae, Ee) | 0, _ = _ + Math.imul(Ae, Fe) | 0, _ = _ + Math.imul(Be, Ee) | 0, I = I + Math.imul(Be, Fe) | 0, P = P + Math.imul(be, Ne) | 0, _ = _ + Math.imul(be, Ve) | 0, _ = _ + Math.imul(_e, Ne) | 0, I = I + Math.imul(_e, Ve) | 0, P = P + Math.imul(qe, Ze) | 0, _ = _ + Math.imul(qe, tt) | 0, _ = _ + Math.imul(He, Ze) | 0, I = I + Math.imul(He, tt) | 0;
      var Ot = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, P = Math.imul(Te, Ee), _ = Math.imul(Te, Fe), _ = _ + Math.imul(Ue, Ee) | 0, I = Math.imul(Ue, Fe), P = P + Math.imul(Ae, Ne) | 0, _ = _ + Math.imul(Ae, Ve) | 0, _ = _ + Math.imul(Be, Ne) | 0, I = I + Math.imul(Be, Ve) | 0, P = P + Math.imul(be, Ze) | 0, _ = _ + Math.imul(be, tt) | 0, _ = _ + Math.imul(_e, Ze) | 0, I = I + Math.imul(_e, tt) | 0;
      var Ct = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, P = Math.imul(Te, Ne), _ = Math.imul(Te, Ve), _ = _ + Math.imul(Ue, Ne) | 0, I = Math.imul(Ue, Ve), P = P + Math.imul(Ae, Ze) | 0, _ = _ + Math.imul(Ae, tt) | 0, _ = _ + Math.imul(Be, Ze) | 0, I = I + Math.imul(Be, tt) | 0;
      var Dt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, P = Math.imul(Te, Ze), _ = Math.imul(Te, tt), _ = _ + Math.imul(Ue, Ze) | 0, I = Math.imul(Ue, tt);
      var kt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      return L = (I + (_ >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, C[0] = vt, C[1] = mt, C[2] = wt, C[3] = Mt, C[4] = _t, C[5] = xt, C[6] = Et, C[7] = St, C[8] = $t, C[9] = At, C[10] = Rt, C[11] = Bt, C[12] = Tt, C[13] = Pt, C[14] = It, C[15] = Ot, C[16] = Ct, C[17] = Dt, C[18] = kt, L !== 0 && (C[19] = L, A.length++), A;
    };
    Math.imul || (ce = fe);
    function me(N, y, E) {
      E.negative = y.negative ^ N.negative, E.length = N.length + y.length;
      for (var A = 0, B = 0, O = 0; O < E.length - 1; O++) {
        var C = B;
        B = 0;
        for (var L = A & 67108863, P = Math.min(O, y.length - 1), _ = Math.max(0, O - N.length + 1); _ <= P; _++) {
          var I = O - _, U = N.words[I] | 0, Y = y.words[_] | 0, te = U * Y, oe = te & 67108863;
          C = C + (te / 67108864 | 0) | 0, oe = oe + L | 0, L = oe & 67108863, C = C + (oe >>> 26) | 0, B += C >>> 26, C &= 67108863;
        }
        E.words[O] = L, A = C, C = B;
      }
      return A !== 0 ? E.words[O] = A : E.length--, E.strip();
    }
    function de(N, y, E) {
      var A = new ne();
      return A.mulp(N, y, E);
    }
    S.prototype.mulTo = function(y, E) {
      var A, B = this.length + y.length;
      return this.length === 10 && y.length === 10 ? A = ce(this, y, E) : B < 63 ? A = fe(this, y, E) : B < 1024 ? A = me(this, y, E) : A = de(this, y, E), A;
    };
    function ne(N, y) {
      this.x = N, this.y = y;
    }
    ne.prototype.makeRBT = function(y) {
      for (var E = new Array(y), A = S.prototype._countBits(y) - 1, B = 0; B < y; B++)
        E[B] = this.revBin(B, A, y);
      return E;
    }, ne.prototype.revBin = function(y, E, A) {
      if (y === 0 || y === A - 1) return y;
      for (var B = 0, O = 0; O < E; O++)
        B |= (y & 1) << E - O - 1, y >>= 1;
      return B;
    }, ne.prototype.permute = function(y, E, A, B, O, C) {
      for (var L = 0; L < C; L++)
        B[L] = E[y[L]], O[L] = A[y[L]];
    }, ne.prototype.transform = function(y, E, A, B, O, C) {
      this.permute(C, y, E, A, B, O);
      for (var L = 1; L < O; L <<= 1)
        for (var P = L << 1, _ = Math.cos(2 * Math.PI / P), I = Math.sin(2 * Math.PI / P), U = 0; U < O; U += P)
          for (var Y = _, te = I, oe = 0; oe < L; oe++) {
            var re = A[U + oe], ee = B[U + oe], ae = A[U + oe + L], ue = B[U + oe + L], ye = Y * ae - te * ue;
            ue = Y * ue + te * ae, ae = ye, A[U + oe] = re + ae, B[U + oe] = ee + ue, A[U + oe + L] = re - ae, B[U + oe + L] = ee - ue, oe !== P && (ye = _ * Y - I * te, te = _ * te + I * Y, Y = ye);
          }
    }, ne.prototype.guessLen13b = function(y, E) {
      var A = Math.max(E, y) | 1, B = A & 1, O = 0;
      for (A = A / 2 | 0; A; A = A >>> 1)
        O++;
      return 1 << O + 1 + B;
    }, ne.prototype.conjugate = function(y, E, A) {
      if (!(A <= 1))
        for (var B = 0; B < A / 2; B++) {
          var O = y[B];
          y[B] = y[A - B - 1], y[A - B - 1] = O, O = E[B], E[B] = -E[A - B - 1], E[A - B - 1] = -O;
        }
    }, ne.prototype.normalize13b = function(y, E) {
      for (var A = 0, B = 0; B < E / 2; B++) {
        var O = Math.round(y[2 * B + 1] / E) * 8192 + Math.round(y[2 * B] / E) + A;
        y[B] = O & 67108863, O < 67108864 ? A = 0 : A = O / 67108864 | 0;
      }
      return y;
    }, ne.prototype.convert13b = function(y, E, A, B) {
      for (var O = 0, C = 0; C < E; C++)
        O = O + (y[C] | 0), A[2 * C] = O & 8191, O = O >>> 13, A[2 * C + 1] = O & 8191, O = O >>> 13;
      for (C = 2 * E; C < B; ++C)
        A[C] = 0;
      $(O === 0), $((O & -8192) === 0);
    }, ne.prototype.stub = function(y) {
      for (var E = new Array(y), A = 0; A < y; A++)
        E[A] = 0;
      return E;
    }, ne.prototype.mulp = function(y, E, A) {
      var B = 2 * this.guessLen13b(y.length, E.length), O = this.makeRBT(B), C = this.stub(B), L = new Array(B), P = new Array(B), _ = new Array(B), I = new Array(B), U = new Array(B), Y = new Array(B), te = A.words;
      te.length = B, this.convert13b(y.words, y.length, L, B), this.convert13b(E.words, E.length, I, B), this.transform(L, C, P, _, B, O), this.transform(I, C, U, Y, B, O);
      for (var oe = 0; oe < B; oe++) {
        var re = P[oe] * U[oe] - _[oe] * Y[oe];
        _[oe] = P[oe] * Y[oe] + _[oe] * U[oe], P[oe] = re;
      }
      return this.conjugate(P, _, B), this.transform(P, _, te, C, B, O), this.conjugate(te, C, B), this.normalize13b(te, B), A.negative = y.negative ^ E.negative, A.length = y.length + E.length, A.strip();
    }, S.prototype.mul = function(y) {
      var E = new S(null);
      return E.words = new Array(this.length + y.length), this.mulTo(y, E);
    }, S.prototype.mulf = function(y) {
      var E = new S(null);
      return E.words = new Array(this.length + y.length), de(this, y, E);
    }, S.prototype.imul = function(y) {
      return this.clone().mulTo(y, this);
    }, S.prototype.imuln = function(y) {
      $(typeof y == "number"), $(y < 67108864);
      for (var E = 0, A = 0; A < this.length; A++) {
        var B = (this.words[A] | 0) * y, O = (B & 67108863) + (E & 67108863);
        E >>= 26, E += B / 67108864 | 0, E += O >>> 26, this.words[A] = O & 67108863;
      }
      return E !== 0 && (this.words[A] = E, this.length++), this.length = y === 0 ? 1 : this.length, this;
    }, S.prototype.muln = function(y) {
      return this.clone().imuln(y);
    }, S.prototype.sqr = function() {
      return this.mul(this);
    }, S.prototype.isqr = function() {
      return this.imul(this.clone());
    }, S.prototype.pow = function(y) {
      var E = Q(y);
      if (E.length === 0) return new S(1);
      for (var A = this, B = 0; B < E.length && E[B] === 0; B++, A = A.sqr())
        ;
      if (++B < E.length)
        for (var O = A.sqr(); B < E.length; B++, O = O.sqr())
          E[B] !== 0 && (A = A.mul(O));
      return A;
    }, S.prototype.iushln = function(y) {
      $(typeof y == "number" && y >= 0);
      var E = y % 26, A = (y - E) / 26, B = 67108863 >>> 26 - E << 26 - E, O;
      if (E !== 0) {
        var C = 0;
        for (O = 0; O < this.length; O++) {
          var L = this.words[O] & B, P = (this.words[O] | 0) - L << E;
          this.words[O] = P | C, C = L >>> 26 - E;
        }
        C && (this.words[O] = C, this.length++);
      }
      if (A !== 0) {
        for (O = this.length - 1; O >= 0; O--)
          this.words[O + A] = this.words[O];
        for (O = 0; O < A; O++)
          this.words[O] = 0;
        this.length += A;
      }
      return this.strip();
    }, S.prototype.ishln = function(y) {
      return $(this.negative === 0), this.iushln(y);
    }, S.prototype.iushrn = function(y, E, A) {
      $(typeof y == "number" && y >= 0);
      var B;
      E ? B = (E - E % 26) / 26 : B = 0;
      var O = y % 26, C = Math.min((y - O) / 26, this.length), L = 67108863 ^ 67108863 >>> O << O, P = A;
      if (B -= C, B = Math.max(0, B), P) {
        for (var _ = 0; _ < C; _++)
          P.words[_] = this.words[_];
        P.length = C;
      }
      if (C !== 0) if (this.length > C)
        for (this.length -= C, _ = 0; _ < this.length; _++)
          this.words[_] = this.words[_ + C];
      else
        this.words[0] = 0, this.length = 1;
      var I = 0;
      for (_ = this.length - 1; _ >= 0 && (I !== 0 || _ >= B); _--) {
        var U = this.words[_] | 0;
        this.words[_] = I << 26 - O | U >>> O, I = U & L;
      }
      return P && I !== 0 && (P.words[P.length++] = I), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, S.prototype.ishrn = function(y, E, A) {
      return $(this.negative === 0), this.iushrn(y, E, A);
    }, S.prototype.shln = function(y) {
      return this.clone().ishln(y);
    }, S.prototype.ushln = function(y) {
      return this.clone().iushln(y);
    }, S.prototype.shrn = function(y) {
      return this.clone().ishrn(y);
    }, S.prototype.ushrn = function(y) {
      return this.clone().iushrn(y);
    }, S.prototype.testn = function(y) {
      $(typeof y == "number" && y >= 0);
      var E = y % 26, A = (y - E) / 26, B = 1 << E;
      if (this.length <= A) return !1;
      var O = this.words[A];
      return !!(O & B);
    }, S.prototype.imaskn = function(y) {
      $(typeof y == "number" && y >= 0);
      var E = y % 26, A = (y - E) / 26;
      if ($(this.negative === 0, "imaskn works only with positive numbers"), this.length <= A)
        return this;
      if (E !== 0 && A++, this.length = Math.min(A, this.length), E !== 0) {
        var B = 67108863 ^ 67108863 >>> E << E;
        this.words[this.length - 1] &= B;
      }
      return this.strip();
    }, S.prototype.maskn = function(y) {
      return this.clone().imaskn(y);
    }, S.prototype.iaddn = function(y) {
      return $(typeof y == "number"), $(y < 67108864), y < 0 ? this.isubn(-y) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < y ? (this.words[0] = y - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(y), this.negative = 1, this) : this._iaddn(y);
    }, S.prototype._iaddn = function(y) {
      this.words[0] += y;
      for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
        this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
      return this.length = Math.max(this.length, E + 1), this;
    }, S.prototype.isubn = function(y) {
      if ($(typeof y == "number"), $(y < 67108864), y < 0) return this.iaddn(-y);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(y), this.negative = 1, this;
      if (this.words[0] -= y, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var E = 0; E < this.length && this.words[E] < 0; E++)
          this.words[E] += 67108864, this.words[E + 1] -= 1;
      return this.strip();
    }, S.prototype.addn = function(y) {
      return this.clone().iaddn(y);
    }, S.prototype.subn = function(y) {
      return this.clone().isubn(y);
    }, S.prototype.iabs = function() {
      return this.negative = 0, this;
    }, S.prototype.abs = function() {
      return this.clone().iabs();
    }, S.prototype._ishlnsubmul = function(y, E, A) {
      var B = y.length + A, O;
      this._expand(B);
      var C, L = 0;
      for (O = 0; O < y.length; O++) {
        C = (this.words[O + A] | 0) + L;
        var P = (y.words[O] | 0) * E;
        C -= P & 67108863, L = (C >> 26) - (P / 67108864 | 0), this.words[O + A] = C & 67108863;
      }
      for (; O < this.length - A; O++)
        C = (this.words[O + A] | 0) + L, L = C >> 26, this.words[O + A] = C & 67108863;
      if (L === 0) return this.strip();
      for ($(L === -1), L = 0, O = 0; O < this.length; O++)
        C = -(this.words[O] | 0) + L, L = C >> 26, this.words[O] = C & 67108863;
      return this.negative = 1, this.strip();
    }, S.prototype._wordDiv = function(y, E) {
      var A = this.length - y.length, B = this.clone(), O = y, C = O.words[O.length - 1] | 0, L = this._countBits(C);
      A = 26 - L, A !== 0 && (O = O.ushln(A), B.iushln(A), C = O.words[O.length - 1] | 0);
      var P = B.length - O.length, _;
      if (E !== "mod") {
        _ = new S(null), _.length = P + 1, _.words = new Array(_.length);
        for (var I = 0; I < _.length; I++)
          _.words[I] = 0;
      }
      var U = B.clone()._ishlnsubmul(O, 1, P);
      U.negative === 0 && (B = U, _ && (_.words[P] = 1));
      for (var Y = P - 1; Y >= 0; Y--) {
        var te = (B.words[O.length + Y] | 0) * 67108864 + (B.words[O.length + Y - 1] | 0);
        for (te = Math.min(te / C | 0, 67108863), B._ishlnsubmul(O, te, Y); B.negative !== 0; )
          te--, B.negative = 0, B._ishlnsubmul(O, 1, Y), B.isZero() || (B.negative ^= 1);
        _ && (_.words[Y] = te);
      }
      return _ && _.strip(), B.strip(), E !== "div" && A !== 0 && B.iushrn(A), {
        div: _ || null,
        mod: B
      };
    }, S.prototype.divmod = function(y, E, A) {
      if ($(!y.isZero()), this.isZero())
        return {
          div: new S(0),
          mod: new S(0)
        };
      var B, O, C;
      return this.negative !== 0 && y.negative === 0 ? (C = this.neg().divmod(y, E), E !== "mod" && (B = C.div.neg()), E !== "div" && (O = C.mod.neg(), A && O.negative !== 0 && O.iadd(y)), {
        div: B,
        mod: O
      }) : this.negative === 0 && y.negative !== 0 ? (C = this.divmod(y.neg(), E), E !== "mod" && (B = C.div.neg()), {
        div: B,
        mod: C.mod
      }) : this.negative & y.negative ? (C = this.neg().divmod(y.neg(), E), E !== "div" && (O = C.mod.neg(), A && O.negative !== 0 && O.isub(y)), {
        div: C.div,
        mod: O
      }) : y.length > this.length || this.cmp(y) < 0 ? {
        div: new S(0),
        mod: this
      } : y.length === 1 ? E === "div" ? {
        div: this.divn(y.words[0]),
        mod: null
      } : E === "mod" ? {
        div: null,
        mod: new S(this.modn(y.words[0]))
      } : {
        div: this.divn(y.words[0]),
        mod: new S(this.modn(y.words[0]))
      } : this._wordDiv(y, E);
    }, S.prototype.div = function(y) {
      return this.divmod(y, "div", !1).div;
    }, S.prototype.mod = function(y) {
      return this.divmod(y, "mod", !1).mod;
    }, S.prototype.umod = function(y) {
      return this.divmod(y, "mod", !0).mod;
    }, S.prototype.divRound = function(y) {
      var E = this.divmod(y);
      if (E.mod.isZero()) return E.div;
      var A = E.div.negative !== 0 ? E.mod.isub(y) : E.mod, B = y.ushrn(1), O = y.andln(1), C = A.cmp(B);
      return C < 0 || O === 1 && C === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
    }, S.prototype.modn = function(y) {
      $(y <= 67108863);
      for (var E = (1 << 26) % y, A = 0, B = this.length - 1; B >= 0; B--)
        A = (E * A + (this.words[B] | 0)) % y;
      return A;
    }, S.prototype.idivn = function(y) {
      $(y <= 67108863);
      for (var E = 0, A = this.length - 1; A >= 0; A--) {
        var B = (this.words[A] | 0) + E * 67108864;
        this.words[A] = B / y | 0, E = B % y;
      }
      return this.strip();
    }, S.prototype.divn = function(y) {
      return this.clone().idivn(y);
    }, S.prototype.egcd = function(y) {
      $(y.negative === 0), $(!y.isZero());
      var E = this, A = y.clone();
      E.negative !== 0 ? E = E.umod(y) : E = E.clone();
      for (var B = new S(1), O = new S(0), C = new S(0), L = new S(1), P = 0; E.isEven() && A.isEven(); )
        E.iushrn(1), A.iushrn(1), ++P;
      for (var _ = A.clone(), I = E.clone(); !E.isZero(); ) {
        for (var U = 0, Y = 1; !(E.words[0] & Y) && U < 26; ++U, Y <<= 1) ;
        if (U > 0)
          for (E.iushrn(U); U-- > 0; )
            (B.isOdd() || O.isOdd()) && (B.iadd(_), O.isub(I)), B.iushrn(1), O.iushrn(1);
        for (var te = 0, oe = 1; !(A.words[0] & oe) && te < 26; ++te, oe <<= 1) ;
        if (te > 0)
          for (A.iushrn(te); te-- > 0; )
            (C.isOdd() || L.isOdd()) && (C.iadd(_), L.isub(I)), C.iushrn(1), L.iushrn(1);
        E.cmp(A) >= 0 ? (E.isub(A), B.isub(C), O.isub(L)) : (A.isub(E), C.isub(B), L.isub(O));
      }
      return {
        a: C,
        b: L,
        gcd: A.iushln(P)
      };
    }, S.prototype._invmp = function(y) {
      $(y.negative === 0), $(!y.isZero());
      var E = this, A = y.clone();
      E.negative !== 0 ? E = E.umod(y) : E = E.clone();
      for (var B = new S(1), O = new S(0), C = A.clone(); E.cmpn(1) > 0 && A.cmpn(1) > 0; ) {
        for (var L = 0, P = 1; !(E.words[0] & P) && L < 26; ++L, P <<= 1) ;
        if (L > 0)
          for (E.iushrn(L); L-- > 0; )
            B.isOdd() && B.iadd(C), B.iushrn(1);
        for (var _ = 0, I = 1; !(A.words[0] & I) && _ < 26; ++_, I <<= 1) ;
        if (_ > 0)
          for (A.iushrn(_); _-- > 0; )
            O.isOdd() && O.iadd(C), O.iushrn(1);
        E.cmp(A) >= 0 ? (E.isub(A), B.isub(O)) : (A.isub(E), O.isub(B));
      }
      var U;
      return E.cmpn(1) === 0 ? U = B : U = O, U.cmpn(0) < 0 && U.iadd(y), U;
    }, S.prototype.gcd = function(y) {
      if (this.isZero()) return y.abs();
      if (y.isZero()) return this.abs();
      var E = this.clone(), A = y.clone();
      E.negative = 0, A.negative = 0;
      for (var B = 0; E.isEven() && A.isEven(); B++)
        E.iushrn(1), A.iushrn(1);
      do {
        for (; E.isEven(); )
          E.iushrn(1);
        for (; A.isEven(); )
          A.iushrn(1);
        var O = E.cmp(A);
        if (O < 0) {
          var C = E;
          E = A, A = C;
        } else if (O === 0 || A.cmpn(1) === 0)
          break;
        E.isub(A);
      } while (!0);
      return A.iushln(B);
    }, S.prototype.invm = function(y) {
      return this.egcd(y).a.umod(y);
    }, S.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, S.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, S.prototype.andln = function(y) {
      return this.words[0] & y;
    }, S.prototype.bincn = function(y) {
      $(typeof y == "number");
      var E = y % 26, A = (y - E) / 26, B = 1 << E;
      if (this.length <= A)
        return this._expand(A + 1), this.words[A] |= B, this;
      for (var O = B, C = A; O !== 0 && C < this.length; C++) {
        var L = this.words[C] | 0;
        L += O, O = L >>> 26, L &= 67108863, this.words[C] = L;
      }
      return O !== 0 && (this.words[C] = O, this.length++), this;
    }, S.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, S.prototype.cmpn = function(y) {
      var E = y < 0;
      if (this.negative !== 0 && !E) return -1;
      if (this.negative === 0 && E) return 1;
      this.strip();
      var A;
      if (this.length > 1)
        A = 1;
      else {
        E && (y = -y), $(y <= 67108863, "Number is too big");
        var B = this.words[0] | 0;
        A = B === y ? 0 : B < y ? -1 : 1;
      }
      return this.negative !== 0 ? -A | 0 : A;
    }, S.prototype.cmp = function(y) {
      if (this.negative !== 0 && y.negative === 0) return -1;
      if (this.negative === 0 && y.negative !== 0) return 1;
      var E = this.ucmp(y);
      return this.negative !== 0 ? -E | 0 : E;
    }, S.prototype.ucmp = function(y) {
      if (this.length > y.length) return 1;
      if (this.length < y.length) return -1;
      for (var E = 0, A = this.length - 1; A >= 0; A--) {
        var B = this.words[A] | 0, O = y.words[A] | 0;
        if (B !== O) {
          B < O ? E = -1 : B > O && (E = 1);
          break;
        }
      }
      return E;
    }, S.prototype.gtn = function(y) {
      return this.cmpn(y) === 1;
    }, S.prototype.gt = function(y) {
      return this.cmp(y) === 1;
    }, S.prototype.gten = function(y) {
      return this.cmpn(y) >= 0;
    }, S.prototype.gte = function(y) {
      return this.cmp(y) >= 0;
    }, S.prototype.ltn = function(y) {
      return this.cmpn(y) === -1;
    }, S.prototype.lt = function(y) {
      return this.cmp(y) === -1;
    }, S.prototype.lten = function(y) {
      return this.cmpn(y) <= 0;
    }, S.prototype.lte = function(y) {
      return this.cmp(y) <= 0;
    }, S.prototype.eqn = function(y) {
      return this.cmpn(y) === 0;
    }, S.prototype.eq = function(y) {
      return this.cmp(y) === 0;
    }, S.red = function(y) {
      return new xe(y);
    }, S.prototype.toRed = function(y) {
      return $(!this.red, "Already a number in reduction context"), $(this.negative === 0, "red works only with positives"), y.convertTo(this)._forceRed(y);
    }, S.prototype.fromRed = function() {
      return $(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, S.prototype._forceRed = function(y) {
      return this.red = y, this;
    }, S.prototype.forceRed = function(y) {
      return $(!this.red, "Already a number in reduction context"), this._forceRed(y);
    }, S.prototype.redAdd = function(y) {
      return $(this.red, "redAdd works only with red numbers"), this.red.add(this, y);
    }, S.prototype.redIAdd = function(y) {
      return $(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, y);
    }, S.prototype.redSub = function(y) {
      return $(this.red, "redSub works only with red numbers"), this.red.sub(this, y);
    }, S.prototype.redISub = function(y) {
      return $(this.red, "redISub works only with red numbers"), this.red.isub(this, y);
    }, S.prototype.redShl = function(y) {
      return $(this.red, "redShl works only with red numbers"), this.red.shl(this, y);
    }, S.prototype.redMul = function(y) {
      return $(this.red, "redMul works only with red numbers"), this.red._verify2(this, y), this.red.mul(this, y);
    }, S.prototype.redIMul = function(y) {
      return $(this.red, "redMul works only with red numbers"), this.red._verify2(this, y), this.red.imul(this, y);
    }, S.prototype.redSqr = function() {
      return $(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, S.prototype.redISqr = function() {
      return $(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, S.prototype.redSqrt = function() {
      return $(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, S.prototype.redInvm = function() {
      return $(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, S.prototype.redNeg = function() {
      return $(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, S.prototype.redPow = function(y) {
      return $(this.red && !y.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, y);
    };
    var ge = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function pe(N, y) {
      this.name = N, this.p = new S(y, 16), this.n = this.p.bitLength(), this.k = new S(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    pe.prototype._tmp = function() {
      var y = new S(null);
      return y.words = new Array(Math.ceil(this.n / 13)), y;
    }, pe.prototype.ireduce = function(y) {
      var E = y, A;
      do
        this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), A = E.bitLength();
      while (A > this.n);
      var B = A < this.n ? -1 : E.ucmp(this.p);
      return B === 0 ? (E.words[0] = 0, E.length = 1) : B > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
    }, pe.prototype.split = function(y, E) {
      y.iushrn(this.n, 0, E);
    }, pe.prototype.imulK = function(y) {
      return y.imul(this.k);
    };
    function $e() {
      pe.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    T($e, pe), $e.prototype.split = function(y, E) {
      for (var A = 4194303, B = Math.min(y.length, 9), O = 0; O < B; O++)
        E.words[O] = y.words[O];
      if (E.length = B, y.length <= 9) {
        y.words[0] = 0, y.length = 1;
        return;
      }
      var C = y.words[9];
      for (E.words[E.length++] = C & A, O = 10; O < y.length; O++) {
        var L = y.words[O] | 0;
        y.words[O - 10] = (L & A) << 4 | C >>> 22, C = L;
      }
      C >>>= 22, y.words[O - 10] = C, C === 0 && y.length > 10 ? y.length -= 10 : y.length -= 9;
    }, $e.prototype.imulK = function(y) {
      y.words[y.length] = 0, y.words[y.length + 1] = 0, y.length += 2;
      for (var E = 0, A = 0; A < y.length; A++) {
        var B = y.words[A] | 0;
        E += B * 977, y.words[A] = E & 67108863, E = B * 64 + (E / 67108864 | 0);
      }
      return y.words[y.length - 1] === 0 && (y.length--, y.words[y.length - 1] === 0 && y.length--), y;
    };
    function Re() {
      pe.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    T(Re, pe);
    function Pe() {
      pe.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    T(Pe, pe);
    function Oe() {
      pe.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    T(Oe, pe), Oe.prototype.imulK = function(y) {
      for (var E = 0, A = 0; A < y.length; A++) {
        var B = (y.words[A] | 0) * 19 + E, O = B & 67108863;
        B >>>= 26, y.words[A] = O, E = B;
      }
      return E !== 0 && (y.words[y.length++] = E), y;
    }, S._prime = function(y) {
      if (ge[y]) return ge[y];
      var E;
      if (y === "k256")
        E = new $e();
      else if (y === "p224")
        E = new Re();
      else if (y === "p192")
        E = new Pe();
      else if (y === "p25519")
        E = new Oe();
      else
        throw new Error("Unknown prime " + y);
      return ge[y] = E, E;
    };
    function xe(N) {
      if (typeof N == "string") {
        var y = S._prime(N);
        this.m = y.p, this.prime = y;
      } else
        $(N.gtn(1), "modulus must be greater than 1"), this.m = N, this.prime = null;
    }
    xe.prototype._verify1 = function(y) {
      $(y.negative === 0, "red works only with positives"), $(y.red, "red works only with red numbers");
    }, xe.prototype._verify2 = function(y, E) {
      $((y.negative | E.negative) === 0, "red works only with positives"), $(
        y.red && y.red === E.red,
        "red works only with red numbers"
      );
    }, xe.prototype.imod = function(y) {
      return this.prime ? this.prime.ireduce(y)._forceRed(this) : y.umod(this.m)._forceRed(this);
    }, xe.prototype.neg = function(y) {
      return y.isZero() ? y.clone() : this.m.sub(y)._forceRed(this);
    }, xe.prototype.add = function(y, E) {
      this._verify2(y, E);
      var A = y.add(E);
      return A.cmp(this.m) >= 0 && A.isub(this.m), A._forceRed(this);
    }, xe.prototype.iadd = function(y, E) {
      this._verify2(y, E);
      var A = y.iadd(E);
      return A.cmp(this.m) >= 0 && A.isub(this.m), A;
    }, xe.prototype.sub = function(y, E) {
      this._verify2(y, E);
      var A = y.sub(E);
      return A.cmpn(0) < 0 && A.iadd(this.m), A._forceRed(this);
    }, xe.prototype.isub = function(y, E) {
      this._verify2(y, E);
      var A = y.isub(E);
      return A.cmpn(0) < 0 && A.iadd(this.m), A;
    }, xe.prototype.shl = function(y, E) {
      return this._verify1(y), this.imod(y.ushln(E));
    }, xe.prototype.imul = function(y, E) {
      return this._verify2(y, E), this.imod(y.imul(E));
    }, xe.prototype.mul = function(y, E) {
      return this._verify2(y, E), this.imod(y.mul(E));
    }, xe.prototype.isqr = function(y) {
      return this.imul(y, y.clone());
    }, xe.prototype.sqr = function(y) {
      return this.mul(y, y);
    }, xe.prototype.sqrt = function(y) {
      if (y.isZero()) return y.clone();
      var E = this.m.andln(3);
      if ($(E % 2 === 1), E === 3) {
        var A = this.m.add(new S(1)).iushrn(2);
        return this.pow(y, A);
      }
      for (var B = this.m.subn(1), O = 0; !B.isZero() && B.andln(1) === 0; )
        O++, B.iushrn(1);
      $(!B.isZero());
      var C = new S(1).toRed(this), L = C.redNeg(), P = this.m.subn(1).iushrn(1), _ = this.m.bitLength();
      for (_ = new S(2 * _ * _).toRed(this); this.pow(_, P).cmp(L) !== 0; )
        _.redIAdd(L);
      for (var I = this.pow(_, B), U = this.pow(y, B.addn(1).iushrn(1)), Y = this.pow(y, B), te = O; Y.cmp(C) !== 0; ) {
        for (var oe = Y, re = 0; oe.cmp(C) !== 0; re++)
          oe = oe.redSqr();
        $(re < te);
        var ee = this.pow(I, new S(1).iushln(te - re - 1));
        U = U.redMul(ee), I = ee.redSqr(), Y = Y.redMul(I), te = re;
      }
      return U;
    }, xe.prototype.invm = function(y) {
      var E = y._invmp(this.m);
      return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
    }, xe.prototype.pow = function(y, E) {
      if (E.isZero()) return new S(1).toRed(this);
      if (E.cmpn(1) === 0) return y.clone();
      var A = 4, B = new Array(1 << A);
      B[0] = new S(1).toRed(this), B[1] = y;
      for (var O = 2; O < B.length; O++)
        B[O] = this.mul(B[O - 1], y);
      var C = B[0], L = 0, P = 0, _ = E.bitLength() % 26;
      for (_ === 0 && (_ = 26), O = E.length - 1; O >= 0; O--) {
        for (var I = E.words[O], U = _ - 1; U >= 0; U--) {
          var Y = I >> U & 1;
          if (C !== B[0] && (C = this.sqr(C)), Y === 0 && L === 0) {
            P = 0;
            continue;
          }
          L <<= 1, L |= Y, P++, !(P !== A && (O !== 0 || U !== 0)) && (C = this.mul(C, B[L]), P = 0, L = 0);
        }
        _ = 26;
      }
      return C;
    }, xe.prototype.convertTo = function(y) {
      var E = y.umod(this.m);
      return E === y ? E.clone() : E;
    }, xe.prototype.convertFrom = function(y) {
      var E = y.clone();
      return E.red = null, E;
    }, S.mont = function(y) {
      return new rt(y);
    };
    function rt(N) {
      xe.call(this, N), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new S(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    T(rt, xe), rt.prototype.convertTo = function(y) {
      return this.imod(y.ushln(this.shift));
    }, rt.prototype.convertFrom = function(y) {
      var E = this.imod(y.mul(this.rinv));
      return E.red = null, E;
    }, rt.prototype.imul = function(y, E) {
      if (y.isZero() || E.isZero())
        return y.words[0] = 0, y.length = 1, y;
      var A = y.imul(E), B = A.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), O = A.isub(B).iushrn(this.shift), C = O;
      return O.cmp(this.m) >= 0 ? C = O.isub(this.m) : O.cmpn(0) < 0 && (C = O.iadd(this.m)), C._forceRed(this);
    }, rt.prototype.mul = function(y, E) {
      if (y.isZero() || E.isZero()) return new S(0)._forceRed(this);
      var A = y.mul(E), B = A.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), O = A.isub(B).iushrn(this.shift), C = O;
      return O.cmp(this.m) >= 0 ? C = O.isub(this.m) : O.cmpn(0) < 0 && (C = O.iadd(this.m)), C._forceRed(this);
    }, rt.prototype.invm = function(y) {
      var E = this.imod(y._invmp(this.m).mul(this.r2));
      return E._forceRed(this);
    };
  })(w, commonjsGlobal);
})(bn$3);
var bnExports$3 = bn$3.exports, utils$k = {};
(function(w) {
  var M = w;
  function x(S, D) {
    if (Array.isArray(S))
      return S.slice();
    if (!S)
      return [];
    var F = [];
    if (typeof S != "string") {
      for (var z = 0; z < S.length; z++)
        F[z] = S[z] | 0;
      return F;
    }
    if (D === "hex") {
      S = S.replace(/[^a-z0-9]+/ig, ""), S.length % 2 !== 0 && (S = "0" + S);
      for (var z = 0; z < S.length; z += 2)
        F.push(parseInt(S[z] + S[z + 1], 16));
    } else
      for (var z = 0; z < S.length; z++) {
        var Z = S.charCodeAt(z), H = Z >> 8, V = Z & 255;
        H ? F.push(H, V) : F.push(V);
      }
    return F;
  }
  M.toArray = x;
  function $(S) {
    return S.length === 1 ? "0" + S : S;
  }
  M.zero2 = $;
  function T(S) {
    for (var D = "", F = 0; F < S.length; F++)
      D += $(S[F].toString(16));
    return D;
  }
  M.toHex = T, M.encode = function(D, F) {
    return F === "hex" ? T(D) : D;
  };
})(utils$k);
(function(w) {
  var M = w, x = bnExports$3, $ = minimalisticAssert, T = utils$k;
  M.assert = $, M.toArray = T.toArray, M.zero2 = T.zero2, M.toHex = T.toHex, M.encode = T.encode;
  function S(H, V, X) {
    var Q = new Array(Math.max(H.bitLength(), X) + 1), fe;
    for (fe = 0; fe < Q.length; fe += 1)
      Q[fe] = 0;
    var ce = 1 << V + 1, me = H.clone();
    for (fe = 0; fe < Q.length; fe++) {
      var de, ne = me.andln(ce - 1);
      me.isOdd() ? (ne > (ce >> 1) - 1 ? de = (ce >> 1) - ne : de = ne, me.isubn(de)) : de = 0, Q[fe] = de, me.iushrn(1);
    }
    return Q;
  }
  M.getNAF = S;
  function D(H, V) {
    var X = [
      [],
      []
    ];
    H = H.clone(), V = V.clone();
    for (var Q = 0, fe = 0, ce; H.cmpn(-Q) > 0 || V.cmpn(-fe) > 0; ) {
      var me = H.andln(3) + Q & 3, de = V.andln(3) + fe & 3;
      me === 3 && (me = -1), de === 3 && (de = -1);
      var ne;
      me & 1 ? (ce = H.andln(7) + Q & 7, (ce === 3 || ce === 5) && de === 2 ? ne = -me : ne = me) : ne = 0, X[0].push(ne);
      var ge;
      de & 1 ? (ce = V.andln(7) + fe & 7, (ce === 3 || ce === 5) && me === 2 ? ge = -de : ge = de) : ge = 0, X[1].push(ge), 2 * Q === ne + 1 && (Q = 1 - Q), 2 * fe === ge + 1 && (fe = 1 - fe), H.iushrn(1), V.iushrn(1);
    }
    return X;
  }
  M.getJSF = D;
  function F(H, V, X) {
    var Q = "_" + V;
    H.prototype[V] = function() {
      return this[Q] !== void 0 ? this[Q] : this[Q] = X.call(this);
    };
  }
  M.cachedProperty = F;
  function z(H) {
    return typeof H == "string" ? M.toArray(H, "hex") : H;
  }
  M.parseBytes = z;
  function Z(H) {
    return new x(H, "hex", "le");
  }
  M.intFromLE = Z;
})(utils$l);
var curve = {}, BN$9 = bnExports$3, utils$j = utils$l, getNAF = utils$j.getNAF, getJSF = utils$j.getJSF, assert$d = utils$j.assert;
function BaseCurve(w, M) {
  this.type = w, this.p = new BN$9(M.p, 16), this.red = M.prime ? BN$9.red(M.prime) : BN$9.mont(this.p), this.zero = new BN$9(0).toRed(this.red), this.one = new BN$9(1).toRed(this.red), this.two = new BN$9(2).toRed(this.red), this.n = M.n && new BN$9(M.n, 16), this.g = M.g && this.pointFromJSON(M.g, M.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var x = this.n && this.p.div(this.n);
  !x || x.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var base$1 = BaseCurve;
BaseCurve.prototype.point = function() {
  throw new Error("Not implemented");
};
BaseCurve.prototype.validate = function() {
  throw new Error("Not implemented");
};
BaseCurve.prototype._fixedNafMul = function(M, x) {
  assert$d(M.precomputed);
  var $ = M._getDoubles(), T = getNAF(x, 1, this._bitLength), S = (1 << $.step + 1) - ($.step % 2 === 0 ? 2 : 1);
  S /= 3;
  var D = [], F, z;
  for (F = 0; F < T.length; F += $.step) {
    z = 0;
    for (var Z = F + $.step - 1; Z >= F; Z--)
      z = (z << 1) + T[Z];
    D.push(z);
  }
  for (var H = this.jpoint(null, null, null), V = this.jpoint(null, null, null), X = S; X > 0; X--) {
    for (F = 0; F < D.length; F++)
      z = D[F], z === X ? V = V.mixedAdd($.points[F]) : z === -X && (V = V.mixedAdd($.points[F].neg()));
    H = H.add(V);
  }
  return H.toP();
};
BaseCurve.prototype._wnafMul = function(M, x) {
  var $ = 4, T = M._getNAFPoints($);
  $ = T.wnd;
  for (var S = T.points, D = getNAF(x, $, this._bitLength), F = this.jpoint(null, null, null), z = D.length - 1; z >= 0; z--) {
    for (var Z = 0; z >= 0 && D[z] === 0; z--)
      Z++;
    if (z >= 0 && Z++, F = F.dblp(Z), z < 0)
      break;
    var H = D[z];
    assert$d(H !== 0), M.type === "affine" ? H > 0 ? F = F.mixedAdd(S[H - 1 >> 1]) : F = F.mixedAdd(S[-H - 1 >> 1].neg()) : H > 0 ? F = F.add(S[H - 1 >> 1]) : F = F.add(S[-H - 1 >> 1].neg());
  }
  return M.type === "affine" ? F.toP() : F;
};
BaseCurve.prototype._wnafMulAdd = function(M, x, $, T, S) {
  var D = this._wnafT1, F = this._wnafT2, z = this._wnafT3, Z = 0, H, V, X;
  for (H = 0; H < T; H++) {
    X = x[H];
    var Q = X._getNAFPoints(M);
    D[H] = Q.wnd, F[H] = Q.points;
  }
  for (H = T - 1; H >= 1; H -= 2) {
    var fe = H - 1, ce = H;
    if (D[fe] !== 1 || D[ce] !== 1) {
      z[fe] = getNAF($[fe], D[fe], this._bitLength), z[ce] = getNAF($[ce], D[ce], this._bitLength), Z = Math.max(z[fe].length, Z), Z = Math.max(z[ce].length, Z);
      continue;
    }
    var me = [
      x[fe],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      x[ce]
      /* 7 */
    ];
    x[fe].y.cmp(x[ce].y) === 0 ? (me[1] = x[fe].add(x[ce]), me[2] = x[fe].toJ().mixedAdd(x[ce].neg())) : x[fe].y.cmp(x[ce].y.redNeg()) === 0 ? (me[1] = x[fe].toJ().mixedAdd(x[ce]), me[2] = x[fe].add(x[ce].neg())) : (me[1] = x[fe].toJ().mixedAdd(x[ce]), me[2] = x[fe].toJ().mixedAdd(x[ce].neg()));
    var de = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], ne = getJSF($[fe], $[ce]);
    for (Z = Math.max(ne[0].length, Z), z[fe] = new Array(Z), z[ce] = new Array(Z), V = 0; V < Z; V++) {
      var ge = ne[0][V] | 0, pe = ne[1][V] | 0;
      z[fe][V] = de[(ge + 1) * 3 + (pe + 1)], z[ce][V] = 0, F[fe] = me;
    }
  }
  var $e = this.jpoint(null, null, null), Re = this._wnafT4;
  for (H = Z; H >= 0; H--) {
    for (var Pe = 0; H >= 0; ) {
      var Oe = !0;
      for (V = 0; V < T; V++)
        Re[V] = z[V][H] | 0, Re[V] !== 0 && (Oe = !1);
      if (!Oe)
        break;
      Pe++, H--;
    }
    if (H >= 0 && Pe++, $e = $e.dblp(Pe), H < 0)
      break;
    for (V = 0; V < T; V++) {
      var xe = Re[V];
      xe !== 0 && (xe > 0 ? X = F[V][xe - 1 >> 1] : xe < 0 && (X = F[V][-xe - 1 >> 1].neg()), X.type === "affine" ? $e = $e.mixedAdd(X) : $e = $e.add(X));
    }
  }
  for (H = 0; H < T; H++)
    F[H] = null;
  return S ? $e : $e.toP();
};
function BasePoint(w, M) {
  this.curve = w, this.type = M, this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;
BasePoint.prototype.eq = function() {
  throw new Error("Not implemented");
};
BasePoint.prototype.validate = function() {
  return this.curve.validate(this);
};
BaseCurve.prototype.decodePoint = function(M, x) {
  M = utils$j.toArray(M, x);
  var $ = this.p.byteLength();
  if ((M[0] === 4 || M[0] === 6 || M[0] === 7) && M.length - 1 === 2 * $) {
    M[0] === 6 ? assert$d(M[M.length - 1] % 2 === 0) : M[0] === 7 && assert$d(M[M.length - 1] % 2 === 1);
    var T = this.point(
      M.slice(1, 1 + $),
      M.slice(1 + $, 1 + 2 * $)
    );
    return T;
  } else if ((M[0] === 2 || M[0] === 3) && M.length - 1 === $)
    return this.pointFromX(M.slice(1, 1 + $), M[0] === 3);
  throw new Error("Unknown point format");
};
BasePoint.prototype.encodeCompressed = function(M) {
  return this.encode(M, !0);
};
BasePoint.prototype._encode = function(M) {
  var x = this.curve.p.byteLength(), $ = this.getX().toArray("be", x);
  return M ? [this.getY().isEven() ? 2 : 3].concat($) : [4].concat($, this.getY().toArray("be", x));
};
BasePoint.prototype.encode = function(M, x) {
  return utils$j.encode(this._encode(x), M);
};
BasePoint.prototype.precompute = function(M) {
  if (this.precomputed)
    return this;
  var x = {
    doubles: null,
    naf: null,
    beta: null
  };
  return x.naf = this._getNAFPoints(8), x.doubles = this._getDoubles(4, M), x.beta = this._getBeta(), this.precomputed = x, this;
};
BasePoint.prototype._hasDoubles = function(M) {
  if (!this.precomputed)
    return !1;
  var x = this.precomputed.doubles;
  return x ? x.points.length >= Math.ceil((M.bitLength() + 1) / x.step) : !1;
};
BasePoint.prototype._getDoubles = function(M, x) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var $ = [this], T = this, S = 0; S < x; S += M) {
    for (var D = 0; D < M; D++)
      T = T.dbl();
    $.push(T);
  }
  return {
    step: M,
    points: $
  };
};
BasePoint.prototype._getNAFPoints = function(M) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var x = [this], $ = (1 << M) - 1, T = $ === 1 ? null : this.dbl(), S = 1; S < $; S++)
    x[S] = x[S - 1].add(T);
  return {
    wnd: M,
    points: x
  };
};
BasePoint.prototype._getBeta = function() {
  return null;
};
BasePoint.prototype.dblp = function(M) {
  for (var x = this, $ = 0; $ < M; $++)
    x = x.dbl();
  return x;
};
var utils$i = utils$l, BN$8 = bnExports$3, inherits$4 = inherits_browserExports, Base$2 = base$1, assert$c = utils$i.assert;
function ShortCurve(w) {
  Base$2.call(this, "short", w), this.a = new BN$8(w.a, 16).toRed(this.red), this.b = new BN$8(w.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(w), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
inherits$4(ShortCurve, Base$2);
var short = ShortCurve;
ShortCurve.prototype._getEndomorphism = function(M) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var x, $;
    if (M.beta)
      x = new BN$8(M.beta, 16).toRed(this.red);
    else {
      var T = this._getEndoRoots(this.p);
      x = T[0].cmp(T[1]) < 0 ? T[0] : T[1], x = x.toRed(this.red);
    }
    if (M.lambda)
      $ = new BN$8(M.lambda, 16);
    else {
      var S = this._getEndoRoots(this.n);
      this.g.mul(S[0]).x.cmp(this.g.x.redMul(x)) === 0 ? $ = S[0] : ($ = S[1], assert$c(this.g.mul($).x.cmp(this.g.x.redMul(x)) === 0));
    }
    var D;
    return M.basis ? D = M.basis.map(function(F) {
      return {
        a: new BN$8(F.a, 16),
        b: new BN$8(F.b, 16)
      };
    }) : D = this._getEndoBasis($), {
      beta: x,
      lambda: $,
      basis: D
    };
  }
};
ShortCurve.prototype._getEndoRoots = function(M) {
  var x = M === this.p ? this.red : BN$8.mont(M), $ = new BN$8(2).toRed(x).redInvm(), T = $.redNeg(), S = new BN$8(3).toRed(x).redNeg().redSqrt().redMul($), D = T.redAdd(S).fromRed(), F = T.redSub(S).fromRed();
  return [D, F];
};
ShortCurve.prototype._getEndoBasis = function(M) {
  for (var x = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), $ = M, T = this.n.clone(), S = new BN$8(1), D = new BN$8(0), F = new BN$8(0), z = new BN$8(1), Z, H, V, X, Q, fe, ce, me = 0, de, ne; $.cmpn(0) !== 0; ) {
    var ge = T.div($);
    de = T.sub(ge.mul($)), ne = F.sub(ge.mul(S));
    var pe = z.sub(ge.mul(D));
    if (!V && de.cmp(x) < 0)
      Z = ce.neg(), H = S, V = de.neg(), X = ne;
    else if (V && ++me === 2)
      break;
    ce = de, T = $, $ = de, F = S, S = ne, z = D, D = pe;
  }
  Q = de.neg(), fe = ne;
  var $e = V.sqr().add(X.sqr()), Re = Q.sqr().add(fe.sqr());
  return Re.cmp($e) >= 0 && (Q = Z, fe = H), V.negative && (V = V.neg(), X = X.neg()), Q.negative && (Q = Q.neg(), fe = fe.neg()), [
    { a: V, b: X },
    { a: Q, b: fe }
  ];
};
ShortCurve.prototype._endoSplit = function(M) {
  var x = this.endo.basis, $ = x[0], T = x[1], S = T.b.mul(M).divRound(this.n), D = $.b.neg().mul(M).divRound(this.n), F = S.mul($.a), z = D.mul(T.a), Z = S.mul($.b), H = D.mul(T.b), V = M.sub(F).sub(z), X = Z.add(H).neg();
  return { k1: V, k2: X };
};
ShortCurve.prototype.pointFromX = function(M, x) {
  M = new BN$8(M, 16), M.red || (M = M.toRed(this.red));
  var $ = M.redSqr().redMul(M).redIAdd(M.redMul(this.a)).redIAdd(this.b), T = $.redSqrt();
  if (T.redSqr().redSub($).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var S = T.fromRed().isOdd();
  return (x && !S || !x && S) && (T = T.redNeg()), this.point(M, T);
};
ShortCurve.prototype.validate = function(M) {
  if (M.inf)
    return !0;
  var x = M.x, $ = M.y, T = this.a.redMul(x), S = x.redSqr().redMul(x).redIAdd(T).redIAdd(this.b);
  return $.redSqr().redISub(S).cmpn(0) === 0;
};
ShortCurve.prototype._endoWnafMulAdd = function(M, x, $) {
  for (var T = this._endoWnafT1, S = this._endoWnafT2, D = 0; D < M.length; D++) {
    var F = this._endoSplit(x[D]), z = M[D], Z = z._getBeta();
    F.k1.negative && (F.k1.ineg(), z = z.neg(!0)), F.k2.negative && (F.k2.ineg(), Z = Z.neg(!0)), T[D * 2] = z, T[D * 2 + 1] = Z, S[D * 2] = F.k1, S[D * 2 + 1] = F.k2;
  }
  for (var H = this._wnafMulAdd(1, T, S, D * 2, $), V = 0; V < D * 2; V++)
    T[V] = null, S[V] = null;
  return H;
};
function Point$2(w, M, x, $) {
  Base$2.BasePoint.call(this, w, "affine"), M === null && x === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new BN$8(M, 16), this.y = new BN$8(x, 16), $ && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
inherits$4(Point$2, Base$2.BasePoint);
ShortCurve.prototype.point = function(M, x, $) {
  return new Point$2(this, M, x, $);
};
ShortCurve.prototype.pointFromJSON = function(M, x) {
  return Point$2.fromJSON(this, M, x);
};
Point$2.prototype._getBeta = function() {
  if (this.curve.endo) {
    var M = this.precomputed;
    if (M && M.beta)
      return M.beta;
    var x = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (M) {
      var $ = this.curve, T = function(S) {
        return $.point(S.x.redMul($.endo.beta), S.y);
      };
      M.beta = x, x.precomputed = {
        beta: null,
        naf: M.naf && {
          wnd: M.naf.wnd,
          points: M.naf.points.map(T)
        },
        doubles: M.doubles && {
          step: M.doubles.step,
          points: M.doubles.points.map(T)
        }
      };
    }
    return x;
  }
};
Point$2.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
Point$2.fromJSON = function(M, x, $) {
  typeof x == "string" && (x = JSON.parse(x));
  var T = M.point(x[0], x[1], $);
  if (!x[2])
    return T;
  function S(F) {
    return M.point(F[0], F[1], $);
  }
  var D = x[2];
  return T.precomputed = {
    beta: null,
    doubles: D.doubles && {
      step: D.doubles.step,
      points: [T].concat(D.doubles.points.map(S))
    },
    naf: D.naf && {
      wnd: D.naf.wnd,
      points: [T].concat(D.naf.points.map(S))
    }
  }, T;
};
Point$2.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
Point$2.prototype.isInfinity = function() {
  return this.inf;
};
Point$2.prototype.add = function(M) {
  if (this.inf)
    return M;
  if (M.inf)
    return this;
  if (this.eq(M))
    return this.dbl();
  if (this.neg().eq(M))
    return this.curve.point(null, null);
  if (this.x.cmp(M.x) === 0)
    return this.curve.point(null, null);
  var x = this.y.redSub(M.y);
  x.cmpn(0) !== 0 && (x = x.redMul(this.x.redSub(M.x).redInvm()));
  var $ = x.redSqr().redISub(this.x).redISub(M.x), T = x.redMul(this.x.redSub($)).redISub(this.y);
  return this.curve.point($, T);
};
Point$2.prototype.dbl = function() {
  if (this.inf)
    return this;
  var M = this.y.redAdd(this.y);
  if (M.cmpn(0) === 0)
    return this.curve.point(null, null);
  var x = this.curve.a, $ = this.x.redSqr(), T = M.redInvm(), S = $.redAdd($).redIAdd($).redIAdd(x).redMul(T), D = S.redSqr().redISub(this.x.redAdd(this.x)), F = S.redMul(this.x.redSub(D)).redISub(this.y);
  return this.curve.point(D, F);
};
Point$2.prototype.getX = function() {
  return this.x.fromRed();
};
Point$2.prototype.getY = function() {
  return this.y.fromRed();
};
Point$2.prototype.mul = function(M) {
  return M = new BN$8(M, 16), this.isInfinity() ? this : this._hasDoubles(M) ? this.curve._fixedNafMul(this, M) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [M]) : this.curve._wnafMul(this, M);
};
Point$2.prototype.mulAdd = function(M, x, $) {
  var T = [this, x], S = [M, $];
  return this.curve.endo ? this.curve._endoWnafMulAdd(T, S) : this.curve._wnafMulAdd(1, T, S, 2);
};
Point$2.prototype.jmulAdd = function(M, x, $) {
  var T = [this, x], S = [M, $];
  return this.curve.endo ? this.curve._endoWnafMulAdd(T, S, !0) : this.curve._wnafMulAdd(1, T, S, 2, !0);
};
Point$2.prototype.eq = function(M) {
  return this === M || this.inf === M.inf && (this.inf || this.x.cmp(M.x) === 0 && this.y.cmp(M.y) === 0);
};
Point$2.prototype.neg = function(M) {
  if (this.inf)
    return this;
  var x = this.curve.point(this.x, this.y.redNeg());
  if (M && this.precomputed) {
    var $ = this.precomputed, T = function(S) {
      return S.neg();
    };
    x.precomputed = {
      naf: $.naf && {
        wnd: $.naf.wnd,
        points: $.naf.points.map(T)
      },
      doubles: $.doubles && {
        step: $.doubles.step,
        points: $.doubles.points.map(T)
      }
    };
  }
  return x;
};
Point$2.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var M = this.curve.jpoint(this.x, this.y, this.curve.one);
  return M;
};
function JPoint(w, M, x, $) {
  Base$2.BasePoint.call(this, w, "jacobian"), M === null && x === null && $ === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new BN$8(0)) : (this.x = new BN$8(M, 16), this.y = new BN$8(x, 16), this.z = new BN$8($, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
inherits$4(JPoint, Base$2.BasePoint);
ShortCurve.prototype.jpoint = function(M, x, $) {
  return new JPoint(this, M, x, $);
};
JPoint.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var M = this.z.redInvm(), x = M.redSqr(), $ = this.x.redMul(x), T = this.y.redMul(x).redMul(M);
  return this.curve.point($, T);
};
JPoint.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
JPoint.prototype.add = function(M) {
  if (this.isInfinity())
    return M;
  if (M.isInfinity())
    return this;
  var x = M.z.redSqr(), $ = this.z.redSqr(), T = this.x.redMul(x), S = M.x.redMul($), D = this.y.redMul(x.redMul(M.z)), F = M.y.redMul($.redMul(this.z)), z = T.redSub(S), Z = D.redSub(F);
  if (z.cmpn(0) === 0)
    return Z.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var H = z.redSqr(), V = H.redMul(z), X = T.redMul(H), Q = Z.redSqr().redIAdd(V).redISub(X).redISub(X), fe = Z.redMul(X.redISub(Q)).redISub(D.redMul(V)), ce = this.z.redMul(M.z).redMul(z);
  return this.curve.jpoint(Q, fe, ce);
};
JPoint.prototype.mixedAdd = function(M) {
  if (this.isInfinity())
    return M.toJ();
  if (M.isInfinity())
    return this;
  var x = this.z.redSqr(), $ = this.x, T = M.x.redMul(x), S = this.y, D = M.y.redMul(x).redMul(this.z), F = $.redSub(T), z = S.redSub(D);
  if (F.cmpn(0) === 0)
    return z.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var Z = F.redSqr(), H = Z.redMul(F), V = $.redMul(Z), X = z.redSqr().redIAdd(H).redISub(V).redISub(V), Q = z.redMul(V.redISub(X)).redISub(S.redMul(H)), fe = this.z.redMul(F);
  return this.curve.jpoint(X, Q, fe);
};
JPoint.prototype.dblp = function(M) {
  if (M === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!M)
    return this.dbl();
  var x;
  if (this.curve.zeroA || this.curve.threeA) {
    var $ = this;
    for (x = 0; x < M; x++)
      $ = $.dbl();
    return $;
  }
  var T = this.curve.a, S = this.curve.tinv, D = this.x, F = this.y, z = this.z, Z = z.redSqr().redSqr(), H = F.redAdd(F);
  for (x = 0; x < M; x++) {
    var V = D.redSqr(), X = H.redSqr(), Q = X.redSqr(), fe = V.redAdd(V).redIAdd(V).redIAdd(T.redMul(Z)), ce = D.redMul(X), me = fe.redSqr().redISub(ce.redAdd(ce)), de = ce.redISub(me), ne = fe.redMul(de);
    ne = ne.redIAdd(ne).redISub(Q);
    var ge = H.redMul(z);
    x + 1 < M && (Z = Z.redMul(Q)), D = me, z = ge, H = ne;
  }
  return this.curve.jpoint(D, H.redMul(S), z);
};
JPoint.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
JPoint.prototype._zeroDbl = function() {
  var M, x, $;
  if (this.zOne) {
    var T = this.x.redSqr(), S = this.y.redSqr(), D = S.redSqr(), F = this.x.redAdd(S).redSqr().redISub(T).redISub(D);
    F = F.redIAdd(F);
    var z = T.redAdd(T).redIAdd(T), Z = z.redSqr().redISub(F).redISub(F), H = D.redIAdd(D);
    H = H.redIAdd(H), H = H.redIAdd(H), M = Z, x = z.redMul(F.redISub(Z)).redISub(H), $ = this.y.redAdd(this.y);
  } else {
    var V = this.x.redSqr(), X = this.y.redSqr(), Q = X.redSqr(), fe = this.x.redAdd(X).redSqr().redISub(V).redISub(Q);
    fe = fe.redIAdd(fe);
    var ce = V.redAdd(V).redIAdd(V), me = ce.redSqr(), de = Q.redIAdd(Q);
    de = de.redIAdd(de), de = de.redIAdd(de), M = me.redISub(fe).redISub(fe), x = ce.redMul(fe.redISub(M)).redISub(de), $ = this.y.redMul(this.z), $ = $.redIAdd($);
  }
  return this.curve.jpoint(M, x, $);
};
JPoint.prototype._threeDbl = function() {
  var M, x, $;
  if (this.zOne) {
    var T = this.x.redSqr(), S = this.y.redSqr(), D = S.redSqr(), F = this.x.redAdd(S).redSqr().redISub(T).redISub(D);
    F = F.redIAdd(F);
    var z = T.redAdd(T).redIAdd(T).redIAdd(this.curve.a), Z = z.redSqr().redISub(F).redISub(F);
    M = Z;
    var H = D.redIAdd(D);
    H = H.redIAdd(H), H = H.redIAdd(H), x = z.redMul(F.redISub(Z)).redISub(H), $ = this.y.redAdd(this.y);
  } else {
    var V = this.z.redSqr(), X = this.y.redSqr(), Q = this.x.redMul(X), fe = this.x.redSub(V).redMul(this.x.redAdd(V));
    fe = fe.redAdd(fe).redIAdd(fe);
    var ce = Q.redIAdd(Q);
    ce = ce.redIAdd(ce);
    var me = ce.redAdd(ce);
    M = fe.redSqr().redISub(me), $ = this.y.redAdd(this.z).redSqr().redISub(X).redISub(V);
    var de = X.redSqr();
    de = de.redIAdd(de), de = de.redIAdd(de), de = de.redIAdd(de), x = fe.redMul(ce.redISub(M)).redISub(de);
  }
  return this.curve.jpoint(M, x, $);
};
JPoint.prototype._dbl = function() {
  var M = this.curve.a, x = this.x, $ = this.y, T = this.z, S = T.redSqr().redSqr(), D = x.redSqr(), F = $.redSqr(), z = D.redAdd(D).redIAdd(D).redIAdd(M.redMul(S)), Z = x.redAdd(x);
  Z = Z.redIAdd(Z);
  var H = Z.redMul(F), V = z.redSqr().redISub(H.redAdd(H)), X = H.redISub(V), Q = F.redSqr();
  Q = Q.redIAdd(Q), Q = Q.redIAdd(Q), Q = Q.redIAdd(Q);
  var fe = z.redMul(X).redISub(Q), ce = $.redAdd($).redMul(T);
  return this.curve.jpoint(V, fe, ce);
};
JPoint.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var M = this.x.redSqr(), x = this.y.redSqr(), $ = this.z.redSqr(), T = x.redSqr(), S = M.redAdd(M).redIAdd(M), D = S.redSqr(), F = this.x.redAdd(x).redSqr().redISub(M).redISub(T);
  F = F.redIAdd(F), F = F.redAdd(F).redIAdd(F), F = F.redISub(D);
  var z = F.redSqr(), Z = T.redIAdd(T);
  Z = Z.redIAdd(Z), Z = Z.redIAdd(Z), Z = Z.redIAdd(Z);
  var H = S.redIAdd(F).redSqr().redISub(D).redISub(z).redISub(Z), V = x.redMul(H);
  V = V.redIAdd(V), V = V.redIAdd(V);
  var X = this.x.redMul(z).redISub(V);
  X = X.redIAdd(X), X = X.redIAdd(X);
  var Q = this.y.redMul(H.redMul(Z.redISub(H)).redISub(F.redMul(z)));
  Q = Q.redIAdd(Q), Q = Q.redIAdd(Q), Q = Q.redIAdd(Q);
  var fe = this.z.redAdd(F).redSqr().redISub($).redISub(z);
  return this.curve.jpoint(X, Q, fe);
};
JPoint.prototype.mul = function(M, x) {
  return M = new BN$8(M, x), this.curve._wnafMul(this, M);
};
JPoint.prototype.eq = function(M) {
  if (M.type === "affine")
    return this.eq(M.toJ());
  if (this === M)
    return !0;
  var x = this.z.redSqr(), $ = M.z.redSqr();
  if (this.x.redMul($).redISub(M.x.redMul(x)).cmpn(0) !== 0)
    return !1;
  var T = x.redMul(this.z), S = $.redMul(M.z);
  return this.y.redMul(S).redISub(M.y.redMul(T)).cmpn(0) === 0;
};
JPoint.prototype.eqXToP = function(M) {
  var x = this.z.redSqr(), $ = M.toRed(this.curve.red).redMul(x);
  if (this.x.cmp($) === 0)
    return !0;
  for (var T = M.clone(), S = this.curve.redN.redMul(x); ; ) {
    if (T.iadd(this.curve.n), T.cmp(this.curve.p) >= 0)
      return !1;
    if ($.redIAdd(S), this.x.cmp($) === 0)
      return !0;
  }
};
JPoint.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
JPoint.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var BN$7 = bnExports$3, inherits$3 = inherits_browserExports, Base$1 = base$1, utils$h = utils$l;
function MontCurve(w) {
  Base$1.call(this, "mont", w), this.a = new BN$7(w.a, 16).toRed(this.red), this.b = new BN$7(w.b, 16).toRed(this.red), this.i4 = new BN$7(4).toRed(this.red).redInvm(), this.two = new BN$7(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits$3(MontCurve, Base$1);
var mont = MontCurve;
MontCurve.prototype.validate = function(M) {
  var x = M.normalize().x, $ = x.redSqr(), T = $.redMul(x).redAdd($.redMul(this.a)).redAdd(x), S = T.redSqrt();
  return S.redSqr().cmp(T) === 0;
};
function Point$1(w, M, x) {
  Base$1.BasePoint.call(this, w, "projective"), M === null && x === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new BN$7(M, 16), this.z = new BN$7(x, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
}
inherits$3(Point$1, Base$1.BasePoint);
MontCurve.prototype.decodePoint = function(M, x) {
  return this.point(utils$h.toArray(M, x), 1);
};
MontCurve.prototype.point = function(M, x) {
  return new Point$1(this, M, x);
};
MontCurve.prototype.pointFromJSON = function(M) {
  return Point$1.fromJSON(this, M);
};
Point$1.prototype.precompute = function() {
};
Point$1.prototype._encode = function() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
Point$1.fromJSON = function(M, x) {
  return new Point$1(M, x[0], x[1] || M.one);
};
Point$1.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point$1.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
Point$1.prototype.dbl = function() {
  var M = this.x.redAdd(this.z), x = M.redSqr(), $ = this.x.redSub(this.z), T = $.redSqr(), S = x.redSub(T), D = x.redMul(T), F = S.redMul(T.redAdd(this.curve.a24.redMul(S)));
  return this.curve.point(D, F);
};
Point$1.prototype.add = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.diffAdd = function(M, x) {
  var $ = this.x.redAdd(this.z), T = this.x.redSub(this.z), S = M.x.redAdd(M.z), D = M.x.redSub(M.z), F = D.redMul($), z = S.redMul(T), Z = x.z.redMul(F.redAdd(z).redSqr()), H = x.x.redMul(F.redISub(z).redSqr());
  return this.curve.point(Z, H);
};
Point$1.prototype.mul = function(M) {
  for (var x = M.clone(), $ = this, T = this.curve.point(null, null), S = this, D = []; x.cmpn(0) !== 0; x.iushrn(1))
    D.push(x.andln(1));
  for (var F = D.length - 1; F >= 0; F--)
    D[F] === 0 ? ($ = $.diffAdd(T, S), T = T.dbl()) : (T = $.diffAdd(T, S), $ = $.dbl());
  return T;
};
Point$1.prototype.mulAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.jumlAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
Point$1.prototype.eq = function(M) {
  return this.getX().cmp(M.getX()) === 0;
};
Point$1.prototype.normalize = function() {
  return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
};
Point$1.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
var utils$g = utils$l, BN$6 = bnExports$3, inherits$2 = inherits_browserExports, Base = base$1, assert$b = utils$g.assert;
function EdwardsCurve(w) {
  this.twisted = (w.a | 0) !== 1, this.mOneA = this.twisted && (w.a | 0) === -1, this.extended = this.mOneA, Base.call(this, "edwards", w), this.a = new BN$6(w.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new BN$6(w.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new BN$6(w.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), assert$b(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (w.c | 0) === 1;
}
inherits$2(EdwardsCurve, Base);
var edwards = EdwardsCurve;
EdwardsCurve.prototype._mulA = function(M) {
  return this.mOneA ? M.redNeg() : this.a.redMul(M);
};
EdwardsCurve.prototype._mulC = function(M) {
  return this.oneC ? M : this.c.redMul(M);
};
EdwardsCurve.prototype.jpoint = function(M, x, $, T) {
  return this.point(M, x, $, T);
};
EdwardsCurve.prototype.pointFromX = function(M, x) {
  M = new BN$6(M, 16), M.red || (M = M.toRed(this.red));
  var $ = M.redSqr(), T = this.c2.redSub(this.a.redMul($)), S = this.one.redSub(this.c2.redMul(this.d).redMul($)), D = T.redMul(S.redInvm()), F = D.redSqrt();
  if (F.redSqr().redSub(D).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var z = F.fromRed().isOdd();
  return (x && !z || !x && z) && (F = F.redNeg()), this.point(M, F);
};
EdwardsCurve.prototype.pointFromY = function(M, x) {
  M = new BN$6(M, 16), M.red || (M = M.toRed(this.red));
  var $ = M.redSqr(), T = $.redSub(this.c2), S = $.redMul(this.d).redMul(this.c2).redSub(this.a), D = T.redMul(S.redInvm());
  if (D.cmp(this.zero) === 0) {
    if (x)
      throw new Error("invalid point");
    return this.point(this.zero, M);
  }
  var F = D.redSqrt();
  if (F.redSqr().redSub(D).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  return F.fromRed().isOdd() !== x && (F = F.redNeg()), this.point(F, M);
};
EdwardsCurve.prototype.validate = function(M) {
  if (M.isInfinity())
    return !0;
  M.normalize();
  var x = M.x.redSqr(), $ = M.y.redSqr(), T = x.redMul(this.a).redAdd($), S = this.c2.redMul(this.one.redAdd(this.d.redMul(x).redMul($)));
  return T.cmp(S) === 0;
};
function Point(w, M, x, $, T) {
  Base.BasePoint.call(this, w, "projective"), M === null && x === null && $ === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new BN$6(M, 16), this.y = new BN$6(x, 16), this.z = $ ? new BN$6($, 16) : this.curve.one, this.t = T && new BN$6(T, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
}
inherits$2(Point, Base.BasePoint);
EdwardsCurve.prototype.pointFromJSON = function(M) {
  return Point.fromJSON(this, M);
};
EdwardsCurve.prototype.point = function(M, x, $, T) {
  return new Point(this, M, x, $, T);
};
Point.fromJSON = function(M, x) {
  return new Point(M, x[0], x[1], x[2]);
};
Point.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
Point.prototype.isInfinity = function() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
Point.prototype._extDbl = function() {
  var M = this.x.redSqr(), x = this.y.redSqr(), $ = this.z.redSqr();
  $ = $.redIAdd($);
  var T = this.curve._mulA(M), S = this.x.redAdd(this.y).redSqr().redISub(M).redISub(x), D = T.redAdd(x), F = D.redSub($), z = T.redSub(x), Z = S.redMul(F), H = D.redMul(z), V = S.redMul(z), X = F.redMul(D);
  return this.curve.point(Z, H, X, V);
};
Point.prototype._projDbl = function() {
  var M = this.x.redAdd(this.y).redSqr(), x = this.x.redSqr(), $ = this.y.redSqr(), T, S, D, F, z, Z;
  if (this.curve.twisted) {
    F = this.curve._mulA(x);
    var H = F.redAdd($);
    this.zOne ? (T = M.redSub(x).redSub($).redMul(H.redSub(this.curve.two)), S = H.redMul(F.redSub($)), D = H.redSqr().redSub(H).redSub(H)) : (z = this.z.redSqr(), Z = H.redSub(z).redISub(z), T = M.redSub(x).redISub($).redMul(Z), S = H.redMul(F.redSub($)), D = H.redMul(Z));
  } else
    F = x.redAdd($), z = this.curve._mulC(this.z).redSqr(), Z = F.redSub(z).redSub(z), T = this.curve._mulC(M.redISub(F)).redMul(Z), S = this.curve._mulC(F).redMul(x.redISub($)), D = F.redMul(Z);
  return this.curve.point(T, S, D);
};
Point.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
};
Point.prototype._extAdd = function(M) {
  var x = this.y.redSub(this.x).redMul(M.y.redSub(M.x)), $ = this.y.redAdd(this.x).redMul(M.y.redAdd(M.x)), T = this.t.redMul(this.curve.dd).redMul(M.t), S = this.z.redMul(M.z.redAdd(M.z)), D = $.redSub(x), F = S.redSub(T), z = S.redAdd(T), Z = $.redAdd(x), H = D.redMul(F), V = z.redMul(Z), X = D.redMul(Z), Q = F.redMul(z);
  return this.curve.point(H, V, Q, X);
};
Point.prototype._projAdd = function(M) {
  var x = this.z.redMul(M.z), $ = x.redSqr(), T = this.x.redMul(M.x), S = this.y.redMul(M.y), D = this.curve.d.redMul(T).redMul(S), F = $.redSub(D), z = $.redAdd(D), Z = this.x.redAdd(this.y).redMul(M.x.redAdd(M.y)).redISub(T).redISub(S), H = x.redMul(F).redMul(Z), V, X;
  return this.curve.twisted ? (V = x.redMul(z).redMul(S.redSub(this.curve._mulA(T))), X = F.redMul(z)) : (V = x.redMul(z).redMul(S.redSub(T)), X = this.curve._mulC(F).redMul(z)), this.curve.point(H, V, X);
};
Point.prototype.add = function(M) {
  return this.isInfinity() ? M : M.isInfinity() ? this : this.curve.extended ? this._extAdd(M) : this._projAdd(M);
};
Point.prototype.mul = function(M) {
  return this._hasDoubles(M) ? this.curve._fixedNafMul(this, M) : this.curve._wnafMul(this, M);
};
Point.prototype.mulAdd = function(M, x, $) {
  return this.curve._wnafMulAdd(1, [this, x], [M, $], 2, !1);
};
Point.prototype.jmulAdd = function(M, x, $) {
  return this.curve._wnafMulAdd(1, [this, x], [M, $], 2, !0);
};
Point.prototype.normalize = function() {
  if (this.zOne)
    return this;
  var M = this.z.redInvm();
  return this.x = this.x.redMul(M), this.y = this.y.redMul(M), this.t && (this.t = this.t.redMul(M)), this.z = this.curve.one, this.zOne = !0, this;
};
Point.prototype.neg = function() {
  return this.curve.point(
    this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg()
  );
};
Point.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
Point.prototype.getY = function() {
  return this.normalize(), this.y.fromRed();
};
Point.prototype.eq = function(M) {
  return this === M || this.getX().cmp(M.getX()) === 0 && this.getY().cmp(M.getY()) === 0;
};
Point.prototype.eqXToP = function(M) {
  var x = M.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(x) === 0)
    return !0;
  for (var $ = M.clone(), T = this.curve.redN.redMul(this.z); ; ) {
    if ($.iadd(this.curve.n), $.cmp(this.curve.p) >= 0)
      return !1;
    if (x.redIAdd(T), this.x.cmp(x) === 0)
      return !0;
  }
};
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;
(function(w) {
  var M = w;
  M.base = base$1, M.short = short, M.mont = mont, M.edwards = edwards;
})(curve);
var curves$1 = {}, hash$3 = {}, utils$f = {}, assert$a = minimalisticAssert, inherits$1 = inherits_browserExports;
utils$f.inherits = inherits$1;
function isSurrogatePair(w, M) {
  return (w.charCodeAt(M) & 64512) !== 55296 || M < 0 || M + 1 >= w.length ? !1 : (w.charCodeAt(M + 1) & 64512) === 56320;
}
function toArray(w, M) {
  if (Array.isArray(w))
    return w.slice();
  if (!w)
    return [];
  var x = [];
  if (typeof w == "string")
    if (M) {
      if (M === "hex")
        for (w = w.replace(/[^a-z0-9]+/ig, ""), w.length % 2 !== 0 && (w = "0" + w), T = 0; T < w.length; T += 2)
          x.push(parseInt(w[T] + w[T + 1], 16));
    } else for (var $ = 0, T = 0; T < w.length; T++) {
      var S = w.charCodeAt(T);
      S < 128 ? x[$++] = S : S < 2048 ? (x[$++] = S >> 6 | 192, x[$++] = S & 63 | 128) : isSurrogatePair(w, T) ? (S = 65536 + ((S & 1023) << 10) + (w.charCodeAt(++T) & 1023), x[$++] = S >> 18 | 240, x[$++] = S >> 12 & 63 | 128, x[$++] = S >> 6 & 63 | 128, x[$++] = S & 63 | 128) : (x[$++] = S >> 12 | 224, x[$++] = S >> 6 & 63 | 128, x[$++] = S & 63 | 128);
    }
  else
    for (T = 0; T < w.length; T++)
      x[T] = w[T] | 0;
  return x;
}
utils$f.toArray = toArray;
function toHex(w) {
  for (var M = "", x = 0; x < w.length; x++)
    M += zero2(w[x].toString(16));
  return M;
}
utils$f.toHex = toHex;
function htonl(w) {
  var M = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
  return M >>> 0;
}
utils$f.htonl = htonl;
function toHex32(w, M) {
  for (var x = "", $ = 0; $ < w.length; $++) {
    var T = w[$];
    M === "little" && (T = htonl(T)), x += zero8(T.toString(16));
  }
  return x;
}
utils$f.toHex32 = toHex32;
function zero2(w) {
  return w.length === 1 ? "0" + w : w;
}
utils$f.zero2 = zero2;
function zero8(w) {
  return w.length === 7 ? "0" + w : w.length === 6 ? "00" + w : w.length === 5 ? "000" + w : w.length === 4 ? "0000" + w : w.length === 3 ? "00000" + w : w.length === 2 ? "000000" + w : w.length === 1 ? "0000000" + w : w;
}
utils$f.zero8 = zero8;
function join32(w, M, x, $) {
  var T = x - M;
  assert$a(T % 4 === 0);
  for (var S = new Array(T / 4), D = 0, F = M; D < S.length; D++, F += 4) {
    var z;
    $ === "big" ? z = w[F] << 24 | w[F + 1] << 16 | w[F + 2] << 8 | w[F + 3] : z = w[F + 3] << 24 | w[F + 2] << 16 | w[F + 1] << 8 | w[F], S[D] = z >>> 0;
  }
  return S;
}
utils$f.join32 = join32;
function split32(w, M) {
  for (var x = new Array(w.length * 4), $ = 0, T = 0; $ < w.length; $++, T += 4) {
    var S = w[$];
    M === "big" ? (x[T] = S >>> 24, x[T + 1] = S >>> 16 & 255, x[T + 2] = S >>> 8 & 255, x[T + 3] = S & 255) : (x[T + 3] = S >>> 24, x[T + 2] = S >>> 16 & 255, x[T + 1] = S >>> 8 & 255, x[T] = S & 255);
  }
  return x;
}
utils$f.split32 = split32;
function rotr32$1(w, M) {
  return w >>> M | w << 32 - M;
}
utils$f.rotr32 = rotr32$1;
function rotl32$2(w, M) {
  return w << M | w >>> 32 - M;
}
utils$f.rotl32 = rotl32$2;
function sum32$3(w, M) {
  return w + M >>> 0;
}
utils$f.sum32 = sum32$3;
function sum32_3$1(w, M, x) {
  return w + M + x >>> 0;
}
utils$f.sum32_3 = sum32_3$1;
function sum32_4$2(w, M, x, $) {
  return w + M + x + $ >>> 0;
}
utils$f.sum32_4 = sum32_4$2;
function sum32_5$2(w, M, x, $, T) {
  return w + M + x + $ + T >>> 0;
}
utils$f.sum32_5 = sum32_5$2;
function sum64$1(w, M, x, $) {
  var T = w[M], S = w[M + 1], D = $ + S >>> 0, F = (D < $ ? 1 : 0) + x + T;
  w[M] = F >>> 0, w[M + 1] = D;
}
utils$f.sum64 = sum64$1;
function sum64_hi$1(w, M, x, $) {
  var T = M + $ >>> 0, S = (T < M ? 1 : 0) + w + x;
  return S >>> 0;
}
utils$f.sum64_hi = sum64_hi$1;
function sum64_lo$1(w, M, x, $) {
  var T = M + $;
  return T >>> 0;
}
utils$f.sum64_lo = sum64_lo$1;
function sum64_4_hi$1(w, M, x, $, T, S, D, F) {
  var z = 0, Z = M;
  Z = Z + $ >>> 0, z += Z < M ? 1 : 0, Z = Z + S >>> 0, z += Z < S ? 1 : 0, Z = Z + F >>> 0, z += Z < F ? 1 : 0;
  var H = w + x + T + D + z;
  return H >>> 0;
}
utils$f.sum64_4_hi = sum64_4_hi$1;
function sum64_4_lo$1(w, M, x, $, T, S, D, F) {
  var z = M + $ + S + F;
  return z >>> 0;
}
utils$f.sum64_4_lo = sum64_4_lo$1;
function sum64_5_hi$1(w, M, x, $, T, S, D, F, z, Z) {
  var H = 0, V = M;
  V = V + $ >>> 0, H += V < M ? 1 : 0, V = V + S >>> 0, H += V < S ? 1 : 0, V = V + F >>> 0, H += V < F ? 1 : 0, V = V + Z >>> 0, H += V < Z ? 1 : 0;
  var X = w + x + T + D + z + H;
  return X >>> 0;
}
utils$f.sum64_5_hi = sum64_5_hi$1;
function sum64_5_lo$1(w, M, x, $, T, S, D, F, z, Z) {
  var H = M + $ + S + F + Z;
  return H >>> 0;
}
utils$f.sum64_5_lo = sum64_5_lo$1;
function rotr64_hi$1(w, M, x) {
  var $ = M << 32 - x | w >>> x;
  return $ >>> 0;
}
utils$f.rotr64_hi = rotr64_hi$1;
function rotr64_lo$1(w, M, x) {
  var $ = w << 32 - x | M >>> x;
  return $ >>> 0;
}
utils$f.rotr64_lo = rotr64_lo$1;
function shr64_hi$1(w, M, x) {
  return w >>> x;
}
utils$f.shr64_hi = shr64_hi$1;
function shr64_lo$1(w, M, x) {
  var $ = w << 32 - x | M >>> x;
  return $ >>> 0;
}
utils$f.shr64_lo = shr64_lo$1;
var common$5 = {}, utils$e = utils$f, assert$9 = minimalisticAssert;
function BlockHash$4() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
common$5.BlockHash = BlockHash$4;
BlockHash$4.prototype.update = function(M, x) {
  if (M = utils$e.toArray(M, x), this.pending ? this.pending = this.pending.concat(M) : this.pending = M, this.pendingTotal += M.length, this.pending.length >= this._delta8) {
    M = this.pending;
    var $ = M.length % this._delta8;
    this.pending = M.slice(M.length - $, M.length), this.pending.length === 0 && (this.pending = null), M = utils$e.join32(M, 0, M.length - $, this.endian);
    for (var T = 0; T < M.length; T += this._delta32)
      this._update(M, T, T + this._delta32);
  }
  return this;
};
BlockHash$4.prototype.digest = function(M) {
  return this.update(this._pad()), assert$9(this.pending === null), this._digest(M);
};
BlockHash$4.prototype._pad = function() {
  var M = this.pendingTotal, x = this._delta8, $ = x - (M + this.padLength) % x, T = new Array($ + this.padLength);
  T[0] = 128;
  for (var S = 1; S < $; S++)
    T[S] = 0;
  if (M <<= 3, this.endian === "big") {
    for (var D = 8; D < this.padLength; D++)
      T[S++] = 0;
    T[S++] = 0, T[S++] = 0, T[S++] = 0, T[S++] = 0, T[S++] = M >>> 24 & 255, T[S++] = M >>> 16 & 255, T[S++] = M >>> 8 & 255, T[S++] = M & 255;
  } else
    for (T[S++] = M & 255, T[S++] = M >>> 8 & 255, T[S++] = M >>> 16 & 255, T[S++] = M >>> 24 & 255, T[S++] = 0, T[S++] = 0, T[S++] = 0, T[S++] = 0, D = 8; D < this.padLength; D++)
      T[S++] = 0;
  return T;
};
var sha = {}, common$4 = {}, utils$d = utils$f, rotr32 = utils$d.rotr32;
function ft_1$1(w, M, x, $) {
  if (w === 0)
    return ch32$1(M, x, $);
  if (w === 1 || w === 3)
    return p32(M, x, $);
  if (w === 2)
    return maj32$1(M, x, $);
}
common$4.ft_1 = ft_1$1;
function ch32$1(w, M, x) {
  return w & M ^ ~w & x;
}
common$4.ch32 = ch32$1;
function maj32$1(w, M, x) {
  return w & M ^ w & x ^ M & x;
}
common$4.maj32 = maj32$1;
function p32(w, M, x) {
  return w ^ M ^ x;
}
common$4.p32 = p32;
function s0_256$1(w) {
  return rotr32(w, 2) ^ rotr32(w, 13) ^ rotr32(w, 22);
}
common$4.s0_256 = s0_256$1;
function s1_256$1(w) {
  return rotr32(w, 6) ^ rotr32(w, 11) ^ rotr32(w, 25);
}
common$4.s1_256 = s1_256$1;
function g0_256$1(w) {
  return rotr32(w, 7) ^ rotr32(w, 18) ^ w >>> 3;
}
common$4.g0_256 = g0_256$1;
function g1_256$1(w) {
  return rotr32(w, 17) ^ rotr32(w, 19) ^ w >>> 10;
}
common$4.g1_256 = g1_256$1;
var utils$c = utils$f, common$3 = common$5, shaCommon$1 = common$4, rotl32$1 = utils$c.rotl32, sum32$2 = utils$c.sum32, sum32_5$1 = utils$c.sum32_5, ft_1 = shaCommon$1.ft_1, BlockHash$3 = common$3.BlockHash, sha1_K = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();
  BlockHash$3.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
utils$c.inherits(SHA1, BlockHash$3);
var _1 = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;
SHA1.prototype._update = function(M, x) {
  for (var $ = this.W, T = 0; T < 16; T++)
    $[T] = M[x + T];
  for (; T < $.length; T++)
    $[T] = rotl32$1($[T - 3] ^ $[T - 8] ^ $[T - 14] ^ $[T - 16], 1);
  var S = this.h[0], D = this.h[1], F = this.h[2], z = this.h[3], Z = this.h[4];
  for (T = 0; T < $.length; T++) {
    var H = ~~(T / 20), V = sum32_5$1(rotl32$1(S, 5), ft_1(H, D, F, z), Z, $[T], sha1_K[H]);
    Z = z, z = F, F = rotl32$1(D, 30), D = S, S = V;
  }
  this.h[0] = sum32$2(this.h[0], S), this.h[1] = sum32$2(this.h[1], D), this.h[2] = sum32$2(this.h[2], F), this.h[3] = sum32$2(this.h[3], z), this.h[4] = sum32$2(this.h[4], Z);
};
SHA1.prototype._digest = function(M) {
  return M === "hex" ? utils$c.toHex32(this.h, "big") : utils$c.split32(this.h, "big");
};
var utils$b = utils$f, common$2 = common$5, shaCommon = common$4, assert$8 = minimalisticAssert, sum32$1 = utils$b.sum32, sum32_4$1 = utils$b.sum32_4, sum32_5 = utils$b.sum32_5, ch32 = shaCommon.ch32, maj32 = shaCommon.maj32, s0_256 = shaCommon.s0_256, s1_256 = shaCommon.s1_256, g0_256 = shaCommon.g0_256, g1_256 = shaCommon.g1_256, BlockHash$2 = common$2.BlockHash, sha256_K = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function SHA256$1() {
  if (!(this instanceof SHA256$1))
    return new SHA256$1();
  BlockHash$2.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = sha256_K, this.W = new Array(64);
}
utils$b.inherits(SHA256$1, BlockHash$2);
var _256 = SHA256$1;
SHA256$1.blockSize = 512;
SHA256$1.outSize = 256;
SHA256$1.hmacStrength = 192;
SHA256$1.padLength = 64;
SHA256$1.prototype._update = function(M, x) {
  for (var $ = this.W, T = 0; T < 16; T++)
    $[T] = M[x + T];
  for (; T < $.length; T++)
    $[T] = sum32_4$1(g1_256($[T - 2]), $[T - 7], g0_256($[T - 15]), $[T - 16]);
  var S = this.h[0], D = this.h[1], F = this.h[2], z = this.h[3], Z = this.h[4], H = this.h[5], V = this.h[6], X = this.h[7];
  for (assert$8(this.k.length === $.length), T = 0; T < $.length; T++) {
    var Q = sum32_5(X, s1_256(Z), ch32(Z, H, V), this.k[T], $[T]), fe = sum32$1(s0_256(S), maj32(S, D, F));
    X = V, V = H, H = Z, Z = sum32$1(z, Q), z = F, F = D, D = S, S = sum32$1(Q, fe);
  }
  this.h[0] = sum32$1(this.h[0], S), this.h[1] = sum32$1(this.h[1], D), this.h[2] = sum32$1(this.h[2], F), this.h[3] = sum32$1(this.h[3], z), this.h[4] = sum32$1(this.h[4], Z), this.h[5] = sum32$1(this.h[5], H), this.h[6] = sum32$1(this.h[6], V), this.h[7] = sum32$1(this.h[7], X);
};
SHA256$1.prototype._digest = function(M) {
  return M === "hex" ? utils$b.toHex32(this.h, "big") : utils$b.split32(this.h, "big");
};
var utils$a = utils$f, SHA256 = _256;
function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();
  SHA256.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
utils$a.inherits(SHA224, SHA256);
var _224 = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;
SHA224.prototype._digest = function(M) {
  return M === "hex" ? utils$a.toHex32(this.h.slice(0, 7), "big") : utils$a.split32(this.h.slice(0, 7), "big");
};
var utils$9 = utils$f, common$1 = common$5, assert$7 = minimalisticAssert, rotr64_hi = utils$9.rotr64_hi, rotr64_lo = utils$9.rotr64_lo, shr64_hi = utils$9.shr64_hi, shr64_lo = utils$9.shr64_lo, sum64 = utils$9.sum64, sum64_hi = utils$9.sum64_hi, sum64_lo = utils$9.sum64_lo, sum64_4_hi = utils$9.sum64_4_hi, sum64_4_lo = utils$9.sum64_4_lo, sum64_5_hi = utils$9.sum64_5_hi, sum64_5_lo = utils$9.sum64_5_lo, BlockHash$1 = common$1.BlockHash, sha512_K = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function SHA512$1() {
  if (!(this instanceof SHA512$1))
    return new SHA512$1();
  BlockHash$1.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = sha512_K, this.W = new Array(160);
}
utils$9.inherits(SHA512$1, BlockHash$1);
var _512 = SHA512$1;
SHA512$1.blockSize = 1024;
SHA512$1.outSize = 512;
SHA512$1.hmacStrength = 192;
SHA512$1.padLength = 128;
SHA512$1.prototype._prepareBlock = function(M, x) {
  for (var $ = this.W, T = 0; T < 32; T++)
    $[T] = M[x + T];
  for (; T < $.length; T += 2) {
    var S = g1_512_hi($[T - 4], $[T - 3]), D = g1_512_lo($[T - 4], $[T - 3]), F = $[T - 14], z = $[T - 13], Z = g0_512_hi($[T - 30], $[T - 29]), H = g0_512_lo($[T - 30], $[T - 29]), V = $[T - 32], X = $[T - 31];
    $[T] = sum64_4_hi(
      S,
      D,
      F,
      z,
      Z,
      H,
      V,
      X
    ), $[T + 1] = sum64_4_lo(
      S,
      D,
      F,
      z,
      Z,
      H,
      V,
      X
    );
  }
};
SHA512$1.prototype._update = function(M, x) {
  this._prepareBlock(M, x);
  var $ = this.W, T = this.h[0], S = this.h[1], D = this.h[2], F = this.h[3], z = this.h[4], Z = this.h[5], H = this.h[6], V = this.h[7], X = this.h[8], Q = this.h[9], fe = this.h[10], ce = this.h[11], me = this.h[12], de = this.h[13], ne = this.h[14], ge = this.h[15];
  assert$7(this.k.length === $.length);
  for (var pe = 0; pe < $.length; pe += 2) {
    var $e = ne, Re = ge, Pe = s1_512_hi(X, Q), Oe = s1_512_lo(X, Q), xe = ch64_hi(X, Q, fe, ce, me), rt = ch64_lo(X, Q, fe, ce, me, de), N = this.k[pe], y = this.k[pe + 1], E = $[pe], A = $[pe + 1], B = sum64_5_hi(
      $e,
      Re,
      Pe,
      Oe,
      xe,
      rt,
      N,
      y,
      E,
      A
    ), O = sum64_5_lo(
      $e,
      Re,
      Pe,
      Oe,
      xe,
      rt,
      N,
      y,
      E,
      A
    );
    $e = s0_512_hi(T, S), Re = s0_512_lo(T, S), Pe = maj64_hi(T, S, D, F, z), Oe = maj64_lo(T, S, D, F, z, Z);
    var C = sum64_hi($e, Re, Pe, Oe), L = sum64_lo($e, Re, Pe, Oe);
    ne = me, ge = de, me = fe, de = ce, fe = X, ce = Q, X = sum64_hi(H, V, B, O), Q = sum64_lo(V, V, B, O), H = z, V = Z, z = D, Z = F, D = T, F = S, T = sum64_hi(B, O, C, L), S = sum64_lo(B, O, C, L);
  }
  sum64(this.h, 0, T, S), sum64(this.h, 2, D, F), sum64(this.h, 4, z, Z), sum64(this.h, 6, H, V), sum64(this.h, 8, X, Q), sum64(this.h, 10, fe, ce), sum64(this.h, 12, me, de), sum64(this.h, 14, ne, ge);
};
SHA512$1.prototype._digest = function(M) {
  return M === "hex" ? utils$9.toHex32(this.h, "big") : utils$9.split32(this.h, "big");
};
function ch64_hi(w, M, x, $, T) {
  var S = w & x ^ ~w & T;
  return S < 0 && (S += 4294967296), S;
}
function ch64_lo(w, M, x, $, T, S) {
  var D = M & $ ^ ~M & S;
  return D < 0 && (D += 4294967296), D;
}
function maj64_hi(w, M, x, $, T) {
  var S = w & x ^ w & T ^ x & T;
  return S < 0 && (S += 4294967296), S;
}
function maj64_lo(w, M, x, $, T, S) {
  var D = M & $ ^ M & S ^ $ & S;
  return D < 0 && (D += 4294967296), D;
}
function s0_512_hi(w, M) {
  var x = rotr64_hi(w, M, 28), $ = rotr64_hi(M, w, 2), T = rotr64_hi(M, w, 7), S = x ^ $ ^ T;
  return S < 0 && (S += 4294967296), S;
}
function s0_512_lo(w, M) {
  var x = rotr64_lo(w, M, 28), $ = rotr64_lo(M, w, 2), T = rotr64_lo(M, w, 7), S = x ^ $ ^ T;
  return S < 0 && (S += 4294967296), S;
}
function s1_512_hi(w, M) {
  var x = rotr64_hi(w, M, 14), $ = rotr64_hi(w, M, 18), T = rotr64_hi(M, w, 9), S = x ^ $ ^ T;
  return S < 0 && (S += 4294967296), S;
}
function s1_512_lo(w, M) {
  var x = rotr64_lo(w, M, 14), $ = rotr64_lo(w, M, 18), T = rotr64_lo(M, w, 9), S = x ^ $ ^ T;
  return S < 0 && (S += 4294967296), S;
}
function g0_512_hi(w, M) {
  var x = rotr64_hi(w, M, 1), $ = rotr64_hi(w, M, 8), T = shr64_hi(w, M, 7), S = x ^ $ ^ T;
  return S < 0 && (S += 4294967296), S;
}
function g0_512_lo(w, M) {
  var x = rotr64_lo(w, M, 1), $ = rotr64_lo(w, M, 8), T = shr64_lo(w, M, 7), S = x ^ $ ^ T;
  return S < 0 && (S += 4294967296), S;
}
function g1_512_hi(w, M) {
  var x = rotr64_hi(w, M, 19), $ = rotr64_hi(M, w, 29), T = shr64_hi(w, M, 6), S = x ^ $ ^ T;
  return S < 0 && (S += 4294967296), S;
}
function g1_512_lo(w, M) {
  var x = rotr64_lo(w, M, 19), $ = rotr64_lo(M, w, 29), T = shr64_lo(w, M, 6), S = x ^ $ ^ T;
  return S < 0 && (S += 4294967296), S;
}
var utils$8 = utils$f, SHA512 = _512;
function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();
  SHA512.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
utils$8.inherits(SHA384, SHA512);
var _384 = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;
SHA384.prototype._digest = function(M) {
  return M === "hex" ? utils$8.toHex32(this.h.slice(0, 12), "big") : utils$8.split32(this.h.slice(0, 12), "big");
};
sha.sha1 = _1;
sha.sha224 = _224;
sha.sha256 = _256;
sha.sha384 = _384;
sha.sha512 = _512;
var ripemd = {}, utils$7 = utils$f, common = common$5, rotl32 = utils$7.rotl32, sum32 = utils$7.sum32, sum32_3 = utils$7.sum32_3, sum32_4 = utils$7.sum32_4, BlockHash = common.BlockHash;
function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();
  BlockHash.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
utils$7.inherits(RIPEMD160, BlockHash);
ripemd.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;
RIPEMD160.prototype._update = function(M, x) {
  for (var $ = this.h[0], T = this.h[1], S = this.h[2], D = this.h[3], F = this.h[4], z = $, Z = T, H = S, V = D, X = F, Q = 0; Q < 80; Q++) {
    var fe = sum32(
      rotl32(
        sum32_4($, f(Q, T, S, D), M[r[Q] + x], K(Q)),
        s[Q]
      ),
      F
    );
    $ = F, F = D, D = rotl32(S, 10), S = T, T = fe, fe = sum32(
      rotl32(
        sum32_4(z, f(79 - Q, Z, H, V), M[rh[Q] + x], Kh(Q)),
        sh[Q]
      ),
      X
    ), z = X, X = V, V = rotl32(H, 10), H = Z, Z = fe;
  }
  fe = sum32_3(this.h[1], S, V), this.h[1] = sum32_3(this.h[2], D, X), this.h[2] = sum32_3(this.h[3], F, z), this.h[3] = sum32_3(this.h[4], $, Z), this.h[4] = sum32_3(this.h[0], T, H), this.h[0] = fe;
};
RIPEMD160.prototype._digest = function(M) {
  return M === "hex" ? utils$7.toHex32(this.h, "little") : utils$7.split32(this.h, "little");
};
function f(w, M, x, $) {
  return w <= 15 ? M ^ x ^ $ : w <= 31 ? M & x | ~M & $ : w <= 47 ? (M | ~x) ^ $ : w <= 63 ? M & $ | x & ~$ : M ^ (x | ~$);
}
function K(w) {
  return w <= 15 ? 0 : w <= 31 ? 1518500249 : w <= 47 ? 1859775393 : w <= 63 ? 2400959708 : 2840853838;
}
function Kh(w) {
  return w <= 15 ? 1352829926 : w <= 31 ? 1548603684 : w <= 47 ? 1836072691 : w <= 63 ? 2053994217 : 0;
}
var r = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], rh = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], s = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], sh = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], utils$6 = utils$f, assert$6 = minimalisticAssert;
function Hmac(w, M, x) {
  if (!(this instanceof Hmac))
    return new Hmac(w, M, x);
  this.Hash = w, this.blockSize = w.blockSize / 8, this.outSize = w.outSize / 8, this.inner = null, this.outer = null, this._init(utils$6.toArray(M, x));
}
var hmac = Hmac;
Hmac.prototype._init = function(M) {
  M.length > this.blockSize && (M = new this.Hash().update(M).digest()), assert$6(M.length <= this.blockSize);
  for (var x = M.length; x < this.blockSize; x++)
    M.push(0);
  for (x = 0; x < M.length; x++)
    M[x] ^= 54;
  for (this.inner = new this.Hash().update(M), x = 0; x < M.length; x++)
    M[x] ^= 106;
  this.outer = new this.Hash().update(M);
};
Hmac.prototype.update = function(M, x) {
  return this.inner.update(M, x), this;
};
Hmac.prototype.digest = function(M) {
  return this.outer.update(this.inner.digest()), this.outer.digest(M);
};
(function(w) {
  var M = w;
  M.utils = utils$f, M.common = common$5, M.sha = sha, M.ripemd = ripemd, M.hmac = hmac, M.sha1 = M.sha.sha1, M.sha256 = M.sha.sha256, M.sha224 = M.sha.sha224, M.sha384 = M.sha.sha384, M.sha512 = M.sha.sha512, M.ripemd160 = M.ripemd.ripemd160;
})(hash$3);
var secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1;
}
(function(w) {
  var M = w, x = hash$3, $ = curve, T = utils$l, S = T.assert;
  function D(Z) {
    Z.type === "short" ? this.curve = new $.short(Z) : Z.type === "edwards" ? this.curve = new $.edwards(Z) : this.curve = new $.mont(Z), this.g = this.curve.g, this.n = this.curve.n, this.hash = Z.hash, S(this.g.validate(), "Invalid curve"), S(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  M.PresetCurve = D;
  function F(Z, H) {
    Object.defineProperty(M, Z, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var V = new D(H);
        return Object.defineProperty(M, Z, {
          configurable: !0,
          enumerable: !0,
          value: V
        }), V;
      }
    });
  }
  F("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: x.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), F("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: x.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), F("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: x.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), F("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: x.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), F("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: x.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), F("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: x.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), F("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: x.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var z;
  try {
    z = requireSecp256k1();
  } catch {
    z = void 0;
  }
  F("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: x.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      z
    ]
  });
})(curves$1);
var hash$2 = hash$3, utils$5 = utils$k, assert$5 = minimalisticAssert;
function HmacDRBG(w) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(w);
  this.hash = w.hash, this.predResist = !!w.predResist, this.outLen = this.hash.outSize, this.minEntropy = w.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var M = utils$5.toArray(w.entropy, w.entropyEnc || "hex"), x = utils$5.toArray(w.nonce, w.nonceEnc || "hex"), $ = utils$5.toArray(w.pers, w.persEnc || "hex");
  assert$5(
    M.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(M, x, $);
}
var hmacDrbg = HmacDRBG;
HmacDRBG.prototype._init = function(M, x, $) {
  var T = M.concat(x).concat($);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var S = 0; S < this.V.length; S++)
    this.K[S] = 0, this.V[S] = 1;
  this._update(T), this._reseed = 1, this.reseedInterval = 281474976710656;
};
HmacDRBG.prototype._hmac = function() {
  return new hash$2.hmac(this.hash, this.K);
};
HmacDRBG.prototype._update = function(M) {
  var x = this._hmac().update(this.V).update([0]);
  M && (x = x.update(M)), this.K = x.digest(), this.V = this._hmac().update(this.V).digest(), M && (this.K = this._hmac().update(this.V).update([1]).update(M).digest(), this.V = this._hmac().update(this.V).digest());
};
HmacDRBG.prototype.reseed = function(M, x, $, T) {
  typeof x != "string" && (T = $, $ = x, x = null), M = utils$5.toArray(M, x), $ = utils$5.toArray($, T), assert$5(
    M.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(M.concat($ || [])), this._reseed = 1;
};
HmacDRBG.prototype.generate = function(M, x, $, T) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof x != "string" && (T = $, $ = x, x = null), $ && ($ = utils$5.toArray($, T || "hex"), this._update($));
  for (var S = []; S.length < M; )
    this.V = this._hmac().update(this.V).digest(), S = S.concat(this.V);
  var D = S.slice(0, M);
  return this._update($), this._reseed++, utils$5.encode(D, x);
};
var BN$5 = bnExports$3, utils$4 = utils$l, assert$4 = utils$4.assert;
function KeyPair$2(w, M) {
  this.ec = w, this.priv = null, this.pub = null, M.priv && this._importPrivate(M.priv, M.privEnc), M.pub && this._importPublic(M.pub, M.pubEnc);
}
var key$1 = KeyPair$2;
KeyPair$2.fromPublic = function(M, x, $) {
  return x instanceof KeyPair$2 ? x : new KeyPair$2(M, {
    pub: x,
    pubEnc: $
  });
};
KeyPair$2.fromPrivate = function(M, x, $) {
  return x instanceof KeyPair$2 ? x : new KeyPair$2(M, {
    priv: x,
    privEnc: $
  });
};
KeyPair$2.prototype.validate = function() {
  var M = this.getPublic();
  return M.isInfinity() ? { result: !1, reason: "Invalid public key" } : M.validate() ? M.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
KeyPair$2.prototype.getPublic = function(M, x) {
  return typeof M == "string" && (x = M, M = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), x ? this.pub.encode(x, M) : this.pub;
};
KeyPair$2.prototype.getPrivate = function(M) {
  return M === "hex" ? this.priv.toString(16, 2) : this.priv;
};
KeyPair$2.prototype._importPrivate = function(M, x) {
  this.priv = new BN$5(M, x || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
KeyPair$2.prototype._importPublic = function(M, x) {
  if (M.x || M.y) {
    this.ec.curve.type === "mont" ? assert$4(M.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && assert$4(M.x && M.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(M.x, M.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(M, x);
};
KeyPair$2.prototype.derive = function(M) {
  return M.validate() || assert$4(M.validate(), "public point not validated"), M.mul(this.priv).getX();
};
KeyPair$2.prototype.sign = function(M, x, $) {
  return this.ec.sign(M, this, x, $);
};
KeyPair$2.prototype.verify = function(M, x, $) {
  return this.ec.verify(M, x, this, void 0, $);
};
KeyPair$2.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var BN$4 = bnExports$3, utils$3 = utils$l, assert$3 = utils$3.assert;
function Signature$2(w, M) {
  if (w instanceof Signature$2)
    return w;
  this._importDER(w, M) || (assert$3(w.r && w.s, "Signature without r or s"), this.r = new BN$4(w.r, 16), this.s = new BN$4(w.s, 16), w.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = w.recoveryParam);
}
var signature$1 = Signature$2;
function Position() {
  this.place = 0;
}
function getLength(w, M) {
  var x = w[M.place++];
  if (!(x & 128))
    return x;
  var $ = x & 15;
  if ($ === 0 || $ > 4 || w[M.place] === 0)
    return !1;
  for (var T = 0, S = 0, D = M.place; S < $; S++, D++)
    T <<= 8, T |= w[D], T >>>= 0;
  return T <= 127 ? !1 : (M.place = D, T);
}
function rmPadding(w) {
  for (var M = 0, x = w.length - 1; !w[M] && !(w[M + 1] & 128) && M < x; )
    M++;
  return M === 0 ? w : w.slice(M);
}
Signature$2.prototype._importDER = function(M, x) {
  M = utils$3.toArray(M, x);
  var $ = new Position();
  if (M[$.place++] !== 48)
    return !1;
  var T = getLength(M, $);
  if (T === !1 || T + $.place !== M.length || M[$.place++] !== 2)
    return !1;
  var S = getLength(M, $);
  if (S === !1 || M[$.place] & 128)
    return !1;
  var D = M.slice($.place, S + $.place);
  if ($.place += S, M[$.place++] !== 2)
    return !1;
  var F = getLength(M, $);
  if (F === !1 || M.length !== F + $.place || M[$.place] & 128)
    return !1;
  var z = M.slice($.place, F + $.place);
  if (D[0] === 0)
    if (D[1] & 128)
      D = D.slice(1);
    else
      return !1;
  if (z[0] === 0)
    if (z[1] & 128)
      z = z.slice(1);
    else
      return !1;
  return this.r = new BN$4(D), this.s = new BN$4(z), this.recoveryParam = null, !0;
};
function constructLength(w, M) {
  if (M < 128) {
    w.push(M);
    return;
  }
  var x = 1 + (Math.log(M) / Math.LN2 >>> 3);
  for (w.push(x | 128); --x; )
    w.push(M >>> (x << 3) & 255);
  w.push(M);
}
Signature$2.prototype.toDER = function(M) {
  var x = this.r.toArray(), $ = this.s.toArray();
  for (x[0] & 128 && (x = [0].concat(x)), $[0] & 128 && ($ = [0].concat($)), x = rmPadding(x), $ = rmPadding($); !$[0] && !($[1] & 128); )
    $ = $.slice(1);
  var T = [2];
  constructLength(T, x.length), T = T.concat(x), T.push(2), constructLength(T, $.length);
  var S = T.concat($), D = [48];
  return constructLength(D, S.length), D = D.concat(S), utils$3.encode(D, M);
};
var ec, hasRequiredEc;
function requireEc() {
  if (hasRequiredEc) return ec;
  hasRequiredEc = 1;
  var w = bnExports$3, M = hmacDrbg, x = utils$l, $ = curves$1, T = requireBrorand(), S = x.assert, D = key$1, F = signature$1;
  function z(Z) {
    if (!(this instanceof z))
      return new z(Z);
    typeof Z == "string" && (S(
      Object.prototype.hasOwnProperty.call($, Z),
      "Unknown curve " + Z
    ), Z = $[Z]), Z instanceof $.PresetCurve && (Z = { curve: Z }), this.curve = Z.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = Z.curve.g, this.g.precompute(Z.curve.n.bitLength() + 1), this.hash = Z.hash || Z.curve.hash;
  }
  return ec = z, z.prototype.keyPair = function(H) {
    return new D(this, H);
  }, z.prototype.keyFromPrivate = function(H, V) {
    return D.fromPrivate(this, H, V);
  }, z.prototype.keyFromPublic = function(H, V) {
    return D.fromPublic(this, H, V);
  }, z.prototype.genKeyPair = function(H) {
    H || (H = {});
    for (var V = new M({
      hash: this.hash,
      pers: H.pers,
      persEnc: H.persEnc || "utf8",
      entropy: H.entropy || T(this.hash.hmacStrength),
      entropyEnc: H.entropy && H.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), X = this.n.byteLength(), Q = this.n.sub(new w(2)); ; ) {
      var fe = new w(V.generate(X));
      if (!(fe.cmp(Q) > 0))
        return fe.iaddn(1), this.keyFromPrivate(fe);
    }
  }, z.prototype._truncateToN = function(H, V, X) {
    var Q;
    if (w.isBN(H) || typeof H == "number")
      H = new w(H, 16), Q = H.byteLength();
    else if (typeof H == "object")
      Q = H.length, H = new w(H, 16);
    else {
      var fe = H.toString();
      Q = fe.length + 1 >>> 1, H = new w(fe, 16);
    }
    typeof X != "number" && (X = Q * 8);
    var ce = X - this.n.bitLength();
    return ce > 0 && (H = H.ushrn(ce)), !V && H.cmp(this.n) >= 0 ? H.sub(this.n) : H;
  }, z.prototype.sign = function(H, V, X, Q) {
    if (typeof X == "object" && (Q = X, X = null), Q || (Q = {}), typeof H != "string" && typeof H != "number" && !w.isBN(H)) {
      S(
        typeof H == "object" && H && typeof H.length == "number",
        "Expected message to be an array-like, a hex string, or a BN instance"
      ), S(H.length >>> 0 === H.length);
      for (var fe = 0; fe < H.length; fe++) S((H[fe] & 255) === H[fe]);
    }
    V = this.keyFromPrivate(V, X), H = this._truncateToN(H, !1, Q.msgBitLength), S(!H.isNeg(), "Can not sign a negative message");
    var ce = this.n.byteLength(), me = V.getPrivate().toArray("be", ce), de = H.toArray("be", ce);
    S(new w(de).eq(H), "Can not sign message");
    for (var ne = new M({
      hash: this.hash,
      entropy: me,
      nonce: de,
      pers: Q.pers,
      persEnc: Q.persEnc || "utf8"
    }), ge = this.n.sub(new w(1)), pe = 0; ; pe++) {
      var $e = Q.k ? Q.k(pe) : new w(ne.generate(this.n.byteLength()));
      if ($e = this._truncateToN($e, !0), !($e.cmpn(1) <= 0 || $e.cmp(ge) >= 0)) {
        var Re = this.g.mul($e);
        if (!Re.isInfinity()) {
          var Pe = Re.getX(), Oe = Pe.umod(this.n);
          if (Oe.cmpn(0) !== 0) {
            var xe = $e.invm(this.n).mul(Oe.mul(V.getPrivate()).iadd(H));
            if (xe = xe.umod(this.n), xe.cmpn(0) !== 0) {
              var rt = (Re.getY().isOdd() ? 1 : 0) | (Pe.cmp(Oe) !== 0 ? 2 : 0);
              return Q.canonical && xe.cmp(this.nh) > 0 && (xe = this.n.sub(xe), rt ^= 1), new F({ r: Oe, s: xe, recoveryParam: rt });
            }
          }
        }
      }
    }
  }, z.prototype.verify = function(H, V, X, Q, fe) {
    fe || (fe = {}), H = this._truncateToN(H, !1, fe.msgBitLength), X = this.keyFromPublic(X, Q), V = new F(V, "hex");
    var ce = V.r, me = V.s;
    if (ce.cmpn(1) < 0 || ce.cmp(this.n) >= 0 || me.cmpn(1) < 0 || me.cmp(this.n) >= 0)
      return !1;
    var de = me.invm(this.n), ne = de.mul(H).umod(this.n), ge = de.mul(ce).umod(this.n), pe;
    return this.curve._maxwellTrick ? (pe = this.g.jmulAdd(ne, X.getPublic(), ge), pe.isInfinity() ? !1 : pe.eqXToP(ce)) : (pe = this.g.mulAdd(ne, X.getPublic(), ge), pe.isInfinity() ? !1 : pe.getX().umod(this.n).cmp(ce) === 0);
  }, z.prototype.recoverPubKey = function(Z, H, V, X) {
    S((3 & V) === V, "The recovery param is more than two bits"), H = new F(H, X);
    var Q = this.n, fe = new w(Z), ce = H.r, me = H.s, de = V & 1, ne = V >> 1;
    if (ce.cmp(this.curve.p.umod(this.curve.n)) >= 0 && ne)
      throw new Error("Unable to find sencond key candinate");
    ne ? ce = this.curve.pointFromX(ce.add(this.curve.n), de) : ce = this.curve.pointFromX(ce, de);
    var ge = H.r.invm(Q), pe = Q.sub(fe).mul(ge).umod(Q), $e = me.mul(ge).umod(Q);
    return this.g.mulAdd(pe, ce, $e);
  }, z.prototype.getKeyRecoveryParam = function(Z, H, V, X) {
    if (H = new F(H, X), H.recoveryParam !== null)
      return H.recoveryParam;
    for (var Q = 0; Q < 4; Q++) {
      var fe;
      try {
        fe = this.recoverPubKey(Z, H, Q);
      } catch {
        continue;
      }
      if (fe.eq(V))
        return Q;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec;
}
var utils$2 = utils$l, assert$2 = utils$2.assert, parseBytes$2 = utils$2.parseBytes, cachedProperty$1 = utils$2.cachedProperty;
function KeyPair$1(w, M) {
  this.eddsa = w, this._secret = parseBytes$2(M.secret), w.isPoint(M.pub) ? this._pub = M.pub : this._pubBytes = parseBytes$2(M.pub);
}
KeyPair$1.fromPublic = function(M, x) {
  return x instanceof KeyPair$1 ? x : new KeyPair$1(M, { pub: x });
};
KeyPair$1.fromSecret = function(M, x) {
  return x instanceof KeyPair$1 ? x : new KeyPair$1(M, { secret: x });
};
KeyPair$1.prototype.secret = function() {
  return this._secret;
};
cachedProperty$1(KeyPair$1, "pubBytes", function() {
  return this.eddsa.encodePoint(this.pub());
});
cachedProperty$1(KeyPair$1, "pub", function() {
  return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
});
cachedProperty$1(KeyPair$1, "privBytes", function() {
  var M = this.eddsa, x = this.hash(), $ = M.encodingLength - 1, T = x.slice(0, M.encodingLength);
  return T[0] &= 248, T[$] &= 127, T[$] |= 64, T;
});
cachedProperty$1(KeyPair$1, "priv", function() {
  return this.eddsa.decodeInt(this.privBytes());
});
cachedProperty$1(KeyPair$1, "hash", function() {
  return this.eddsa.hash().update(this.secret()).digest();
});
cachedProperty$1(KeyPair$1, "messagePrefix", function() {
  return this.hash().slice(this.eddsa.encodingLength);
});
KeyPair$1.prototype.sign = function(M) {
  return assert$2(this._secret, "KeyPair can only verify"), this.eddsa.sign(M, this);
};
KeyPair$1.prototype.verify = function(M, x) {
  return this.eddsa.verify(M, x, this);
};
KeyPair$1.prototype.getSecret = function(M) {
  return assert$2(this._secret, "KeyPair is public only"), utils$2.encode(this.secret(), M);
};
KeyPair$1.prototype.getPublic = function(M) {
  return utils$2.encode(this.pubBytes(), M);
};
var key = KeyPair$1, BN$3 = bnExports$3, utils$1 = utils$l, assert$1 = utils$1.assert, cachedProperty = utils$1.cachedProperty, parseBytes$1 = utils$1.parseBytes;
function Signature$1(w, M) {
  this.eddsa = w, typeof M != "object" && (M = parseBytes$1(M)), Array.isArray(M) && (assert$1(M.length === w.encodingLength * 2, "Signature has invalid size"), M = {
    R: M.slice(0, w.encodingLength),
    S: M.slice(w.encodingLength)
  }), assert$1(M.R && M.S, "Signature without R or S"), w.isPoint(M.R) && (this._R = M.R), M.S instanceof BN$3 && (this._S = M.S), this._Rencoded = Array.isArray(M.R) ? M.R : M.Rencoded, this._Sencoded = Array.isArray(M.S) ? M.S : M.Sencoded;
}
cachedProperty(Signature$1, "S", function() {
  return this.eddsa.decodeInt(this.Sencoded());
});
cachedProperty(Signature$1, "R", function() {
  return this.eddsa.decodePoint(this.Rencoded());
});
cachedProperty(Signature$1, "Rencoded", function() {
  return this.eddsa.encodePoint(this.R());
});
cachedProperty(Signature$1, "Sencoded", function() {
  return this.eddsa.encodeInt(this.S());
});
Signature$1.prototype.toBytes = function() {
  return this.Rencoded().concat(this.Sencoded());
};
Signature$1.prototype.toHex = function() {
  return utils$1.encode(this.toBytes(), "hex").toUpperCase();
};
var signature = Signature$1, hash$1 = hash$3, curves = curves$1, utils = utils$l, assert = utils.assert, parseBytes = utils.parseBytes, KeyPair = key, Signature = signature;
function EDDSA(w) {
  if (assert(w === "ed25519", "only tested with ed25519 so far"), !(this instanceof EDDSA))
    return new EDDSA(w);
  w = curves[w].curve, this.curve = w, this.g = w.g, this.g.precompute(w.n.bitLength() + 1), this.pointClass = w.point().constructor, this.encodingLength = Math.ceil(w.n.bitLength() / 8), this.hash = hash$1.sha512;
}
var eddsa = EDDSA;
EDDSA.prototype.sign = function(M, x) {
  M = parseBytes(M);
  var $ = this.keyFromSecret(x), T = this.hashInt($.messagePrefix(), M), S = this.g.mul(T), D = this.encodePoint(S), F = this.hashInt(D, $.pubBytes(), M).mul($.priv()), z = T.add(F).umod(this.curve.n);
  return this.makeSignature({ R: S, S: z, Rencoded: D });
};
EDDSA.prototype.verify = function(M, x, $) {
  if (M = parseBytes(M), x = this.makeSignature(x), x.S().gte(x.eddsa.curve.n) || x.S().isNeg())
    return !1;
  var T = this.keyFromPublic($), S = this.hashInt(x.Rencoded(), T.pubBytes(), M), D = this.g.mul(x.S()), F = x.R().add(T.pub().mul(S));
  return F.eq(D);
};
EDDSA.prototype.hashInt = function() {
  for (var M = this.hash(), x = 0; x < arguments.length; x++)
    M.update(arguments[x]);
  return utils.intFromLE(M.digest()).umod(this.curve.n);
};
EDDSA.prototype.keyFromPublic = function(M) {
  return KeyPair.fromPublic(this, M);
};
EDDSA.prototype.keyFromSecret = function(M) {
  return KeyPair.fromSecret(this, M);
};
EDDSA.prototype.makeSignature = function(M) {
  return M instanceof Signature ? M : new Signature(this, M);
};
EDDSA.prototype.encodePoint = function(M) {
  var x = M.getY().toArray("le", this.encodingLength);
  return x[this.encodingLength - 1] |= M.getX().isOdd() ? 128 : 0, x;
};
EDDSA.prototype.decodePoint = function(M) {
  M = utils.parseBytes(M);
  var x = M.length - 1, $ = M.slice(0, x).concat(M[x] & -129), T = (M[x] & 128) !== 0, S = utils.intFromLE($);
  return this.curve.pointFromY(S, T);
};
EDDSA.prototype.encodeInt = function(M) {
  return M.toArray("le", this.encodingLength);
};
EDDSA.prototype.decodeInt = function(M) {
  return utils.intFromLE(M);
};
EDDSA.prototype.isPoint = function(M) {
  return M instanceof this.pointClass;
};
var hasRequiredElliptic;
function requireElliptic() {
  return hasRequiredElliptic || (hasRequiredElliptic = 1, function(w) {
    var M = w;
    M.version = require$$0.version, M.utils = utils$l, M.rand = requireBrorand(), M.curve = curve, M.curves = curves$1, M.ec = requireEc(), M.eddsa = eddsa;
  }(elliptic)), elliptic;
}
var asn1$3 = {}, asn1$2 = {}, bn$2 = { exports: {} };
bn$2.exports;
(function(w) {
  (function(M, x) {
    function $(N, y) {
      if (!N) throw new Error(y || "Assertion failed");
    }
    function T(N, y) {
      N.super_ = y;
      var E = function() {
      };
      E.prototype = y.prototype, N.prototype = new E(), N.prototype.constructor = N;
    }
    function S(N, y, E) {
      if (S.isBN(N))
        return N;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, N !== null && ((y === "le" || y === "be") && (E = y, y = 10), this._init(N || 0, y || 10, E || "be"));
    }
    typeof M == "object" ? M.exports = S : x.BN = S, S.BN = S, S.wordSize = 26;
    var D;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? D = window.Buffer : D = dist.Buffer;
    } catch {
    }
    S.isBN = function(y) {
      return y instanceof S ? !0 : y !== null && typeof y == "object" && y.constructor.wordSize === S.wordSize && Array.isArray(y.words);
    }, S.max = function(y, E) {
      return y.cmp(E) > 0 ? y : E;
    }, S.min = function(y, E) {
      return y.cmp(E) < 0 ? y : E;
    }, S.prototype._init = function(y, E, A) {
      if (typeof y == "number")
        return this._initNumber(y, E, A);
      if (typeof y == "object")
        return this._initArray(y, E, A);
      E === "hex" && (E = 16), $(E === (E | 0) && E >= 2 && E <= 36), y = y.toString().replace(/\s+/g, "");
      var B = 0;
      y[0] === "-" && (B++, this.negative = 1), B < y.length && (E === 16 ? this._parseHex(y, B, A) : (this._parseBase(y, E, B), A === "le" && this._initArray(this.toArray(), E, A)));
    }, S.prototype._initNumber = function(y, E, A) {
      y < 0 && (this.negative = 1, y = -y), y < 67108864 ? (this.words = [y & 67108863], this.length = 1) : y < 4503599627370496 ? (this.words = [
        y & 67108863,
        y / 67108864 & 67108863
      ], this.length = 2) : ($(y < 9007199254740992), this.words = [
        y & 67108863,
        y / 67108864 & 67108863,
        1
      ], this.length = 3), A === "le" && this._initArray(this.toArray(), E, A);
    }, S.prototype._initArray = function(y, E, A) {
      if ($(typeof y.length == "number"), y.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(y.length / 3), this.words = new Array(this.length);
      for (var B = 0; B < this.length; B++)
        this.words[B] = 0;
      var O, C, L = 0;
      if (A === "be")
        for (B = y.length - 1, O = 0; B >= 0; B -= 3)
          C = y[B] | y[B - 1] << 8 | y[B - 2] << 16, this.words[O] |= C << L & 67108863, this.words[O + 1] = C >>> 26 - L & 67108863, L += 24, L >= 26 && (L -= 26, O++);
      else if (A === "le")
        for (B = 0, O = 0; B < y.length; B += 3)
          C = y[B] | y[B + 1] << 8 | y[B + 2] << 16, this.words[O] |= C << L & 67108863, this.words[O + 1] = C >>> 26 - L & 67108863, L += 24, L >= 26 && (L -= 26, O++);
      return this.strip();
    };
    function F(N, y) {
      var E = N.charCodeAt(y);
      return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
    }
    function z(N, y, E) {
      var A = F(N, E);
      return E - 1 >= y && (A |= F(N, E - 1) << 4), A;
    }
    S.prototype._parseHex = function(y, E, A) {
      this.length = Math.ceil((y.length - E) / 6), this.words = new Array(this.length);
      for (var B = 0; B < this.length; B++)
        this.words[B] = 0;
      var O = 0, C = 0, L;
      if (A === "be")
        for (B = y.length - 1; B >= E; B -= 2)
          L = z(y, E, B) << O, this.words[C] |= L & 67108863, O >= 18 ? (O -= 18, C += 1, this.words[C] |= L >>> 26) : O += 8;
      else {
        var P = y.length - E;
        for (B = P % 2 === 0 ? E + 1 : E; B < y.length; B += 2)
          L = z(y, E, B) << O, this.words[C] |= L & 67108863, O >= 18 ? (O -= 18, C += 1, this.words[C] |= L >>> 26) : O += 8;
      }
      this.strip();
    };
    function Z(N, y, E, A) {
      for (var B = 0, O = Math.min(N.length, E), C = y; C < O; C++) {
        var L = N.charCodeAt(C) - 48;
        B *= A, L >= 49 ? B += L - 49 + 10 : L >= 17 ? B += L - 17 + 10 : B += L;
      }
      return B;
    }
    S.prototype._parseBase = function(y, E, A) {
      this.words = [0], this.length = 1;
      for (var B = 0, O = 1; O <= 67108863; O *= E)
        B++;
      B--, O = O / E | 0;
      for (var C = y.length - A, L = C % B, P = Math.min(C, C - L) + A, _ = 0, I = A; I < P; I += B)
        _ = Z(y, I, I + B, E), this.imuln(O), this.words[0] + _ < 67108864 ? this.words[0] += _ : this._iaddn(_);
      if (L !== 0) {
        var U = 1;
        for (_ = Z(y, I, y.length, E), I = 0; I < L; I++)
          U *= E;
        this.imuln(U), this.words[0] + _ < 67108864 ? this.words[0] += _ : this._iaddn(_);
      }
      this.strip();
    }, S.prototype.copy = function(y) {
      y.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        y.words[E] = this.words[E];
      y.length = this.length, y.negative = this.negative, y.red = this.red;
    }, S.prototype.clone = function() {
      var y = new S(null);
      return this.copy(y), y;
    }, S.prototype._expand = function(y) {
      for (; this.length < y; )
        this.words[this.length++] = 0;
      return this;
    }, S.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, S.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, S.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var H = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], V = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], X = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    S.prototype.toString = function(y, E) {
      y = y || 10, E = E | 0 || 1;
      var A;
      if (y === 16 || y === "hex") {
        A = "";
        for (var B = 0, O = 0, C = 0; C < this.length; C++) {
          var L = this.words[C], P = ((L << B | O) & 16777215).toString(16);
          O = L >>> 24 - B & 16777215, B += 2, B >= 26 && (B -= 26, C--), O !== 0 || C !== this.length - 1 ? A = H[6 - P.length] + P + A : A = P + A;
        }
        for (O !== 0 && (A = O.toString(16) + A); A.length % E !== 0; )
          A = "0" + A;
        return this.negative !== 0 && (A = "-" + A), A;
      }
      if (y === (y | 0) && y >= 2 && y <= 36) {
        var _ = V[y], I = X[y];
        A = "";
        var U = this.clone();
        for (U.negative = 0; !U.isZero(); ) {
          var Y = U.modn(I).toString(y);
          U = U.idivn(I), U.isZero() ? A = Y + A : A = H[_ - Y.length] + Y + A;
        }
        for (this.isZero() && (A = "0" + A); A.length % E !== 0; )
          A = "0" + A;
        return this.negative !== 0 && (A = "-" + A), A;
      }
      $(!1, "Base should be between 2 and 36");
    }, S.prototype.toNumber = function() {
      var y = this.words[0];
      return this.length === 2 ? y += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? y += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && $(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -y : y;
    }, S.prototype.toJSON = function() {
      return this.toString(16);
    }, S.prototype.toBuffer = function(y, E) {
      return $(typeof D < "u"), this.toArrayLike(D, y, E);
    }, S.prototype.toArray = function(y, E) {
      return this.toArrayLike(Array, y, E);
    }, S.prototype.toArrayLike = function(y, E, A) {
      var B = this.byteLength(), O = A || Math.max(1, B);
      $(B <= O, "byte array longer than desired length"), $(O > 0, "Requested array length <= 0"), this.strip();
      var C = E === "le", L = new y(O), P, _, I = this.clone();
      if (C) {
        for (_ = 0; !I.isZero(); _++)
          P = I.andln(255), I.iushrn(8), L[_] = P;
        for (; _ < O; _++)
          L[_] = 0;
      } else {
        for (_ = 0; _ < O - B; _++)
          L[_] = 0;
        for (_ = 0; !I.isZero(); _++)
          P = I.andln(255), I.iushrn(8), L[O - _ - 1] = P;
      }
      return L;
    }, Math.clz32 ? S.prototype._countBits = function(y) {
      return 32 - Math.clz32(y);
    } : S.prototype._countBits = function(y) {
      var E = y, A = 0;
      return E >= 4096 && (A += 13, E >>>= 13), E >= 64 && (A += 7, E >>>= 7), E >= 8 && (A += 4, E >>>= 4), E >= 2 && (A += 2, E >>>= 2), A + E;
    }, S.prototype._zeroBits = function(y) {
      if (y === 0) return 26;
      var E = y, A = 0;
      return E & 8191 || (A += 13, E >>>= 13), E & 127 || (A += 7, E >>>= 7), E & 15 || (A += 4, E >>>= 4), E & 3 || (A += 2, E >>>= 2), E & 1 || A++, A;
    }, S.prototype.bitLength = function() {
      var y = this.words[this.length - 1], E = this._countBits(y);
      return (this.length - 1) * 26 + E;
    };
    function Q(N) {
      for (var y = new Array(N.bitLength()), E = 0; E < y.length; E++) {
        var A = E / 26 | 0, B = E % 26;
        y[E] = (N.words[A] & 1 << B) >>> B;
      }
      return y;
    }
    S.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var y = 0, E = 0; E < this.length; E++) {
        var A = this._zeroBits(this.words[E]);
        if (y += A, A !== 26) break;
      }
      return y;
    }, S.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, S.prototype.toTwos = function(y) {
      return this.negative !== 0 ? this.abs().inotn(y).iaddn(1) : this.clone();
    }, S.prototype.fromTwos = function(y) {
      return this.testn(y - 1) ? this.notn(y).iaddn(1).ineg() : this.clone();
    }, S.prototype.isNeg = function() {
      return this.negative !== 0;
    }, S.prototype.neg = function() {
      return this.clone().ineg();
    }, S.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, S.prototype.iuor = function(y) {
      for (; this.length < y.length; )
        this.words[this.length++] = 0;
      for (var E = 0; E < y.length; E++)
        this.words[E] = this.words[E] | y.words[E];
      return this.strip();
    }, S.prototype.ior = function(y) {
      return $((this.negative | y.negative) === 0), this.iuor(y);
    }, S.prototype.or = function(y) {
      return this.length > y.length ? this.clone().ior(y) : y.clone().ior(this);
    }, S.prototype.uor = function(y) {
      return this.length > y.length ? this.clone().iuor(y) : y.clone().iuor(this);
    }, S.prototype.iuand = function(y) {
      var E;
      this.length > y.length ? E = y : E = this;
      for (var A = 0; A < E.length; A++)
        this.words[A] = this.words[A] & y.words[A];
      return this.length = E.length, this.strip();
    }, S.prototype.iand = function(y) {
      return $((this.negative | y.negative) === 0), this.iuand(y);
    }, S.prototype.and = function(y) {
      return this.length > y.length ? this.clone().iand(y) : y.clone().iand(this);
    }, S.prototype.uand = function(y) {
      return this.length > y.length ? this.clone().iuand(y) : y.clone().iuand(this);
    }, S.prototype.iuxor = function(y) {
      var E, A;
      this.length > y.length ? (E = this, A = y) : (E = y, A = this);
      for (var B = 0; B < A.length; B++)
        this.words[B] = E.words[B] ^ A.words[B];
      if (this !== E)
        for (; B < E.length; B++)
          this.words[B] = E.words[B];
      return this.length = E.length, this.strip();
    }, S.prototype.ixor = function(y) {
      return $((this.negative | y.negative) === 0), this.iuxor(y);
    }, S.prototype.xor = function(y) {
      return this.length > y.length ? this.clone().ixor(y) : y.clone().ixor(this);
    }, S.prototype.uxor = function(y) {
      return this.length > y.length ? this.clone().iuxor(y) : y.clone().iuxor(this);
    }, S.prototype.inotn = function(y) {
      $(typeof y == "number" && y >= 0);
      var E = Math.ceil(y / 26) | 0, A = y % 26;
      this._expand(E), A > 0 && E--;
      for (var B = 0; B < E; B++)
        this.words[B] = ~this.words[B] & 67108863;
      return A > 0 && (this.words[B] = ~this.words[B] & 67108863 >> 26 - A), this.strip();
    }, S.prototype.notn = function(y) {
      return this.clone().inotn(y);
    }, S.prototype.setn = function(y, E) {
      $(typeof y == "number" && y >= 0);
      var A = y / 26 | 0, B = y % 26;
      return this._expand(A + 1), E ? this.words[A] = this.words[A] | 1 << B : this.words[A] = this.words[A] & ~(1 << B), this.strip();
    }, S.prototype.iadd = function(y) {
      var E;
      if (this.negative !== 0 && y.negative === 0)
        return this.negative = 0, E = this.isub(y), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && y.negative !== 0)
        return y.negative = 0, E = this.isub(y), y.negative = 1, E._normSign();
      var A, B;
      this.length > y.length ? (A = this, B = y) : (A = y, B = this);
      for (var O = 0, C = 0; C < B.length; C++)
        E = (A.words[C] | 0) + (B.words[C] | 0) + O, this.words[C] = E & 67108863, O = E >>> 26;
      for (; O !== 0 && C < A.length; C++)
        E = (A.words[C] | 0) + O, this.words[C] = E & 67108863, O = E >>> 26;
      if (this.length = A.length, O !== 0)
        this.words[this.length] = O, this.length++;
      else if (A !== this)
        for (; C < A.length; C++)
          this.words[C] = A.words[C];
      return this;
    }, S.prototype.add = function(y) {
      var E;
      return y.negative !== 0 && this.negative === 0 ? (y.negative = 0, E = this.sub(y), y.negative ^= 1, E) : y.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = y.sub(this), this.negative = 1, E) : this.length > y.length ? this.clone().iadd(y) : y.clone().iadd(this);
    }, S.prototype.isub = function(y) {
      if (y.negative !== 0) {
        y.negative = 0;
        var E = this.iadd(y);
        return y.negative = 1, E._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(y), this.negative = 1, this._normSign();
      var A = this.cmp(y);
      if (A === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var B, O;
      A > 0 ? (B = this, O = y) : (B = y, O = this);
      for (var C = 0, L = 0; L < O.length; L++)
        E = (B.words[L] | 0) - (O.words[L] | 0) + C, C = E >> 26, this.words[L] = E & 67108863;
      for (; C !== 0 && L < B.length; L++)
        E = (B.words[L] | 0) + C, C = E >> 26, this.words[L] = E & 67108863;
      if (C === 0 && L < B.length && B !== this)
        for (; L < B.length; L++)
          this.words[L] = B.words[L];
      return this.length = Math.max(this.length, L), B !== this && (this.negative = 1), this.strip();
    }, S.prototype.sub = function(y) {
      return this.clone().isub(y);
    };
    function fe(N, y, E) {
      E.negative = y.negative ^ N.negative;
      var A = N.length + y.length | 0;
      E.length = A, A = A - 1 | 0;
      var B = N.words[0] | 0, O = y.words[0] | 0, C = B * O, L = C & 67108863, P = C / 67108864 | 0;
      E.words[0] = L;
      for (var _ = 1; _ < A; _++) {
        for (var I = P >>> 26, U = P & 67108863, Y = Math.min(_, y.length - 1), te = Math.max(0, _ - N.length + 1); te <= Y; te++) {
          var oe = _ - te | 0;
          B = N.words[oe] | 0, O = y.words[te] | 0, C = B * O + U, I += C / 67108864 | 0, U = C & 67108863;
        }
        E.words[_] = U | 0, P = I | 0;
      }
      return P !== 0 ? E.words[_] = P | 0 : E.length--, E.strip();
    }
    var ce = function(y, E, A) {
      var B = y.words, O = E.words, C = A.words, L = 0, P, _, I, U = B[0] | 0, Y = U & 8191, te = U >>> 13, oe = B[1] | 0, re = oe & 8191, ee = oe >>> 13, ae = B[2] | 0, ue = ae & 8191, ye = ae >>> 13, ve = B[3] | 0, he = ve & 8191, Me = ve >>> 13, Qe = B[4] | 0, Ie = Qe & 8191, De = Qe >>> 13, at = B[5] | 0, ke = at & 8191, Se = at >>> 13, lt = B[6] | 0, qe = lt & 8191, He = lt >>> 13, ot = B[7] | 0, be = ot & 8191, _e = ot >>> 13, it = B[8] | 0, Ae = it & 8191, Be = it >>> 13, nt = B[9] | 0, Te = nt & 8191, Ue = nt >>> 13, st = O[0] | 0, Le = st & 8191, Ge = st >>> 13, pt = O[1] | 0, je = pt & 8191, Je = pt >>> 13, dt = O[2] | 0, ze = dt & 8191, et = dt >>> 13, yt = O[3] | 0, Ke = yt & 8191, Ye = yt >>> 13, gt = O[4] | 0, We = gt & 8191, Xe = gt >>> 13, bt = O[5] | 0, se = bt & 8191, J = bt >>> 13, ie = O[6] | 0, le = ie & 8191, we = ie >>> 13, Ce = O[7] | 0, Ee = Ce & 8191, Fe = Ce >>> 13, ut = O[8] | 0, Ne = ut & 8191, Ve = ut >>> 13, ht = O[9] | 0, Ze = ht & 8191, tt = ht >>> 13;
      A.negative = y.negative ^ E.negative, A.length = 19, P = Math.imul(Y, Le), _ = Math.imul(Y, Ge), _ = _ + Math.imul(te, Le) | 0, I = Math.imul(te, Ge);
      var vt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, P = Math.imul(re, Le), _ = Math.imul(re, Ge), _ = _ + Math.imul(ee, Le) | 0, I = Math.imul(ee, Ge), P = P + Math.imul(Y, je) | 0, _ = _ + Math.imul(Y, Je) | 0, _ = _ + Math.imul(te, je) | 0, I = I + Math.imul(te, Je) | 0;
      var mt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, P = Math.imul(ue, Le), _ = Math.imul(ue, Ge), _ = _ + Math.imul(ye, Le) | 0, I = Math.imul(ye, Ge), P = P + Math.imul(re, je) | 0, _ = _ + Math.imul(re, Je) | 0, _ = _ + Math.imul(ee, je) | 0, I = I + Math.imul(ee, Je) | 0, P = P + Math.imul(Y, ze) | 0, _ = _ + Math.imul(Y, et) | 0, _ = _ + Math.imul(te, ze) | 0, I = I + Math.imul(te, et) | 0;
      var wt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, P = Math.imul(he, Le), _ = Math.imul(he, Ge), _ = _ + Math.imul(Me, Le) | 0, I = Math.imul(Me, Ge), P = P + Math.imul(ue, je) | 0, _ = _ + Math.imul(ue, Je) | 0, _ = _ + Math.imul(ye, je) | 0, I = I + Math.imul(ye, Je) | 0, P = P + Math.imul(re, ze) | 0, _ = _ + Math.imul(re, et) | 0, _ = _ + Math.imul(ee, ze) | 0, I = I + Math.imul(ee, et) | 0, P = P + Math.imul(Y, Ke) | 0, _ = _ + Math.imul(Y, Ye) | 0, _ = _ + Math.imul(te, Ke) | 0, I = I + Math.imul(te, Ye) | 0;
      var Mt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, P = Math.imul(Ie, Le), _ = Math.imul(Ie, Ge), _ = _ + Math.imul(De, Le) | 0, I = Math.imul(De, Ge), P = P + Math.imul(he, je) | 0, _ = _ + Math.imul(he, Je) | 0, _ = _ + Math.imul(Me, je) | 0, I = I + Math.imul(Me, Je) | 0, P = P + Math.imul(ue, ze) | 0, _ = _ + Math.imul(ue, et) | 0, _ = _ + Math.imul(ye, ze) | 0, I = I + Math.imul(ye, et) | 0, P = P + Math.imul(re, Ke) | 0, _ = _ + Math.imul(re, Ye) | 0, _ = _ + Math.imul(ee, Ke) | 0, I = I + Math.imul(ee, Ye) | 0, P = P + Math.imul(Y, We) | 0, _ = _ + Math.imul(Y, Xe) | 0, _ = _ + Math.imul(te, We) | 0, I = I + Math.imul(te, Xe) | 0;
      var _t = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, P = Math.imul(ke, Le), _ = Math.imul(ke, Ge), _ = _ + Math.imul(Se, Le) | 0, I = Math.imul(Se, Ge), P = P + Math.imul(Ie, je) | 0, _ = _ + Math.imul(Ie, Je) | 0, _ = _ + Math.imul(De, je) | 0, I = I + Math.imul(De, Je) | 0, P = P + Math.imul(he, ze) | 0, _ = _ + Math.imul(he, et) | 0, _ = _ + Math.imul(Me, ze) | 0, I = I + Math.imul(Me, et) | 0, P = P + Math.imul(ue, Ke) | 0, _ = _ + Math.imul(ue, Ye) | 0, _ = _ + Math.imul(ye, Ke) | 0, I = I + Math.imul(ye, Ye) | 0, P = P + Math.imul(re, We) | 0, _ = _ + Math.imul(re, Xe) | 0, _ = _ + Math.imul(ee, We) | 0, I = I + Math.imul(ee, Xe) | 0, P = P + Math.imul(Y, se) | 0, _ = _ + Math.imul(Y, J) | 0, _ = _ + Math.imul(te, se) | 0, I = I + Math.imul(te, J) | 0;
      var xt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, P = Math.imul(qe, Le), _ = Math.imul(qe, Ge), _ = _ + Math.imul(He, Le) | 0, I = Math.imul(He, Ge), P = P + Math.imul(ke, je) | 0, _ = _ + Math.imul(ke, Je) | 0, _ = _ + Math.imul(Se, je) | 0, I = I + Math.imul(Se, Je) | 0, P = P + Math.imul(Ie, ze) | 0, _ = _ + Math.imul(Ie, et) | 0, _ = _ + Math.imul(De, ze) | 0, I = I + Math.imul(De, et) | 0, P = P + Math.imul(he, Ke) | 0, _ = _ + Math.imul(he, Ye) | 0, _ = _ + Math.imul(Me, Ke) | 0, I = I + Math.imul(Me, Ye) | 0, P = P + Math.imul(ue, We) | 0, _ = _ + Math.imul(ue, Xe) | 0, _ = _ + Math.imul(ye, We) | 0, I = I + Math.imul(ye, Xe) | 0, P = P + Math.imul(re, se) | 0, _ = _ + Math.imul(re, J) | 0, _ = _ + Math.imul(ee, se) | 0, I = I + Math.imul(ee, J) | 0, P = P + Math.imul(Y, le) | 0, _ = _ + Math.imul(Y, we) | 0, _ = _ + Math.imul(te, le) | 0, I = I + Math.imul(te, we) | 0;
      var Et = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, P = Math.imul(be, Le), _ = Math.imul(be, Ge), _ = _ + Math.imul(_e, Le) | 0, I = Math.imul(_e, Ge), P = P + Math.imul(qe, je) | 0, _ = _ + Math.imul(qe, Je) | 0, _ = _ + Math.imul(He, je) | 0, I = I + Math.imul(He, Je) | 0, P = P + Math.imul(ke, ze) | 0, _ = _ + Math.imul(ke, et) | 0, _ = _ + Math.imul(Se, ze) | 0, I = I + Math.imul(Se, et) | 0, P = P + Math.imul(Ie, Ke) | 0, _ = _ + Math.imul(Ie, Ye) | 0, _ = _ + Math.imul(De, Ke) | 0, I = I + Math.imul(De, Ye) | 0, P = P + Math.imul(he, We) | 0, _ = _ + Math.imul(he, Xe) | 0, _ = _ + Math.imul(Me, We) | 0, I = I + Math.imul(Me, Xe) | 0, P = P + Math.imul(ue, se) | 0, _ = _ + Math.imul(ue, J) | 0, _ = _ + Math.imul(ye, se) | 0, I = I + Math.imul(ye, J) | 0, P = P + Math.imul(re, le) | 0, _ = _ + Math.imul(re, we) | 0, _ = _ + Math.imul(ee, le) | 0, I = I + Math.imul(ee, we) | 0, P = P + Math.imul(Y, Ee) | 0, _ = _ + Math.imul(Y, Fe) | 0, _ = _ + Math.imul(te, Ee) | 0, I = I + Math.imul(te, Fe) | 0;
      var St = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, P = Math.imul(Ae, Le), _ = Math.imul(Ae, Ge), _ = _ + Math.imul(Be, Le) | 0, I = Math.imul(Be, Ge), P = P + Math.imul(be, je) | 0, _ = _ + Math.imul(be, Je) | 0, _ = _ + Math.imul(_e, je) | 0, I = I + Math.imul(_e, Je) | 0, P = P + Math.imul(qe, ze) | 0, _ = _ + Math.imul(qe, et) | 0, _ = _ + Math.imul(He, ze) | 0, I = I + Math.imul(He, et) | 0, P = P + Math.imul(ke, Ke) | 0, _ = _ + Math.imul(ke, Ye) | 0, _ = _ + Math.imul(Se, Ke) | 0, I = I + Math.imul(Se, Ye) | 0, P = P + Math.imul(Ie, We) | 0, _ = _ + Math.imul(Ie, Xe) | 0, _ = _ + Math.imul(De, We) | 0, I = I + Math.imul(De, Xe) | 0, P = P + Math.imul(he, se) | 0, _ = _ + Math.imul(he, J) | 0, _ = _ + Math.imul(Me, se) | 0, I = I + Math.imul(Me, J) | 0, P = P + Math.imul(ue, le) | 0, _ = _ + Math.imul(ue, we) | 0, _ = _ + Math.imul(ye, le) | 0, I = I + Math.imul(ye, we) | 0, P = P + Math.imul(re, Ee) | 0, _ = _ + Math.imul(re, Fe) | 0, _ = _ + Math.imul(ee, Ee) | 0, I = I + Math.imul(ee, Fe) | 0, P = P + Math.imul(Y, Ne) | 0, _ = _ + Math.imul(Y, Ve) | 0, _ = _ + Math.imul(te, Ne) | 0, I = I + Math.imul(te, Ve) | 0;
      var $t = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, P = Math.imul(Te, Le), _ = Math.imul(Te, Ge), _ = _ + Math.imul(Ue, Le) | 0, I = Math.imul(Ue, Ge), P = P + Math.imul(Ae, je) | 0, _ = _ + Math.imul(Ae, Je) | 0, _ = _ + Math.imul(Be, je) | 0, I = I + Math.imul(Be, Je) | 0, P = P + Math.imul(be, ze) | 0, _ = _ + Math.imul(be, et) | 0, _ = _ + Math.imul(_e, ze) | 0, I = I + Math.imul(_e, et) | 0, P = P + Math.imul(qe, Ke) | 0, _ = _ + Math.imul(qe, Ye) | 0, _ = _ + Math.imul(He, Ke) | 0, I = I + Math.imul(He, Ye) | 0, P = P + Math.imul(ke, We) | 0, _ = _ + Math.imul(ke, Xe) | 0, _ = _ + Math.imul(Se, We) | 0, I = I + Math.imul(Se, Xe) | 0, P = P + Math.imul(Ie, se) | 0, _ = _ + Math.imul(Ie, J) | 0, _ = _ + Math.imul(De, se) | 0, I = I + Math.imul(De, J) | 0, P = P + Math.imul(he, le) | 0, _ = _ + Math.imul(he, we) | 0, _ = _ + Math.imul(Me, le) | 0, I = I + Math.imul(Me, we) | 0, P = P + Math.imul(ue, Ee) | 0, _ = _ + Math.imul(ue, Fe) | 0, _ = _ + Math.imul(ye, Ee) | 0, I = I + Math.imul(ye, Fe) | 0, P = P + Math.imul(re, Ne) | 0, _ = _ + Math.imul(re, Ve) | 0, _ = _ + Math.imul(ee, Ne) | 0, I = I + Math.imul(ee, Ve) | 0, P = P + Math.imul(Y, Ze) | 0, _ = _ + Math.imul(Y, tt) | 0, _ = _ + Math.imul(te, Ze) | 0, I = I + Math.imul(te, tt) | 0;
      var At = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, P = Math.imul(Te, je), _ = Math.imul(Te, Je), _ = _ + Math.imul(Ue, je) | 0, I = Math.imul(Ue, Je), P = P + Math.imul(Ae, ze) | 0, _ = _ + Math.imul(Ae, et) | 0, _ = _ + Math.imul(Be, ze) | 0, I = I + Math.imul(Be, et) | 0, P = P + Math.imul(be, Ke) | 0, _ = _ + Math.imul(be, Ye) | 0, _ = _ + Math.imul(_e, Ke) | 0, I = I + Math.imul(_e, Ye) | 0, P = P + Math.imul(qe, We) | 0, _ = _ + Math.imul(qe, Xe) | 0, _ = _ + Math.imul(He, We) | 0, I = I + Math.imul(He, Xe) | 0, P = P + Math.imul(ke, se) | 0, _ = _ + Math.imul(ke, J) | 0, _ = _ + Math.imul(Se, se) | 0, I = I + Math.imul(Se, J) | 0, P = P + Math.imul(Ie, le) | 0, _ = _ + Math.imul(Ie, we) | 0, _ = _ + Math.imul(De, le) | 0, I = I + Math.imul(De, we) | 0, P = P + Math.imul(he, Ee) | 0, _ = _ + Math.imul(he, Fe) | 0, _ = _ + Math.imul(Me, Ee) | 0, I = I + Math.imul(Me, Fe) | 0, P = P + Math.imul(ue, Ne) | 0, _ = _ + Math.imul(ue, Ve) | 0, _ = _ + Math.imul(ye, Ne) | 0, I = I + Math.imul(ye, Ve) | 0, P = P + Math.imul(re, Ze) | 0, _ = _ + Math.imul(re, tt) | 0, _ = _ + Math.imul(ee, Ze) | 0, I = I + Math.imul(ee, tt) | 0;
      var Rt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, P = Math.imul(Te, ze), _ = Math.imul(Te, et), _ = _ + Math.imul(Ue, ze) | 0, I = Math.imul(Ue, et), P = P + Math.imul(Ae, Ke) | 0, _ = _ + Math.imul(Ae, Ye) | 0, _ = _ + Math.imul(Be, Ke) | 0, I = I + Math.imul(Be, Ye) | 0, P = P + Math.imul(be, We) | 0, _ = _ + Math.imul(be, Xe) | 0, _ = _ + Math.imul(_e, We) | 0, I = I + Math.imul(_e, Xe) | 0, P = P + Math.imul(qe, se) | 0, _ = _ + Math.imul(qe, J) | 0, _ = _ + Math.imul(He, se) | 0, I = I + Math.imul(He, J) | 0, P = P + Math.imul(ke, le) | 0, _ = _ + Math.imul(ke, we) | 0, _ = _ + Math.imul(Se, le) | 0, I = I + Math.imul(Se, we) | 0, P = P + Math.imul(Ie, Ee) | 0, _ = _ + Math.imul(Ie, Fe) | 0, _ = _ + Math.imul(De, Ee) | 0, I = I + Math.imul(De, Fe) | 0, P = P + Math.imul(he, Ne) | 0, _ = _ + Math.imul(he, Ve) | 0, _ = _ + Math.imul(Me, Ne) | 0, I = I + Math.imul(Me, Ve) | 0, P = P + Math.imul(ue, Ze) | 0, _ = _ + Math.imul(ue, tt) | 0, _ = _ + Math.imul(ye, Ze) | 0, I = I + Math.imul(ye, tt) | 0;
      var Bt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, P = Math.imul(Te, Ke), _ = Math.imul(Te, Ye), _ = _ + Math.imul(Ue, Ke) | 0, I = Math.imul(Ue, Ye), P = P + Math.imul(Ae, We) | 0, _ = _ + Math.imul(Ae, Xe) | 0, _ = _ + Math.imul(Be, We) | 0, I = I + Math.imul(Be, Xe) | 0, P = P + Math.imul(be, se) | 0, _ = _ + Math.imul(be, J) | 0, _ = _ + Math.imul(_e, se) | 0, I = I + Math.imul(_e, J) | 0, P = P + Math.imul(qe, le) | 0, _ = _ + Math.imul(qe, we) | 0, _ = _ + Math.imul(He, le) | 0, I = I + Math.imul(He, we) | 0, P = P + Math.imul(ke, Ee) | 0, _ = _ + Math.imul(ke, Fe) | 0, _ = _ + Math.imul(Se, Ee) | 0, I = I + Math.imul(Se, Fe) | 0, P = P + Math.imul(Ie, Ne) | 0, _ = _ + Math.imul(Ie, Ve) | 0, _ = _ + Math.imul(De, Ne) | 0, I = I + Math.imul(De, Ve) | 0, P = P + Math.imul(he, Ze) | 0, _ = _ + Math.imul(he, tt) | 0, _ = _ + Math.imul(Me, Ze) | 0, I = I + Math.imul(Me, tt) | 0;
      var Tt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, P = Math.imul(Te, We), _ = Math.imul(Te, Xe), _ = _ + Math.imul(Ue, We) | 0, I = Math.imul(Ue, Xe), P = P + Math.imul(Ae, se) | 0, _ = _ + Math.imul(Ae, J) | 0, _ = _ + Math.imul(Be, se) | 0, I = I + Math.imul(Be, J) | 0, P = P + Math.imul(be, le) | 0, _ = _ + Math.imul(be, we) | 0, _ = _ + Math.imul(_e, le) | 0, I = I + Math.imul(_e, we) | 0, P = P + Math.imul(qe, Ee) | 0, _ = _ + Math.imul(qe, Fe) | 0, _ = _ + Math.imul(He, Ee) | 0, I = I + Math.imul(He, Fe) | 0, P = P + Math.imul(ke, Ne) | 0, _ = _ + Math.imul(ke, Ve) | 0, _ = _ + Math.imul(Se, Ne) | 0, I = I + Math.imul(Se, Ve) | 0, P = P + Math.imul(Ie, Ze) | 0, _ = _ + Math.imul(Ie, tt) | 0, _ = _ + Math.imul(De, Ze) | 0, I = I + Math.imul(De, tt) | 0;
      var Pt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, P = Math.imul(Te, se), _ = Math.imul(Te, J), _ = _ + Math.imul(Ue, se) | 0, I = Math.imul(Ue, J), P = P + Math.imul(Ae, le) | 0, _ = _ + Math.imul(Ae, we) | 0, _ = _ + Math.imul(Be, le) | 0, I = I + Math.imul(Be, we) | 0, P = P + Math.imul(be, Ee) | 0, _ = _ + Math.imul(be, Fe) | 0, _ = _ + Math.imul(_e, Ee) | 0, I = I + Math.imul(_e, Fe) | 0, P = P + Math.imul(qe, Ne) | 0, _ = _ + Math.imul(qe, Ve) | 0, _ = _ + Math.imul(He, Ne) | 0, I = I + Math.imul(He, Ve) | 0, P = P + Math.imul(ke, Ze) | 0, _ = _ + Math.imul(ke, tt) | 0, _ = _ + Math.imul(Se, Ze) | 0, I = I + Math.imul(Se, tt) | 0;
      var It = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, P = Math.imul(Te, le), _ = Math.imul(Te, we), _ = _ + Math.imul(Ue, le) | 0, I = Math.imul(Ue, we), P = P + Math.imul(Ae, Ee) | 0, _ = _ + Math.imul(Ae, Fe) | 0, _ = _ + Math.imul(Be, Ee) | 0, I = I + Math.imul(Be, Fe) | 0, P = P + Math.imul(be, Ne) | 0, _ = _ + Math.imul(be, Ve) | 0, _ = _ + Math.imul(_e, Ne) | 0, I = I + Math.imul(_e, Ve) | 0, P = P + Math.imul(qe, Ze) | 0, _ = _ + Math.imul(qe, tt) | 0, _ = _ + Math.imul(He, Ze) | 0, I = I + Math.imul(He, tt) | 0;
      var Ot = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, P = Math.imul(Te, Ee), _ = Math.imul(Te, Fe), _ = _ + Math.imul(Ue, Ee) | 0, I = Math.imul(Ue, Fe), P = P + Math.imul(Ae, Ne) | 0, _ = _ + Math.imul(Ae, Ve) | 0, _ = _ + Math.imul(Be, Ne) | 0, I = I + Math.imul(Be, Ve) | 0, P = P + Math.imul(be, Ze) | 0, _ = _ + Math.imul(be, tt) | 0, _ = _ + Math.imul(_e, Ze) | 0, I = I + Math.imul(_e, tt) | 0;
      var Ct = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, P = Math.imul(Te, Ne), _ = Math.imul(Te, Ve), _ = _ + Math.imul(Ue, Ne) | 0, I = Math.imul(Ue, Ve), P = P + Math.imul(Ae, Ze) | 0, _ = _ + Math.imul(Ae, tt) | 0, _ = _ + Math.imul(Be, Ze) | 0, I = I + Math.imul(Be, tt) | 0;
      var Dt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, P = Math.imul(Te, Ze), _ = Math.imul(Te, tt), _ = _ + Math.imul(Ue, Ze) | 0, I = Math.imul(Ue, tt);
      var kt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      return L = (I + (_ >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, C[0] = vt, C[1] = mt, C[2] = wt, C[3] = Mt, C[4] = _t, C[5] = xt, C[6] = Et, C[7] = St, C[8] = $t, C[9] = At, C[10] = Rt, C[11] = Bt, C[12] = Tt, C[13] = Pt, C[14] = It, C[15] = Ot, C[16] = Ct, C[17] = Dt, C[18] = kt, L !== 0 && (C[19] = L, A.length++), A;
    };
    Math.imul || (ce = fe);
    function me(N, y, E) {
      E.negative = y.negative ^ N.negative, E.length = N.length + y.length;
      for (var A = 0, B = 0, O = 0; O < E.length - 1; O++) {
        var C = B;
        B = 0;
        for (var L = A & 67108863, P = Math.min(O, y.length - 1), _ = Math.max(0, O - N.length + 1); _ <= P; _++) {
          var I = O - _, U = N.words[I] | 0, Y = y.words[_] | 0, te = U * Y, oe = te & 67108863;
          C = C + (te / 67108864 | 0) | 0, oe = oe + L | 0, L = oe & 67108863, C = C + (oe >>> 26) | 0, B += C >>> 26, C &= 67108863;
        }
        E.words[O] = L, A = C, C = B;
      }
      return A !== 0 ? E.words[O] = A : E.length--, E.strip();
    }
    function de(N, y, E) {
      var A = new ne();
      return A.mulp(N, y, E);
    }
    S.prototype.mulTo = function(y, E) {
      var A, B = this.length + y.length;
      return this.length === 10 && y.length === 10 ? A = ce(this, y, E) : B < 63 ? A = fe(this, y, E) : B < 1024 ? A = me(this, y, E) : A = de(this, y, E), A;
    };
    function ne(N, y) {
      this.x = N, this.y = y;
    }
    ne.prototype.makeRBT = function(y) {
      for (var E = new Array(y), A = S.prototype._countBits(y) - 1, B = 0; B < y; B++)
        E[B] = this.revBin(B, A, y);
      return E;
    }, ne.prototype.revBin = function(y, E, A) {
      if (y === 0 || y === A - 1) return y;
      for (var B = 0, O = 0; O < E; O++)
        B |= (y & 1) << E - O - 1, y >>= 1;
      return B;
    }, ne.prototype.permute = function(y, E, A, B, O, C) {
      for (var L = 0; L < C; L++)
        B[L] = E[y[L]], O[L] = A[y[L]];
    }, ne.prototype.transform = function(y, E, A, B, O, C) {
      this.permute(C, y, E, A, B, O);
      for (var L = 1; L < O; L <<= 1)
        for (var P = L << 1, _ = Math.cos(2 * Math.PI / P), I = Math.sin(2 * Math.PI / P), U = 0; U < O; U += P)
          for (var Y = _, te = I, oe = 0; oe < L; oe++) {
            var re = A[U + oe], ee = B[U + oe], ae = A[U + oe + L], ue = B[U + oe + L], ye = Y * ae - te * ue;
            ue = Y * ue + te * ae, ae = ye, A[U + oe] = re + ae, B[U + oe] = ee + ue, A[U + oe + L] = re - ae, B[U + oe + L] = ee - ue, oe !== P && (ye = _ * Y - I * te, te = _ * te + I * Y, Y = ye);
          }
    }, ne.prototype.guessLen13b = function(y, E) {
      var A = Math.max(E, y) | 1, B = A & 1, O = 0;
      for (A = A / 2 | 0; A; A = A >>> 1)
        O++;
      return 1 << O + 1 + B;
    }, ne.prototype.conjugate = function(y, E, A) {
      if (!(A <= 1))
        for (var B = 0; B < A / 2; B++) {
          var O = y[B];
          y[B] = y[A - B - 1], y[A - B - 1] = O, O = E[B], E[B] = -E[A - B - 1], E[A - B - 1] = -O;
        }
    }, ne.prototype.normalize13b = function(y, E) {
      for (var A = 0, B = 0; B < E / 2; B++) {
        var O = Math.round(y[2 * B + 1] / E) * 8192 + Math.round(y[2 * B] / E) + A;
        y[B] = O & 67108863, O < 67108864 ? A = 0 : A = O / 67108864 | 0;
      }
      return y;
    }, ne.prototype.convert13b = function(y, E, A, B) {
      for (var O = 0, C = 0; C < E; C++)
        O = O + (y[C] | 0), A[2 * C] = O & 8191, O = O >>> 13, A[2 * C + 1] = O & 8191, O = O >>> 13;
      for (C = 2 * E; C < B; ++C)
        A[C] = 0;
      $(O === 0), $((O & -8192) === 0);
    }, ne.prototype.stub = function(y) {
      for (var E = new Array(y), A = 0; A < y; A++)
        E[A] = 0;
      return E;
    }, ne.prototype.mulp = function(y, E, A) {
      var B = 2 * this.guessLen13b(y.length, E.length), O = this.makeRBT(B), C = this.stub(B), L = new Array(B), P = new Array(B), _ = new Array(B), I = new Array(B), U = new Array(B), Y = new Array(B), te = A.words;
      te.length = B, this.convert13b(y.words, y.length, L, B), this.convert13b(E.words, E.length, I, B), this.transform(L, C, P, _, B, O), this.transform(I, C, U, Y, B, O);
      for (var oe = 0; oe < B; oe++) {
        var re = P[oe] * U[oe] - _[oe] * Y[oe];
        _[oe] = P[oe] * Y[oe] + _[oe] * U[oe], P[oe] = re;
      }
      return this.conjugate(P, _, B), this.transform(P, _, te, C, B, O), this.conjugate(te, C, B), this.normalize13b(te, B), A.negative = y.negative ^ E.negative, A.length = y.length + E.length, A.strip();
    }, S.prototype.mul = function(y) {
      var E = new S(null);
      return E.words = new Array(this.length + y.length), this.mulTo(y, E);
    }, S.prototype.mulf = function(y) {
      var E = new S(null);
      return E.words = new Array(this.length + y.length), de(this, y, E);
    }, S.prototype.imul = function(y) {
      return this.clone().mulTo(y, this);
    }, S.prototype.imuln = function(y) {
      $(typeof y == "number"), $(y < 67108864);
      for (var E = 0, A = 0; A < this.length; A++) {
        var B = (this.words[A] | 0) * y, O = (B & 67108863) + (E & 67108863);
        E >>= 26, E += B / 67108864 | 0, E += O >>> 26, this.words[A] = O & 67108863;
      }
      return E !== 0 && (this.words[A] = E, this.length++), this.length = y === 0 ? 1 : this.length, this;
    }, S.prototype.muln = function(y) {
      return this.clone().imuln(y);
    }, S.prototype.sqr = function() {
      return this.mul(this);
    }, S.prototype.isqr = function() {
      return this.imul(this.clone());
    }, S.prototype.pow = function(y) {
      var E = Q(y);
      if (E.length === 0) return new S(1);
      for (var A = this, B = 0; B < E.length && E[B] === 0; B++, A = A.sqr())
        ;
      if (++B < E.length)
        for (var O = A.sqr(); B < E.length; B++, O = O.sqr())
          E[B] !== 0 && (A = A.mul(O));
      return A;
    }, S.prototype.iushln = function(y) {
      $(typeof y == "number" && y >= 0);
      var E = y % 26, A = (y - E) / 26, B = 67108863 >>> 26 - E << 26 - E, O;
      if (E !== 0) {
        var C = 0;
        for (O = 0; O < this.length; O++) {
          var L = this.words[O] & B, P = (this.words[O] | 0) - L << E;
          this.words[O] = P | C, C = L >>> 26 - E;
        }
        C && (this.words[O] = C, this.length++);
      }
      if (A !== 0) {
        for (O = this.length - 1; O >= 0; O--)
          this.words[O + A] = this.words[O];
        for (O = 0; O < A; O++)
          this.words[O] = 0;
        this.length += A;
      }
      return this.strip();
    }, S.prototype.ishln = function(y) {
      return $(this.negative === 0), this.iushln(y);
    }, S.prototype.iushrn = function(y, E, A) {
      $(typeof y == "number" && y >= 0);
      var B;
      E ? B = (E - E % 26) / 26 : B = 0;
      var O = y % 26, C = Math.min((y - O) / 26, this.length), L = 67108863 ^ 67108863 >>> O << O, P = A;
      if (B -= C, B = Math.max(0, B), P) {
        for (var _ = 0; _ < C; _++)
          P.words[_] = this.words[_];
        P.length = C;
      }
      if (C !== 0) if (this.length > C)
        for (this.length -= C, _ = 0; _ < this.length; _++)
          this.words[_] = this.words[_ + C];
      else
        this.words[0] = 0, this.length = 1;
      var I = 0;
      for (_ = this.length - 1; _ >= 0 && (I !== 0 || _ >= B); _--) {
        var U = this.words[_] | 0;
        this.words[_] = I << 26 - O | U >>> O, I = U & L;
      }
      return P && I !== 0 && (P.words[P.length++] = I), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, S.prototype.ishrn = function(y, E, A) {
      return $(this.negative === 0), this.iushrn(y, E, A);
    }, S.prototype.shln = function(y) {
      return this.clone().ishln(y);
    }, S.prototype.ushln = function(y) {
      return this.clone().iushln(y);
    }, S.prototype.shrn = function(y) {
      return this.clone().ishrn(y);
    }, S.prototype.ushrn = function(y) {
      return this.clone().iushrn(y);
    }, S.prototype.testn = function(y) {
      $(typeof y == "number" && y >= 0);
      var E = y % 26, A = (y - E) / 26, B = 1 << E;
      if (this.length <= A) return !1;
      var O = this.words[A];
      return !!(O & B);
    }, S.prototype.imaskn = function(y) {
      $(typeof y == "number" && y >= 0);
      var E = y % 26, A = (y - E) / 26;
      if ($(this.negative === 0, "imaskn works only with positive numbers"), this.length <= A)
        return this;
      if (E !== 0 && A++, this.length = Math.min(A, this.length), E !== 0) {
        var B = 67108863 ^ 67108863 >>> E << E;
        this.words[this.length - 1] &= B;
      }
      return this.strip();
    }, S.prototype.maskn = function(y) {
      return this.clone().imaskn(y);
    }, S.prototype.iaddn = function(y) {
      return $(typeof y == "number"), $(y < 67108864), y < 0 ? this.isubn(-y) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < y ? (this.words[0] = y - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(y), this.negative = 1, this) : this._iaddn(y);
    }, S.prototype._iaddn = function(y) {
      this.words[0] += y;
      for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
        this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
      return this.length = Math.max(this.length, E + 1), this;
    }, S.prototype.isubn = function(y) {
      if ($(typeof y == "number"), $(y < 67108864), y < 0) return this.iaddn(-y);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(y), this.negative = 1, this;
      if (this.words[0] -= y, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var E = 0; E < this.length && this.words[E] < 0; E++)
          this.words[E] += 67108864, this.words[E + 1] -= 1;
      return this.strip();
    }, S.prototype.addn = function(y) {
      return this.clone().iaddn(y);
    }, S.prototype.subn = function(y) {
      return this.clone().isubn(y);
    }, S.prototype.iabs = function() {
      return this.negative = 0, this;
    }, S.prototype.abs = function() {
      return this.clone().iabs();
    }, S.prototype._ishlnsubmul = function(y, E, A) {
      var B = y.length + A, O;
      this._expand(B);
      var C, L = 0;
      for (O = 0; O < y.length; O++) {
        C = (this.words[O + A] | 0) + L;
        var P = (y.words[O] | 0) * E;
        C -= P & 67108863, L = (C >> 26) - (P / 67108864 | 0), this.words[O + A] = C & 67108863;
      }
      for (; O < this.length - A; O++)
        C = (this.words[O + A] | 0) + L, L = C >> 26, this.words[O + A] = C & 67108863;
      if (L === 0) return this.strip();
      for ($(L === -1), L = 0, O = 0; O < this.length; O++)
        C = -(this.words[O] | 0) + L, L = C >> 26, this.words[O] = C & 67108863;
      return this.negative = 1, this.strip();
    }, S.prototype._wordDiv = function(y, E) {
      var A = this.length - y.length, B = this.clone(), O = y, C = O.words[O.length - 1] | 0, L = this._countBits(C);
      A = 26 - L, A !== 0 && (O = O.ushln(A), B.iushln(A), C = O.words[O.length - 1] | 0);
      var P = B.length - O.length, _;
      if (E !== "mod") {
        _ = new S(null), _.length = P + 1, _.words = new Array(_.length);
        for (var I = 0; I < _.length; I++)
          _.words[I] = 0;
      }
      var U = B.clone()._ishlnsubmul(O, 1, P);
      U.negative === 0 && (B = U, _ && (_.words[P] = 1));
      for (var Y = P - 1; Y >= 0; Y--) {
        var te = (B.words[O.length + Y] | 0) * 67108864 + (B.words[O.length + Y - 1] | 0);
        for (te = Math.min(te / C | 0, 67108863), B._ishlnsubmul(O, te, Y); B.negative !== 0; )
          te--, B.negative = 0, B._ishlnsubmul(O, 1, Y), B.isZero() || (B.negative ^= 1);
        _ && (_.words[Y] = te);
      }
      return _ && _.strip(), B.strip(), E !== "div" && A !== 0 && B.iushrn(A), {
        div: _ || null,
        mod: B
      };
    }, S.prototype.divmod = function(y, E, A) {
      if ($(!y.isZero()), this.isZero())
        return {
          div: new S(0),
          mod: new S(0)
        };
      var B, O, C;
      return this.negative !== 0 && y.negative === 0 ? (C = this.neg().divmod(y, E), E !== "mod" && (B = C.div.neg()), E !== "div" && (O = C.mod.neg(), A && O.negative !== 0 && O.iadd(y)), {
        div: B,
        mod: O
      }) : this.negative === 0 && y.negative !== 0 ? (C = this.divmod(y.neg(), E), E !== "mod" && (B = C.div.neg()), {
        div: B,
        mod: C.mod
      }) : this.negative & y.negative ? (C = this.neg().divmod(y.neg(), E), E !== "div" && (O = C.mod.neg(), A && O.negative !== 0 && O.isub(y)), {
        div: C.div,
        mod: O
      }) : y.length > this.length || this.cmp(y) < 0 ? {
        div: new S(0),
        mod: this
      } : y.length === 1 ? E === "div" ? {
        div: this.divn(y.words[0]),
        mod: null
      } : E === "mod" ? {
        div: null,
        mod: new S(this.modn(y.words[0]))
      } : {
        div: this.divn(y.words[0]),
        mod: new S(this.modn(y.words[0]))
      } : this._wordDiv(y, E);
    }, S.prototype.div = function(y) {
      return this.divmod(y, "div", !1).div;
    }, S.prototype.mod = function(y) {
      return this.divmod(y, "mod", !1).mod;
    }, S.prototype.umod = function(y) {
      return this.divmod(y, "mod", !0).mod;
    }, S.prototype.divRound = function(y) {
      var E = this.divmod(y);
      if (E.mod.isZero()) return E.div;
      var A = E.div.negative !== 0 ? E.mod.isub(y) : E.mod, B = y.ushrn(1), O = y.andln(1), C = A.cmp(B);
      return C < 0 || O === 1 && C === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
    }, S.prototype.modn = function(y) {
      $(y <= 67108863);
      for (var E = (1 << 26) % y, A = 0, B = this.length - 1; B >= 0; B--)
        A = (E * A + (this.words[B] | 0)) % y;
      return A;
    }, S.prototype.idivn = function(y) {
      $(y <= 67108863);
      for (var E = 0, A = this.length - 1; A >= 0; A--) {
        var B = (this.words[A] | 0) + E * 67108864;
        this.words[A] = B / y | 0, E = B % y;
      }
      return this.strip();
    }, S.prototype.divn = function(y) {
      return this.clone().idivn(y);
    }, S.prototype.egcd = function(y) {
      $(y.negative === 0), $(!y.isZero());
      var E = this, A = y.clone();
      E.negative !== 0 ? E = E.umod(y) : E = E.clone();
      for (var B = new S(1), O = new S(0), C = new S(0), L = new S(1), P = 0; E.isEven() && A.isEven(); )
        E.iushrn(1), A.iushrn(1), ++P;
      for (var _ = A.clone(), I = E.clone(); !E.isZero(); ) {
        for (var U = 0, Y = 1; !(E.words[0] & Y) && U < 26; ++U, Y <<= 1) ;
        if (U > 0)
          for (E.iushrn(U); U-- > 0; )
            (B.isOdd() || O.isOdd()) && (B.iadd(_), O.isub(I)), B.iushrn(1), O.iushrn(1);
        for (var te = 0, oe = 1; !(A.words[0] & oe) && te < 26; ++te, oe <<= 1) ;
        if (te > 0)
          for (A.iushrn(te); te-- > 0; )
            (C.isOdd() || L.isOdd()) && (C.iadd(_), L.isub(I)), C.iushrn(1), L.iushrn(1);
        E.cmp(A) >= 0 ? (E.isub(A), B.isub(C), O.isub(L)) : (A.isub(E), C.isub(B), L.isub(O));
      }
      return {
        a: C,
        b: L,
        gcd: A.iushln(P)
      };
    }, S.prototype._invmp = function(y) {
      $(y.negative === 0), $(!y.isZero());
      var E = this, A = y.clone();
      E.negative !== 0 ? E = E.umod(y) : E = E.clone();
      for (var B = new S(1), O = new S(0), C = A.clone(); E.cmpn(1) > 0 && A.cmpn(1) > 0; ) {
        for (var L = 0, P = 1; !(E.words[0] & P) && L < 26; ++L, P <<= 1) ;
        if (L > 0)
          for (E.iushrn(L); L-- > 0; )
            B.isOdd() && B.iadd(C), B.iushrn(1);
        for (var _ = 0, I = 1; !(A.words[0] & I) && _ < 26; ++_, I <<= 1) ;
        if (_ > 0)
          for (A.iushrn(_); _-- > 0; )
            O.isOdd() && O.iadd(C), O.iushrn(1);
        E.cmp(A) >= 0 ? (E.isub(A), B.isub(O)) : (A.isub(E), O.isub(B));
      }
      var U;
      return E.cmpn(1) === 0 ? U = B : U = O, U.cmpn(0) < 0 && U.iadd(y), U;
    }, S.prototype.gcd = function(y) {
      if (this.isZero()) return y.abs();
      if (y.isZero()) return this.abs();
      var E = this.clone(), A = y.clone();
      E.negative = 0, A.negative = 0;
      for (var B = 0; E.isEven() && A.isEven(); B++)
        E.iushrn(1), A.iushrn(1);
      do {
        for (; E.isEven(); )
          E.iushrn(1);
        for (; A.isEven(); )
          A.iushrn(1);
        var O = E.cmp(A);
        if (O < 0) {
          var C = E;
          E = A, A = C;
        } else if (O === 0 || A.cmpn(1) === 0)
          break;
        E.isub(A);
      } while (!0);
      return A.iushln(B);
    }, S.prototype.invm = function(y) {
      return this.egcd(y).a.umod(y);
    }, S.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, S.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, S.prototype.andln = function(y) {
      return this.words[0] & y;
    }, S.prototype.bincn = function(y) {
      $(typeof y == "number");
      var E = y % 26, A = (y - E) / 26, B = 1 << E;
      if (this.length <= A)
        return this._expand(A + 1), this.words[A] |= B, this;
      for (var O = B, C = A; O !== 0 && C < this.length; C++) {
        var L = this.words[C] | 0;
        L += O, O = L >>> 26, L &= 67108863, this.words[C] = L;
      }
      return O !== 0 && (this.words[C] = O, this.length++), this;
    }, S.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, S.prototype.cmpn = function(y) {
      var E = y < 0;
      if (this.negative !== 0 && !E) return -1;
      if (this.negative === 0 && E) return 1;
      this.strip();
      var A;
      if (this.length > 1)
        A = 1;
      else {
        E && (y = -y), $(y <= 67108863, "Number is too big");
        var B = this.words[0] | 0;
        A = B === y ? 0 : B < y ? -1 : 1;
      }
      return this.negative !== 0 ? -A | 0 : A;
    }, S.prototype.cmp = function(y) {
      if (this.negative !== 0 && y.negative === 0) return -1;
      if (this.negative === 0 && y.negative !== 0) return 1;
      var E = this.ucmp(y);
      return this.negative !== 0 ? -E | 0 : E;
    }, S.prototype.ucmp = function(y) {
      if (this.length > y.length) return 1;
      if (this.length < y.length) return -1;
      for (var E = 0, A = this.length - 1; A >= 0; A--) {
        var B = this.words[A] | 0, O = y.words[A] | 0;
        if (B !== O) {
          B < O ? E = -1 : B > O && (E = 1);
          break;
        }
      }
      return E;
    }, S.prototype.gtn = function(y) {
      return this.cmpn(y) === 1;
    }, S.prototype.gt = function(y) {
      return this.cmp(y) === 1;
    }, S.prototype.gten = function(y) {
      return this.cmpn(y) >= 0;
    }, S.prototype.gte = function(y) {
      return this.cmp(y) >= 0;
    }, S.prototype.ltn = function(y) {
      return this.cmpn(y) === -1;
    }, S.prototype.lt = function(y) {
      return this.cmp(y) === -1;
    }, S.prototype.lten = function(y) {
      return this.cmpn(y) <= 0;
    }, S.prototype.lte = function(y) {
      return this.cmp(y) <= 0;
    }, S.prototype.eqn = function(y) {
      return this.cmpn(y) === 0;
    }, S.prototype.eq = function(y) {
      return this.cmp(y) === 0;
    }, S.red = function(y) {
      return new xe(y);
    }, S.prototype.toRed = function(y) {
      return $(!this.red, "Already a number in reduction context"), $(this.negative === 0, "red works only with positives"), y.convertTo(this)._forceRed(y);
    }, S.prototype.fromRed = function() {
      return $(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, S.prototype._forceRed = function(y) {
      return this.red = y, this;
    }, S.prototype.forceRed = function(y) {
      return $(!this.red, "Already a number in reduction context"), this._forceRed(y);
    }, S.prototype.redAdd = function(y) {
      return $(this.red, "redAdd works only with red numbers"), this.red.add(this, y);
    }, S.prototype.redIAdd = function(y) {
      return $(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, y);
    }, S.prototype.redSub = function(y) {
      return $(this.red, "redSub works only with red numbers"), this.red.sub(this, y);
    }, S.prototype.redISub = function(y) {
      return $(this.red, "redISub works only with red numbers"), this.red.isub(this, y);
    }, S.prototype.redShl = function(y) {
      return $(this.red, "redShl works only with red numbers"), this.red.shl(this, y);
    }, S.prototype.redMul = function(y) {
      return $(this.red, "redMul works only with red numbers"), this.red._verify2(this, y), this.red.mul(this, y);
    }, S.prototype.redIMul = function(y) {
      return $(this.red, "redMul works only with red numbers"), this.red._verify2(this, y), this.red.imul(this, y);
    }, S.prototype.redSqr = function() {
      return $(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, S.prototype.redISqr = function() {
      return $(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, S.prototype.redSqrt = function() {
      return $(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, S.prototype.redInvm = function() {
      return $(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, S.prototype.redNeg = function() {
      return $(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, S.prototype.redPow = function(y) {
      return $(this.red && !y.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, y);
    };
    var ge = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function pe(N, y) {
      this.name = N, this.p = new S(y, 16), this.n = this.p.bitLength(), this.k = new S(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    pe.prototype._tmp = function() {
      var y = new S(null);
      return y.words = new Array(Math.ceil(this.n / 13)), y;
    }, pe.prototype.ireduce = function(y) {
      var E = y, A;
      do
        this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), A = E.bitLength();
      while (A > this.n);
      var B = A < this.n ? -1 : E.ucmp(this.p);
      return B === 0 ? (E.words[0] = 0, E.length = 1) : B > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
    }, pe.prototype.split = function(y, E) {
      y.iushrn(this.n, 0, E);
    }, pe.prototype.imulK = function(y) {
      return y.imul(this.k);
    };
    function $e() {
      pe.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    T($e, pe), $e.prototype.split = function(y, E) {
      for (var A = 4194303, B = Math.min(y.length, 9), O = 0; O < B; O++)
        E.words[O] = y.words[O];
      if (E.length = B, y.length <= 9) {
        y.words[0] = 0, y.length = 1;
        return;
      }
      var C = y.words[9];
      for (E.words[E.length++] = C & A, O = 10; O < y.length; O++) {
        var L = y.words[O] | 0;
        y.words[O - 10] = (L & A) << 4 | C >>> 22, C = L;
      }
      C >>>= 22, y.words[O - 10] = C, C === 0 && y.length > 10 ? y.length -= 10 : y.length -= 9;
    }, $e.prototype.imulK = function(y) {
      y.words[y.length] = 0, y.words[y.length + 1] = 0, y.length += 2;
      for (var E = 0, A = 0; A < y.length; A++) {
        var B = y.words[A] | 0;
        E += B * 977, y.words[A] = E & 67108863, E = B * 64 + (E / 67108864 | 0);
      }
      return y.words[y.length - 1] === 0 && (y.length--, y.words[y.length - 1] === 0 && y.length--), y;
    };
    function Re() {
      pe.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    T(Re, pe);
    function Pe() {
      pe.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    T(Pe, pe);
    function Oe() {
      pe.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    T(Oe, pe), Oe.prototype.imulK = function(y) {
      for (var E = 0, A = 0; A < y.length; A++) {
        var B = (y.words[A] | 0) * 19 + E, O = B & 67108863;
        B >>>= 26, y.words[A] = O, E = B;
      }
      return E !== 0 && (y.words[y.length++] = E), y;
    }, S._prime = function(y) {
      if (ge[y]) return ge[y];
      var E;
      if (y === "k256")
        E = new $e();
      else if (y === "p224")
        E = new Re();
      else if (y === "p192")
        E = new Pe();
      else if (y === "p25519")
        E = new Oe();
      else
        throw new Error("Unknown prime " + y);
      return ge[y] = E, E;
    };
    function xe(N) {
      if (typeof N == "string") {
        var y = S._prime(N);
        this.m = y.p, this.prime = y;
      } else
        $(N.gtn(1), "modulus must be greater than 1"), this.m = N, this.prime = null;
    }
    xe.prototype._verify1 = function(y) {
      $(y.negative === 0, "red works only with positives"), $(y.red, "red works only with red numbers");
    }, xe.prototype._verify2 = function(y, E) {
      $((y.negative | E.negative) === 0, "red works only with positives"), $(
        y.red && y.red === E.red,
        "red works only with red numbers"
      );
    }, xe.prototype.imod = function(y) {
      return this.prime ? this.prime.ireduce(y)._forceRed(this) : y.umod(this.m)._forceRed(this);
    }, xe.prototype.neg = function(y) {
      return y.isZero() ? y.clone() : this.m.sub(y)._forceRed(this);
    }, xe.prototype.add = function(y, E) {
      this._verify2(y, E);
      var A = y.add(E);
      return A.cmp(this.m) >= 0 && A.isub(this.m), A._forceRed(this);
    }, xe.prototype.iadd = function(y, E) {
      this._verify2(y, E);
      var A = y.iadd(E);
      return A.cmp(this.m) >= 0 && A.isub(this.m), A;
    }, xe.prototype.sub = function(y, E) {
      this._verify2(y, E);
      var A = y.sub(E);
      return A.cmpn(0) < 0 && A.iadd(this.m), A._forceRed(this);
    }, xe.prototype.isub = function(y, E) {
      this._verify2(y, E);
      var A = y.isub(E);
      return A.cmpn(0) < 0 && A.iadd(this.m), A;
    }, xe.prototype.shl = function(y, E) {
      return this._verify1(y), this.imod(y.ushln(E));
    }, xe.prototype.imul = function(y, E) {
      return this._verify2(y, E), this.imod(y.imul(E));
    }, xe.prototype.mul = function(y, E) {
      return this._verify2(y, E), this.imod(y.mul(E));
    }, xe.prototype.isqr = function(y) {
      return this.imul(y, y.clone());
    }, xe.prototype.sqr = function(y) {
      return this.mul(y, y);
    }, xe.prototype.sqrt = function(y) {
      if (y.isZero()) return y.clone();
      var E = this.m.andln(3);
      if ($(E % 2 === 1), E === 3) {
        var A = this.m.add(new S(1)).iushrn(2);
        return this.pow(y, A);
      }
      for (var B = this.m.subn(1), O = 0; !B.isZero() && B.andln(1) === 0; )
        O++, B.iushrn(1);
      $(!B.isZero());
      var C = new S(1).toRed(this), L = C.redNeg(), P = this.m.subn(1).iushrn(1), _ = this.m.bitLength();
      for (_ = new S(2 * _ * _).toRed(this); this.pow(_, P).cmp(L) !== 0; )
        _.redIAdd(L);
      for (var I = this.pow(_, B), U = this.pow(y, B.addn(1).iushrn(1)), Y = this.pow(y, B), te = O; Y.cmp(C) !== 0; ) {
        for (var oe = Y, re = 0; oe.cmp(C) !== 0; re++)
          oe = oe.redSqr();
        $(re < te);
        var ee = this.pow(I, new S(1).iushln(te - re - 1));
        U = U.redMul(ee), I = ee.redSqr(), Y = Y.redMul(I), te = re;
      }
      return U;
    }, xe.prototype.invm = function(y) {
      var E = y._invmp(this.m);
      return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
    }, xe.prototype.pow = function(y, E) {
      if (E.isZero()) return new S(1).toRed(this);
      if (E.cmpn(1) === 0) return y.clone();
      var A = 4, B = new Array(1 << A);
      B[0] = new S(1).toRed(this), B[1] = y;
      for (var O = 2; O < B.length; O++)
        B[O] = this.mul(B[O - 1], y);
      var C = B[0], L = 0, P = 0, _ = E.bitLength() % 26;
      for (_ === 0 && (_ = 26), O = E.length - 1; O >= 0; O--) {
        for (var I = E.words[O], U = _ - 1; U >= 0; U--) {
          var Y = I >> U & 1;
          if (C !== B[0] && (C = this.sqr(C)), Y === 0 && L === 0) {
            P = 0;
            continue;
          }
          L <<= 1, L |= Y, P++, !(P !== A && (O !== 0 || U !== 0)) && (C = this.mul(C, B[L]), P = 0, L = 0);
        }
        _ = 26;
      }
      return C;
    }, xe.prototype.convertTo = function(y) {
      var E = y.umod(this.m);
      return E === y ? E.clone() : E;
    }, xe.prototype.convertFrom = function(y) {
      var E = y.clone();
      return E.red = null, E;
    }, S.mont = function(y) {
      return new rt(y);
    };
    function rt(N) {
      xe.call(this, N), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new S(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    T(rt, xe), rt.prototype.convertTo = function(y) {
      return this.imod(y.ushln(this.shift));
    }, rt.prototype.convertFrom = function(y) {
      var E = this.imod(y.mul(this.rinv));
      return E.red = null, E;
    }, rt.prototype.imul = function(y, E) {
      if (y.isZero() || E.isZero())
        return y.words[0] = 0, y.length = 1, y;
      var A = y.imul(E), B = A.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), O = A.isub(B).iushrn(this.shift), C = O;
      return O.cmp(this.m) >= 0 ? C = O.isub(this.m) : O.cmpn(0) < 0 && (C = O.iadd(this.m)), C._forceRed(this);
    }, rt.prototype.mul = function(y, E) {
      if (y.isZero() || E.isZero()) return new S(0)._forceRed(this);
      var A = y.mul(E), B = A.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), O = A.isub(B).iushrn(this.shift), C = O;
      return O.cmp(this.m) >= 0 ? C = O.isub(this.m) : O.cmpn(0) < 0 && (C = O.iadd(this.m)), C._forceRed(this);
    }, rt.prototype.invm = function(y) {
      var E = this.imod(y._invmp(this.m).mul(this.r2));
      return E._forceRed(this);
    };
  })(w, commonjsGlobal);
})(bn$2);
var bnExports$2 = bn$2.exports, api = {}, vmBrowserify = {}, hasRequiredVmBrowserify;
function requireVmBrowserify() {
  return hasRequiredVmBrowserify || (hasRequiredVmBrowserify = 1, function(exports) {
    var indexOf = function(w, M) {
      if (w.indexOf) return w.indexOf(M);
      for (var x = 0; x < w.length; x++)
        if (w[x] === M) return x;
      return -1;
    }, Object_keys = function(w) {
      if (Object.keys) return Object.keys(w);
      var M = [];
      for (var x in w) M.push(x);
      return M;
    }, forEach = function(w, M) {
      if (w.forEach) return w.forEach(M);
      for (var x = 0; x < w.length; x++)
        M(w[x], x, w);
    }, defineProp = function() {
      try {
        return Object.defineProperty({}, "_", {}), function(w, M, x) {
          Object.defineProperty(w, M, {
            writable: !0,
            enumerable: !1,
            configurable: !0,
            value: x
          });
        };
      } catch {
        return function(M, x, $) {
          M[x] = $;
        };
      }
    }(), globals = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "EvalError",
      "Function",
      "Infinity",
      "JSON",
      "Math",
      "NaN",
      "Number",
      "Object",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "String",
      "SyntaxError",
      "TypeError",
      "URIError",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function(M) {
      if (!(this instanceof Script)) return new Script(M);
      this.code = M;
    };
    Script.prototype.runInContext = function(w) {
      if (!(w instanceof Context))
        throw new TypeError("needs a 'context' argument.");
      var M = document.createElement("iframe");
      M.style || (M.style = {}), M.style.display = "none", document.body.appendChild(M);
      var x = M.contentWindow, $ = x.eval, T = x.execScript;
      !$ && T && (T.call(x, "null"), $ = x.eval), forEach(Object_keys(w), function(F) {
        x[F] = w[F];
      }), forEach(globals, function(F) {
        w[F] && (x[F] = w[F]);
      });
      var S = Object_keys(x), D = $.call(x, this.code);
      return forEach(Object_keys(x), function(F) {
        (F in w || indexOf(S, F) === -1) && (w[F] = x[F]);
      }), forEach(globals, function(F) {
        F in w || defineProp(w, F, x[F]);
      }), document.body.removeChild(M), D;
    }, Script.prototype.runInThisContext = function() {
      return eval(this.code);
    }, Script.prototype.runInNewContext = function(w) {
      var M = Script.createContext(w), x = this.runInContext(M);
      return w && forEach(Object_keys(M), function($) {
        w[$] = M[$];
      }), x;
    }, forEach(Object_keys(Script.prototype), function(w) {
      exports[w] = Script[w] = function(M) {
        var x = Script(M);
        return x[w].apply(x, [].slice.call(arguments, 1));
      };
    }), exports.isContext = function(w) {
      return w instanceof Context;
    }, exports.createScript = function(w) {
      return exports.Script(w);
    }, exports.createContext = Script.createContext = function(w) {
      var M = new Context();
      return typeof w == "object" && forEach(Object_keys(w), function(x) {
        M[x] = w[x];
      }), M;
    };
  }(vmBrowserify)), vmBrowserify;
}
var hasRequiredApi;
function requireApi() {
  return hasRequiredApi || (hasRequiredApi = 1, function(w) {
    var M = requireAsn1(), x = inherits_browserExports, $ = w;
    $.define = function(D, F) {
      return new T(D, F);
    };
    function T(S, D) {
      this.name = S, this.body = D, this.decoders = {}, this.encoders = {};
    }
    T.prototype._createNamed = function(D) {
      var F;
      try {
        F = requireVmBrowserify().runInThisContext(
          "(function " + this.name + `(entity) {
  this._initNamed(entity);
})`
        );
      } catch {
        F = function(Z) {
          this._initNamed(Z);
        };
      }
      return x(F, D), F.prototype._initNamed = function(Z) {
        D.call(this, Z);
      }, new F(this);
    }, T.prototype._getDecoder = function(D) {
      return D = D || "der", this.decoders.hasOwnProperty(D) || (this.decoders[D] = this._createNamed(M.decoders[D])), this.decoders[D];
    }, T.prototype.decode = function(D, F, z) {
      return this._getDecoder(F).decode(D, z);
    }, T.prototype._getEncoder = function(D) {
      return D = D || "der", this.encoders.hasOwnProperty(D) || (this.encoders[D] = this._createNamed(M.encoders[D])), this.encoders[D];
    }, T.prototype.encode = function(D, F, z) {
      return this._getEncoder(F).encode(D, z);
    };
  }(api)), api;
}
var base = {}, reporter = {}, inherits = inherits_browserExports;
function Reporter(w) {
  this._reporterState = {
    obj: null,
    path: [],
    options: w || {},
    errors: []
  };
}
reporter.Reporter = Reporter;
Reporter.prototype.isError = function w(M) {
  return M instanceof ReporterError;
};
Reporter.prototype.save = function w() {
  var M = this._reporterState;
  return { obj: M.obj, pathLen: M.path.length };
};
Reporter.prototype.restore = function w(M) {
  var x = this._reporterState;
  x.obj = M.obj, x.path = x.path.slice(0, M.pathLen);
};
Reporter.prototype.enterKey = function w(M) {
  return this._reporterState.path.push(M);
};
Reporter.prototype.exitKey = function w(M) {
  var x = this._reporterState;
  x.path = x.path.slice(0, M - 1);
};
Reporter.prototype.leaveKey = function w(M, x, $) {
  var T = this._reporterState;
  this.exitKey(M), T.obj !== null && (T.obj[x] = $);
};
Reporter.prototype.path = function w() {
  return this._reporterState.path.join("/");
};
Reporter.prototype.enterObject = function w() {
  var M = this._reporterState, x = M.obj;
  return M.obj = {}, x;
};
Reporter.prototype.leaveObject = function w(M) {
  var x = this._reporterState, $ = x.obj;
  return x.obj = M, $;
};
Reporter.prototype.error = function w(M) {
  var x, $ = this._reporterState, T = M instanceof ReporterError;
  if (T ? x = M : x = new ReporterError($.path.map(function(S) {
    return "[" + JSON.stringify(S) + "]";
  }).join(""), M.message || M, M.stack), !$.options.partial)
    throw x;
  return T || $.errors.push(x), x;
};
Reporter.prototype.wrapResult = function w(M) {
  var x = this._reporterState;
  return x.options.partial ? {
    result: this.isError(M) ? null : M,
    errors: x.errors
  } : M;
};
function ReporterError(w, M) {
  this.path = w, this.rethrow(M);
}
inherits(ReporterError, Error);
ReporterError.prototype.rethrow = function w(M) {
  if (this.message = M + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, ReporterError), !this.stack)
    try {
      throw new Error(this.message);
    } catch (x) {
      this.stack = x.stack;
    }
  return this;
};
var buffer = {}, hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer) return buffer;
  hasRequiredBuffer = 1;
  var w = inherits_browserExports, M = requireBase().Reporter, x = dist.Buffer;
  function $(S, D) {
    if (M.call(this, D), !x.isBuffer(S)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = S, this.offset = 0, this.length = S.length;
  }
  w($, M), buffer.DecoderBuffer = $, $.prototype.save = function() {
    return { offset: this.offset, reporter: M.prototype.save.call(this) };
  }, $.prototype.restore = function(D) {
    var F = new $(this.base);
    return F.offset = D.offset, F.length = this.offset, this.offset = D.offset, M.prototype.restore.call(this, D.reporter), F;
  }, $.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, $.prototype.readUInt8 = function(D) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(D || "DecoderBuffer overrun");
  }, $.prototype.skip = function(D, F) {
    if (!(this.offset + D <= this.length))
      return this.error(F || "DecoderBuffer overrun");
    var z = new $(this.base);
    return z._reporterState = this._reporterState, z.offset = this.offset, z.length = this.offset + D, this.offset += D, z;
  }, $.prototype.raw = function(D) {
    return this.base.slice(D ? D.offset : this.offset, this.length);
  };
  function T(S, D) {
    if (Array.isArray(S))
      this.length = 0, this.value = S.map(function(F) {
        return F instanceof T || (F = new T(F, D)), this.length += F.length, F;
      }, this);
    else if (typeof S == "number") {
      if (!(0 <= S && S <= 255))
        return D.error("non-byte EncoderBuffer value");
      this.value = S, this.length = 1;
    } else if (typeof S == "string")
      this.value = S, this.length = x.byteLength(S);
    else if (x.isBuffer(S))
      this.value = S, this.length = S.length;
    else
      return D.error("Unsupported type: " + typeof S);
  }
  return buffer.EncoderBuffer = T, T.prototype.join = function(D, F) {
    return D || (D = new x(this.length)), F || (F = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(z) {
      z.join(D, F), F += z.length;
    }) : (typeof this.value == "number" ? D[F] = this.value : typeof this.value == "string" ? D.write(this.value, F) : x.isBuffer(this.value) && this.value.copy(D, F), F += this.length)), D;
  }, buffer;
}
var node, hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node;
  hasRequiredNode = 1;
  var w = requireBase().Reporter, M = requireBase().EncoderBuffer, x = requireBase().DecoderBuffer, $ = minimalisticAssert, T = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], S = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(T), D = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function F(Z, H) {
    var V = {};
    this._baseState = V, V.enc = Z, V.parent = H || null, V.children = null, V.tag = null, V.args = null, V.reverseArgs = null, V.choice = null, V.optional = !1, V.any = !1, V.obj = !1, V.use = null, V.useDecoder = null, V.key = null, V.default = null, V.explicit = null, V.implicit = null, V.contains = null, V.parent || (V.children = [], this._wrap());
  }
  node = F;
  var z = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  return F.prototype.clone = function() {
    var H = this._baseState, V = {};
    z.forEach(function(Q) {
      V[Q] = H[Q];
    });
    var X = new this.constructor(V.parent);
    return X._baseState = V, X;
  }, F.prototype._wrap = function() {
    var H = this._baseState;
    S.forEach(function(V) {
      this[V] = function() {
        var Q = new this.constructor(this);
        return H.children.push(Q), Q[V].apply(Q, arguments);
      };
    }, this);
  }, F.prototype._init = function(H) {
    var V = this._baseState;
    $(V.parent === null), H.call(this), V.children = V.children.filter(function(X) {
      return X._baseState.parent === this;
    }, this), $.equal(V.children.length, 1, "Root node can have only one child");
  }, F.prototype._useArgs = function(H) {
    var V = this._baseState, X = H.filter(function(Q) {
      return Q instanceof this.constructor;
    }, this);
    H = H.filter(function(Q) {
      return !(Q instanceof this.constructor);
    }, this), X.length !== 0 && ($(V.children === null), V.children = X, X.forEach(function(Q) {
      Q._baseState.parent = this;
    }, this)), H.length !== 0 && ($(V.args === null), V.args = H, V.reverseArgs = H.map(function(Q) {
      if (typeof Q != "object" || Q.constructor !== Object)
        return Q;
      var fe = {};
      return Object.keys(Q).forEach(function(ce) {
        ce == (ce | 0) && (ce |= 0);
        var me = Q[ce];
        fe[me] = ce;
      }), fe;
    }));
  }, D.forEach(function(Z) {
    F.prototype[Z] = function() {
      var V = this._baseState;
      throw new Error(Z + " not implemented for encoding: " + V.enc);
    };
  }), T.forEach(function(Z) {
    F.prototype[Z] = function() {
      var V = this._baseState, X = Array.prototype.slice.call(arguments);
      return $(V.tag === null), V.tag = Z, this._useArgs(X), this;
    };
  }), F.prototype.use = function(H) {
    $(H);
    var V = this._baseState;
    return $(V.use === null), V.use = H, this;
  }, F.prototype.optional = function() {
    var H = this._baseState;
    return H.optional = !0, this;
  }, F.prototype.def = function(H) {
    var V = this._baseState;
    return $(V.default === null), V.default = H, V.optional = !0, this;
  }, F.prototype.explicit = function(H) {
    var V = this._baseState;
    return $(V.explicit === null && V.implicit === null), V.explicit = H, this;
  }, F.prototype.implicit = function(H) {
    var V = this._baseState;
    return $(V.explicit === null && V.implicit === null), V.implicit = H, this;
  }, F.prototype.obj = function() {
    var H = this._baseState, V = Array.prototype.slice.call(arguments);
    return H.obj = !0, V.length !== 0 && this._useArgs(V), this;
  }, F.prototype.key = function(H) {
    var V = this._baseState;
    return $(V.key === null), V.key = H, this;
  }, F.prototype.any = function() {
    var H = this._baseState;
    return H.any = !0, this;
  }, F.prototype.choice = function(H) {
    var V = this._baseState;
    return $(V.choice === null), V.choice = H, this._useArgs(Object.keys(H).map(function(X) {
      return H[X];
    })), this;
  }, F.prototype.contains = function(H) {
    var V = this._baseState;
    return $(V.use === null), V.contains = H, this;
  }, F.prototype._decode = function(H, V) {
    var X = this._baseState;
    if (X.parent === null)
      return H.wrapResult(X.children[0]._decode(H, V));
    var Q = X.default, fe = !0, ce = null;
    if (X.key !== null && (ce = H.enterKey(X.key)), X.optional) {
      var me = null;
      if (X.explicit !== null ? me = X.explicit : X.implicit !== null ? me = X.implicit : X.tag !== null && (me = X.tag), me === null && !X.any) {
        var de = H.save();
        try {
          X.choice === null ? this._decodeGeneric(X.tag, H, V) : this._decodeChoice(H, V), fe = !0;
        } catch {
          fe = !1;
        }
        H.restore(de);
      } else if (fe = this._peekTag(H, me, X.any), H.isError(fe))
        return fe;
    }
    var ne;
    if (X.obj && fe && (ne = H.enterObject()), fe) {
      if (X.explicit !== null) {
        var ge = this._decodeTag(H, X.explicit);
        if (H.isError(ge))
          return ge;
        H = ge;
      }
      var pe = H.offset;
      if (X.use === null && X.choice === null) {
        if (X.any)
          var de = H.save();
        var $e = this._decodeTag(
          H,
          X.implicit !== null ? X.implicit : X.tag,
          X.any
        );
        if (H.isError($e))
          return $e;
        X.any ? Q = H.raw(de) : H = $e;
      }
      if (V && V.track && X.tag !== null && V.track(H.path(), pe, H.length, "tagged"), V && V.track && X.tag !== null && V.track(H.path(), H.offset, H.length, "content"), X.any ? Q = Q : X.choice === null ? Q = this._decodeGeneric(X.tag, H, V) : Q = this._decodeChoice(H, V), H.isError(Q))
        return Q;
      if (!X.any && X.choice === null && X.children !== null && X.children.forEach(function(Oe) {
        Oe._decode(H, V);
      }), X.contains && (X.tag === "octstr" || X.tag === "bitstr")) {
        var Re = new x(Q);
        Q = this._getUse(X.contains, H._reporterState.obj)._decode(Re, V);
      }
    }
    return X.obj && fe && (Q = H.leaveObject(ne)), X.key !== null && (Q !== null || fe === !0) ? H.leaveKey(ce, X.key, Q) : ce !== null && H.exitKey(ce), Q;
  }, F.prototype._decodeGeneric = function(H, V, X) {
    var Q = this._baseState;
    return H === "seq" || H === "set" ? null : H === "seqof" || H === "setof" ? this._decodeList(V, H, Q.args[0], X) : /str$/.test(H) ? this._decodeStr(V, H, X) : H === "objid" && Q.args ? this._decodeObjid(V, Q.args[0], Q.args[1], X) : H === "objid" ? this._decodeObjid(V, null, null, X) : H === "gentime" || H === "utctime" ? this._decodeTime(V, H, X) : H === "null_" ? this._decodeNull(V, X) : H === "bool" ? this._decodeBool(V, X) : H === "objDesc" ? this._decodeStr(V, H, X) : H === "int" || H === "enum" ? this._decodeInt(V, Q.args && Q.args[0], X) : Q.use !== null ? this._getUse(Q.use, V._reporterState.obj)._decode(V, X) : V.error("unknown tag: " + H);
  }, F.prototype._getUse = function(H, V) {
    var X = this._baseState;
    return X.useDecoder = this._use(H, V), $(X.useDecoder._baseState.parent === null), X.useDecoder = X.useDecoder._baseState.children[0], X.implicit !== X.useDecoder._baseState.implicit && (X.useDecoder = X.useDecoder.clone(), X.useDecoder._baseState.implicit = X.implicit), X.useDecoder;
  }, F.prototype._decodeChoice = function(H, V) {
    var X = this._baseState, Q = null, fe = !1;
    return Object.keys(X.choice).some(function(ce) {
      var me = H.save(), de = X.choice[ce];
      try {
        var ne = de._decode(H, V);
        if (H.isError(ne))
          return !1;
        Q = { type: ce, value: ne }, fe = !0;
      } catch {
        return H.restore(me), !1;
      }
      return !0;
    }, this), fe ? Q : H.error("Choice not matched");
  }, F.prototype._createEncoderBuffer = function(H) {
    return new M(H, this.reporter);
  }, F.prototype._encode = function(H, V, X) {
    var Q = this._baseState;
    if (!(Q.default !== null && Q.default === H)) {
      var fe = this._encodeValue(H, V, X);
      if (fe !== void 0 && !this._skipDefault(fe, V, X))
        return fe;
    }
  }, F.prototype._encodeValue = function(H, V, X) {
    var Q = this._baseState;
    if (Q.parent === null)
      return Q.children[0]._encode(H, V || new w());
    var de = null;
    if (this.reporter = V, Q.optional && H === void 0)
      if (Q.default !== null)
        H = Q.default;
      else
        return;
    var fe = null, ce = !1;
    if (Q.any)
      de = this._createEncoderBuffer(H);
    else if (Q.choice)
      de = this._encodeChoice(H, V);
    else if (Q.contains)
      fe = this._getUse(Q.contains, X)._encode(H, V), ce = !0;
    else if (Q.children)
      fe = Q.children.map(function(pe) {
        if (pe._baseState.tag === "null_")
          return pe._encode(null, V, H);
        if (pe._baseState.key === null)
          return V.error("Child should have a key");
        var $e = V.enterKey(pe._baseState.key);
        if (typeof H != "object")
          return V.error("Child expected, but input is not object");
        var Re = pe._encode(H[pe._baseState.key], V, H);
        return V.leaveKey($e), Re;
      }, this).filter(function(pe) {
        return pe;
      }), fe = this._createEncoderBuffer(fe);
    else if (Q.tag === "seqof" || Q.tag === "setof") {
      if (!(Q.args && Q.args.length === 1))
        return V.error("Too many args for : " + Q.tag);
      if (!Array.isArray(H))
        return V.error("seqof/setof, but data is not Array");
      var me = this.clone();
      me._baseState.implicit = null, fe = this._createEncoderBuffer(H.map(function(pe) {
        var $e = this._baseState;
        return this._getUse($e.args[0], H)._encode(pe, V);
      }, me));
    } else Q.use !== null ? de = this._getUse(Q.use, X)._encode(H, V) : (fe = this._encodePrimitive(Q.tag, H), ce = !0);
    var de;
    if (!Q.any && Q.choice === null) {
      var ne = Q.implicit !== null ? Q.implicit : Q.tag, ge = Q.implicit === null ? "universal" : "context";
      ne === null ? Q.use === null && V.error("Tag could be omitted only for .use()") : Q.use === null && (de = this._encodeComposite(ne, ce, ge, fe));
    }
    return Q.explicit !== null && (de = this._encodeComposite(Q.explicit, !1, "context", de)), de;
  }, F.prototype._encodeChoice = function(H, V) {
    var X = this._baseState, Q = X.choice[H.type];
    return Q || $(
      !1,
      H.type + " not found in " + JSON.stringify(Object.keys(X.choice))
    ), Q._encode(H.value, V);
  }, F.prototype._encodePrimitive = function(H, V) {
    var X = this._baseState;
    if (/str$/.test(H))
      return this._encodeStr(V, H);
    if (H === "objid" && X.args)
      return this._encodeObjid(V, X.reverseArgs[0], X.args[1]);
    if (H === "objid")
      return this._encodeObjid(V, null, null);
    if (H === "gentime" || H === "utctime")
      return this._encodeTime(V, H);
    if (H === "null_")
      return this._encodeNull();
    if (H === "int" || H === "enum")
      return this._encodeInt(V, X.args && X.reverseArgs[0]);
    if (H === "bool")
      return this._encodeBool(V);
    if (H === "objDesc")
      return this._encodeStr(V, H);
    throw new Error("Unsupported tag: " + H);
  }, F.prototype._isNumstr = function(H) {
    return /^[0-9 ]*$/.test(H);
  }, F.prototype._isPrintstr = function(H) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(H);
  }, node;
}
var hasRequiredBase;
function requireBase() {
  return hasRequiredBase || (hasRequiredBase = 1, function(w) {
    var M = w;
    M.Reporter = reporter.Reporter, M.DecoderBuffer = requireBuffer().DecoderBuffer, M.EncoderBuffer = requireBuffer().EncoderBuffer, M.Node = requireNode();
  }(base)), base;
}
var constants = {}, der = {}, hasRequiredDer$2;
function requireDer$2() {
  return hasRequiredDer$2 || (hasRequiredDer$2 = 1, function(w) {
    var M = requireConstants();
    w.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, w.tagClassByName = M._reverse(w.tagClass), w.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, w.tagByName = M._reverse(w.tag);
  }(der)), der;
}
var hasRequiredConstants;
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, function(w) {
    var M = w;
    M._reverse = function($) {
      var T = {};
      return Object.keys($).forEach(function(S) {
        (S | 0) == S && (S = S | 0);
        var D = $[S];
        T[D] = S;
      }), T;
    }, M.der = requireDer$2();
  }(constants)), constants;
}
var decoders = {}, der_1$1, hasRequiredDer$1;
function requireDer$1() {
  if (hasRequiredDer$1) return der_1$1;
  hasRequiredDer$1 = 1;
  var w = inherits_browserExports, M = requireAsn1(), x = M.base, $ = M.bignum, T = M.constants.der;
  function S(Z) {
    this.enc = "der", this.name = Z.name, this.entity = Z, this.tree = new D(), this.tree._init(Z.body);
  }
  der_1$1 = S, S.prototype.decode = function(H, V) {
    return H instanceof x.DecoderBuffer || (H = new x.DecoderBuffer(H, V)), this.tree._decode(H, V);
  };
  function D(Z) {
    x.Node.call(this, "der", Z);
  }
  w(D, x.Node), D.prototype._peekTag = function(H, V, X) {
    if (H.isEmpty())
      return !1;
    var Q = H.save(), fe = F(H, 'Failed to peek tag: "' + V + '"');
    return H.isError(fe) ? fe : (H.restore(Q), fe.tag === V || fe.tagStr === V || fe.tagStr + "of" === V || X);
  }, D.prototype._decodeTag = function(H, V, X) {
    var Q = F(
      H,
      'Failed to decode tag of "' + V + '"'
    );
    if (H.isError(Q))
      return Q;
    var fe = z(
      H,
      Q.primitive,
      'Failed to get length of "' + V + '"'
    );
    if (H.isError(fe))
      return fe;
    if (!X && Q.tag !== V && Q.tagStr !== V && Q.tagStr + "of" !== V)
      return H.error('Failed to match tag: "' + V + '"');
    if (Q.primitive || fe !== null)
      return H.skip(fe, 'Failed to match body of: "' + V + '"');
    var ce = H.save(), me = this._skipUntilEnd(
      H,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    return H.isError(me) ? me : (fe = H.offset - ce.offset, H.restore(ce), H.skip(fe, 'Failed to match body of: "' + V + '"'));
  }, D.prototype._skipUntilEnd = function(H, V) {
    for (; ; ) {
      var X = F(H, V);
      if (H.isError(X))
        return X;
      var Q = z(H, X.primitive, V);
      if (H.isError(Q))
        return Q;
      var fe;
      if (X.primitive || Q !== null ? fe = H.skip(Q) : fe = this._skipUntilEnd(H, V), H.isError(fe))
        return fe;
      if (X.tagStr === "end")
        break;
    }
  }, D.prototype._decodeList = function(H, V, X, Q) {
    for (var fe = []; !H.isEmpty(); ) {
      var ce = this._peekTag(H, "end");
      if (H.isError(ce))
        return ce;
      var me = X.decode(H, "der", Q);
      if (H.isError(me) && ce)
        break;
      fe.push(me);
    }
    return fe;
  }, D.prototype._decodeStr = function(H, V) {
    if (V === "bitstr") {
      var X = H.readUInt8();
      return H.isError(X) ? X : { unused: X, data: H.raw() };
    } else if (V === "bmpstr") {
      var Q = H.raw();
      if (Q.length % 2 === 1)
        return H.error("Decoding of string type: bmpstr length mismatch");
      for (var fe = "", ce = 0; ce < Q.length / 2; ce++)
        fe += String.fromCharCode(Q.readUInt16BE(ce * 2));
      return fe;
    } else if (V === "numstr") {
      var me = H.raw().toString("ascii");
      return this._isNumstr(me) ? me : H.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (V === "octstr")
        return H.raw();
      if (V === "objDesc")
        return H.raw();
      if (V === "printstr") {
        var de = H.raw().toString("ascii");
        return this._isPrintstr(de) ? de : H.error("Decoding of string type: printstr unsupported characters");
      } else return /str$/.test(V) ? H.raw().toString() : H.error("Decoding of string type: " + V + " unsupported");
    }
  }, D.prototype._decodeObjid = function(H, V, X) {
    for (var Q, fe = [], ce = 0; !H.isEmpty(); ) {
      var me = H.readUInt8();
      ce <<= 7, ce |= me & 127, me & 128 || (fe.push(ce), ce = 0);
    }
    me & 128 && fe.push(ce);
    var de = fe[0] / 40 | 0, ne = fe[0] % 40;
    if (X ? Q = fe : Q = [de, ne].concat(fe.slice(1)), V) {
      var ge = V[Q.join(" ")];
      ge === void 0 && (ge = V[Q.join(".")]), ge !== void 0 && (Q = ge);
    }
    return Q;
  }, D.prototype._decodeTime = function(H, V) {
    var X = H.raw().toString();
    if (V === "gentime")
      var Q = X.slice(0, 4) | 0, fe = X.slice(4, 6) | 0, ce = X.slice(6, 8) | 0, me = X.slice(8, 10) | 0, de = X.slice(10, 12) | 0, ne = X.slice(12, 14) | 0;
    else if (V === "utctime") {
      var Q = X.slice(0, 2) | 0, fe = X.slice(2, 4) | 0, ce = X.slice(4, 6) | 0, me = X.slice(6, 8) | 0, de = X.slice(8, 10) | 0, ne = X.slice(10, 12) | 0;
      Q < 70 ? Q = 2e3 + Q : Q = 1900 + Q;
    } else
      return H.error("Decoding " + V + " time is not supported yet");
    return Date.UTC(Q, fe - 1, ce, me, de, ne, 0);
  }, D.prototype._decodeNull = function(H) {
    return null;
  }, D.prototype._decodeBool = function(H) {
    var V = H.readUInt8();
    return H.isError(V) ? V : V !== 0;
  }, D.prototype._decodeInt = function(H, V) {
    var X = H.raw(), Q = new $(X);
    return V && (Q = V[Q.toString(10)] || Q), Q;
  }, D.prototype._use = function(H, V) {
    return typeof H == "function" && (H = H(V)), H._getDecoder("der").tree;
  };
  function F(Z, H) {
    var V = Z.readUInt8(H);
    if (Z.isError(V))
      return V;
    var X = T.tagClass[V >> 6], Q = (V & 32) === 0;
    if ((V & 31) === 31) {
      var fe = V;
      for (V = 0; (fe & 128) === 128; ) {
        if (fe = Z.readUInt8(H), Z.isError(fe))
          return fe;
        V <<= 7, V |= fe & 127;
      }
    } else
      V &= 31;
    var ce = T.tag[V];
    return {
      cls: X,
      primitive: Q,
      tag: V,
      tagStr: ce
    };
  }
  function z(Z, H, V) {
    var X = Z.readUInt8(V);
    if (Z.isError(X))
      return X;
    if (!H && X === 128)
      return null;
    if (!(X & 128))
      return X;
    var Q = X & 127;
    if (Q > 4)
      return Z.error("length octect is too long");
    X = 0;
    for (var fe = 0; fe < Q; fe++) {
      X <<= 8;
      var ce = Z.readUInt8(V);
      if (Z.isError(ce))
        return ce;
      X |= ce;
    }
    return X;
  }
  return der_1$1;
}
var pem$1, hasRequiredPem$1;
function requirePem$1() {
  if (hasRequiredPem$1) return pem$1;
  hasRequiredPem$1 = 1;
  var w = inherits_browserExports, M = dist.Buffer, x = requireDer$1();
  function $(T) {
    x.call(this, T), this.enc = "pem";
  }
  return w($, x), pem$1 = $, $.prototype.decode = function(S, D) {
    for (var F = S.toString().split(/[\r\n]+/g), z = D.label.toUpperCase(), Z = /^-----(BEGIN|END) ([^-]+)-----$/, H = -1, V = -1, X = 0; X < F.length; X++) {
      var Q = F[X].match(Z);
      if (Q !== null && Q[2] === z)
        if (H === -1) {
          if (Q[1] !== "BEGIN")
            break;
          H = X;
        } else {
          if (Q[1] !== "END")
            break;
          V = X;
          break;
        }
    }
    if (H === -1 || V === -1)
      throw new Error("PEM section not found for: " + z);
    var fe = F.slice(H + 1, V).join("");
    fe.replace(/[^a-z0-9\+\/=]+/gi, "");
    var ce = new M(fe, "base64");
    return x.prototype.decode.call(this, ce, D);
  }, pem$1;
}
var hasRequiredDecoders;
function requireDecoders() {
  return hasRequiredDecoders || (hasRequiredDecoders = 1, function(w) {
    var M = w;
    M.der = requireDer$1(), M.pem = requirePem$1();
  }(decoders)), decoders;
}
var encoders = {}, der_1, hasRequiredDer;
function requireDer() {
  if (hasRequiredDer) return der_1;
  hasRequiredDer = 1;
  var w = inherits_browserExports, M = dist.Buffer, x = requireAsn1(), $ = x.base, T = x.constants.der;
  function S(Z) {
    this.enc = "der", this.name = Z.name, this.entity = Z, this.tree = new D(), this.tree._init(Z.body);
  }
  der_1 = S, S.prototype.encode = function(H, V) {
    return this.tree._encode(H, V).join();
  };
  function D(Z) {
    $.Node.call(this, "der", Z);
  }
  w(D, $.Node), D.prototype._encodeComposite = function(H, V, X, Q) {
    var fe = z(H, V, X, this.reporter);
    if (Q.length < 128) {
      var de = new M(2);
      return de[0] = fe, de[1] = Q.length, this._createEncoderBuffer([de, Q]);
    }
    for (var ce = 1, me = Q.length; me >= 256; me >>= 8)
      ce++;
    var de = new M(2 + ce);
    de[0] = fe, de[1] = 128 | ce;
    for (var me = 1 + ce, ne = Q.length; ne > 0; me--, ne >>= 8)
      de[me] = ne & 255;
    return this._createEncoderBuffer([de, Q]);
  }, D.prototype._encodeStr = function(H, V) {
    if (V === "bitstr")
      return this._createEncoderBuffer([H.unused | 0, H.data]);
    if (V === "bmpstr") {
      for (var X = new M(H.length * 2), Q = 0; Q < H.length; Q++)
        X.writeUInt16BE(H.charCodeAt(Q), Q * 2);
      return this._createEncoderBuffer(X);
    } else return V === "numstr" ? this._isNumstr(H) ? this._createEncoderBuffer(H) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : V === "printstr" ? this._isPrintstr(H) ? this._createEncoderBuffer(H) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(V) ? this._createEncoderBuffer(H) : V === "objDesc" ? this._createEncoderBuffer(H) : this.reporter.error("Encoding of string type: " + V + " unsupported");
  }, D.prototype._encodeObjid = function(H, V, X) {
    if (typeof H == "string") {
      if (!V)
        return this.reporter.error("string objid given, but no values map found");
      if (!V.hasOwnProperty(H))
        return this.reporter.error("objid not found in values map");
      H = V[H].split(/[\s\.]+/g);
      for (var Q = 0; Q < H.length; Q++)
        H[Q] |= 0;
    } else if (Array.isArray(H)) {
      H = H.slice();
      for (var Q = 0; Q < H.length; Q++)
        H[Q] |= 0;
    }
    if (!Array.isArray(H))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(H));
    if (!X) {
      if (H[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      H.splice(0, 2, H[0] * 40 + H[1]);
    }
    for (var fe = 0, Q = 0; Q < H.length; Q++) {
      var ce = H[Q];
      for (fe++; ce >= 128; ce >>= 7)
        fe++;
    }
    for (var me = new M(fe), de = me.length - 1, Q = H.length - 1; Q >= 0; Q--) {
      var ce = H[Q];
      for (me[de--] = ce & 127; (ce >>= 7) > 0; )
        me[de--] = 128 | ce & 127;
    }
    return this._createEncoderBuffer(me);
  };
  function F(Z) {
    return Z < 10 ? "0" + Z : Z;
  }
  D.prototype._encodeTime = function(H, V) {
    var X, Q = new Date(H);
    return V === "gentime" ? X = [
      F(Q.getFullYear()),
      F(Q.getUTCMonth() + 1),
      F(Q.getUTCDate()),
      F(Q.getUTCHours()),
      F(Q.getUTCMinutes()),
      F(Q.getUTCSeconds()),
      "Z"
    ].join("") : V === "utctime" ? X = [
      F(Q.getFullYear() % 100),
      F(Q.getUTCMonth() + 1),
      F(Q.getUTCDate()),
      F(Q.getUTCHours()),
      F(Q.getUTCMinutes()),
      F(Q.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + V + " time is not supported yet"), this._encodeStr(X, "octstr");
  }, D.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, D.prototype._encodeInt = function(H, V) {
    if (typeof H == "string") {
      if (!V)
        return this.reporter.error("String int or enum given, but no values map");
      if (!V.hasOwnProperty(H))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(H));
      H = V[H];
    }
    if (typeof H != "number" && !M.isBuffer(H)) {
      var X = H.toArray();
      !H.sign && X[0] & 128 && X.unshift(0), H = new M(X);
    }
    if (M.isBuffer(H)) {
      var Q = H.length;
      H.length === 0 && Q++;
      var ce = new M(Q);
      return H.copy(ce), H.length === 0 && (ce[0] = 0), this._createEncoderBuffer(ce);
    }
    if (H < 128)
      return this._createEncoderBuffer(H);
    if (H < 256)
      return this._createEncoderBuffer([0, H]);
    for (var Q = 1, fe = H; fe >= 256; fe >>= 8)
      Q++;
    for (var ce = new Array(Q), fe = ce.length - 1; fe >= 0; fe--)
      ce[fe] = H & 255, H >>= 8;
    return ce[0] & 128 && ce.unshift(0), this._createEncoderBuffer(new M(ce));
  }, D.prototype._encodeBool = function(H) {
    return this._createEncoderBuffer(H ? 255 : 0);
  }, D.prototype._use = function(H, V) {
    return typeof H == "function" && (H = H(V)), H._getEncoder("der").tree;
  }, D.prototype._skipDefault = function(H, V, X) {
    var Q = this._baseState, fe;
    if (Q.default === null)
      return !1;
    var ce = H.join();
    if (Q.defaultBuffer === void 0 && (Q.defaultBuffer = this._encodeValue(Q.default, V, X).join()), ce.length !== Q.defaultBuffer.length)
      return !1;
    for (fe = 0; fe < ce.length; fe++)
      if (ce[fe] !== Q.defaultBuffer[fe])
        return !1;
    return !0;
  };
  function z(Z, H, V, X) {
    var Q;
    if (Z === "seqof" ? Z = "seq" : Z === "setof" && (Z = "set"), T.tagByName.hasOwnProperty(Z))
      Q = T.tagByName[Z];
    else if (typeof Z == "number" && (Z | 0) === Z)
      Q = Z;
    else
      return X.error("Unknown tag: " + Z);
    return Q >= 31 ? X.error("Multi-octet tag encoding unsupported") : (H || (Q |= 32), Q |= T.tagClassByName[V || "universal"] << 6, Q);
  }
  return der_1;
}
var pem, hasRequiredPem;
function requirePem() {
  if (hasRequiredPem) return pem;
  hasRequiredPem = 1;
  var w = inherits_browserExports, M = requireDer();
  function x($) {
    M.call(this, $), this.enc = "pem";
  }
  return w(x, M), pem = x, x.prototype.encode = function(T, S) {
    for (var D = M.prototype.encode.call(this, T), F = D.toString("base64"), z = ["-----BEGIN " + S.label + "-----"], Z = 0; Z < F.length; Z += 64)
      z.push(F.slice(Z, Z + 64));
    return z.push("-----END " + S.label + "-----"), z.join(`
`);
  }, pem;
}
var hasRequiredEncoders;
function requireEncoders() {
  return hasRequiredEncoders || (hasRequiredEncoders = 1, function(w) {
    var M = w;
    M.der = requireDer(), M.pem = requirePem();
  }(encoders)), encoders;
}
var hasRequiredAsn1;
function requireAsn1() {
  return hasRequiredAsn1 || (hasRequiredAsn1 = 1, function(w) {
    var M = w;
    M.bignum = bnExports$2, M.define = requireApi().define, M.base = requireBase(), M.constants = requireConstants(), M.decoders = requireDecoders(), M.encoders = requireEncoders();
  }(asn1$2)), asn1$2;
}
var asn = requireAsn1(), Time = asn.define("Time", function() {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  });
}), AttributeTypeValue = asn.define("AttributeTypeValue", function() {
  this.seq().obj(
    this.key("type").objid(),
    this.key("value").any()
  );
}), AlgorithmIdentifier$1 = asn.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("parameters").optional(),
    this.key("curve").objid().optional()
  );
}), SubjectPublicKeyInfo = asn.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(AlgorithmIdentifier$1),
    this.key("subjectPublicKey").bitstr()
  );
}), RelativeDistinguishedName = asn.define("RelativeDistinguishedName", function() {
  this.setof(AttributeTypeValue);
}), RDNSequence = asn.define("RDNSequence", function() {
  this.seqof(RelativeDistinguishedName);
}), Name = asn.define("Name", function() {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  });
}), Validity = asn.define("Validity", function() {
  this.seq().obj(
    this.key("notBefore").use(Time),
    this.key("notAfter").use(Time)
  );
}), Extension = asn.define("Extension", function() {
  this.seq().obj(
    this.key("extnID").objid(),
    this.key("critical").bool().def(!1),
    this.key("extnValue").octstr()
  );
}), TBSCertificate = asn.define("TBSCertificate", function() {
  this.seq().obj(
    this.key("version").explicit(0).int().optional(),
    this.key("serialNumber").int(),
    this.key("signature").use(AlgorithmIdentifier$1),
    this.key("issuer").use(Name),
    this.key("validity").use(Validity),
    this.key("subject").use(Name),
    this.key("subjectPublicKeyInfo").use(SubjectPublicKeyInfo),
    this.key("issuerUniqueID").implicit(1).bitstr().optional(),
    this.key("subjectUniqueID").implicit(2).bitstr().optional(),
    this.key("extensions").explicit(3).seqof(Extension).optional()
  );
}), X509Certificate = asn.define("X509Certificate", function() {
  this.seq().obj(
    this.key("tbsCertificate").use(TBSCertificate),
    this.key("signatureAlgorithm").use(AlgorithmIdentifier$1),
    this.key("signatureValue").bitstr()
  );
}), certificate = X509Certificate, asn1$1 = requireAsn1();
asn1$3.certificate = certificate;
var RSAPrivateKey = asn1$1.define("RSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("modulus").int(),
    this.key("publicExponent").int(),
    this.key("privateExponent").int(),
    this.key("prime1").int(),
    this.key("prime2").int(),
    this.key("exponent1").int(),
    this.key("exponent2").int(),
    this.key("coefficient").int()
  );
});
asn1$3.RSAPrivateKey = RSAPrivateKey;
var RSAPublicKey = asn1$1.define("RSAPublicKey", function() {
  this.seq().obj(
    this.key("modulus").int(),
    this.key("publicExponent").int()
  );
});
asn1$3.RSAPublicKey = RSAPublicKey;
var AlgorithmIdentifier = asn1$1.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("none").null_().optional(),
    this.key("curve").objid().optional(),
    this.key("params").seq().obj(
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int()
    ).optional()
  );
}), PublicKey = asn1$1.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(AlgorithmIdentifier),
    this.key("subjectPublicKey").bitstr()
  );
});
asn1$3.PublicKey = PublicKey;
var PrivateKeyInfo = asn1$1.define("PrivateKeyInfo", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("algorithm").use(AlgorithmIdentifier),
    this.key("subjectPrivateKey").octstr()
  );
});
asn1$3.PrivateKey = PrivateKeyInfo;
var EncryptedPrivateKeyInfo = asn1$1.define("EncryptedPrivateKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").seq().obj(
      this.key("id").objid(),
      this.key("decrypt").seq().obj(
        this.key("kde").seq().obj(
          this.key("id").objid(),
          this.key("kdeparams").seq().obj(
            this.key("salt").octstr(),
            this.key("iters").int()
          )
        ),
        this.key("cipher").seq().obj(
          this.key("algo").objid(),
          this.key("iv").octstr()
        )
      )
    ),
    this.key("subjectPrivateKey").octstr()
  );
});
asn1$3.EncryptedPrivateKey = EncryptedPrivateKeyInfo;
var DSAPrivateKey = asn1$1.define("DSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("p").int(),
    this.key("q").int(),
    this.key("g").int(),
    this.key("pub_key").int(),
    this.key("priv_key").int()
  );
});
asn1$3.DSAPrivateKey = DSAPrivateKey;
asn1$3.DSAparam = asn1$1.define("DSAparam", function() {
  this.int();
});
var ECParameters = asn1$1.define("ECParameters", function() {
  this.choice({
    namedCurve: this.objid()
  });
}), ECPrivateKey = asn1$1.define("ECPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("privateKey").octstr(),
    this.key("parameters").optional().explicit(0).use(ECParameters),
    this.key("publicKey").optional().explicit(1).bitstr()
  );
});
asn1$3.ECPrivateKey = ECPrivateKey;
asn1$3.signature = asn1$1.define("signature", function() {
  this.seq().obj(
    this.key("r").int(),
    this.key("s").int()
  );
});
const require$$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, evp = evp_bytestokey, ciphers$1 = browser$5, Buffer$6 = safeBufferExports$2.Buffer, fixProc$1 = function(w, M) {
  var x = w.toString(), $ = x.match(findProc), T;
  if ($) {
    var D = "aes" + $[1], F = Buffer$6.from($[2], "hex"), z = Buffer$6.from($[3].replace(/[\r\n]/g, ""), "base64"), Z = evp(M, F.slice(0, 8), parseInt($[1], 10)).key, H = [], V = ciphers$1.createDecipheriv(D, Z, F);
    H.push(V.update(z)), H.push(V.final()), T = Buffer$6.concat(H);
  } else {
    var S = x.match(fullRegex);
    T = Buffer$6.from(S[2].replace(/[\r\n]/g, ""), "base64");
  }
  var X = x.match(startRegex)[1];
  return {
    tag: X,
    data: T
  };
}, asn1 = asn1$3, aesid = require$$1, fixProc = fixProc$1, ciphers = browser$5, compat = browser$7, Buffer$5 = safeBufferExports$2.Buffer;
function decrypt$1(w, M) {
  var x = w.algorithm.decrypt.kde.kdeparams.salt, $ = parseInt(w.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), T = aesid[w.algorithm.decrypt.cipher.algo.join(".")], S = w.algorithm.decrypt.cipher.iv, D = w.subjectPrivateKey, F = parseInt(T.split("-")[1], 10) / 8, z = compat.pbkdf2Sync(M, x, $, F, "sha1"), Z = ciphers.createDecipheriv(T, z, S), H = [];
  return H.push(Z.update(D)), H.push(Z.final()), Buffer$5.concat(H);
}
function parseKeys$2(w) {
  var M;
  typeof w == "object" && !Buffer$5.isBuffer(w) && (M = w.passphrase, w = w.key), typeof w == "string" && (w = Buffer$5.from(w));
  var x = fixProc(w, M), $ = x.tag, T = x.data, S, D;
  switch ($) {
    case "CERTIFICATE":
      D = asn1.certificate.decode(T, "der").tbsCertificate.subjectPublicKeyInfo;
    case "PUBLIC KEY":
      switch (D || (D = asn1.PublicKey.decode(T, "der")), S = D.algorithm.algorithm.join("."), S) {
        case "1.2.840.113549.1.1.1":
          return asn1.RSAPublicKey.decode(D.subjectPublicKey.data, "der");
        case "1.2.840.10045.2.1":
          return D.subjectPrivateKey = D.subjectPublicKey, {
            type: "ec",
            data: D
          };
        case "1.2.840.10040.4.1":
          return D.algorithm.params.pub_key = asn1.DSAparam.decode(D.subjectPublicKey.data, "der"), {
            type: "dsa",
            data: D.algorithm.params
          };
        default:
          throw new Error("unknown key id " + S);
      }
    case "ENCRYPTED PRIVATE KEY":
      T = asn1.EncryptedPrivateKey.decode(T, "der"), T = decrypt$1(T, M);
    case "PRIVATE KEY":
      switch (D = asn1.PrivateKey.decode(T, "der"), S = D.algorithm.algorithm.join("."), S) {
        case "1.2.840.113549.1.1.1":
          return asn1.RSAPrivateKey.decode(D.subjectPrivateKey, "der");
        case "1.2.840.10045.2.1":
          return {
            curve: D.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(D.subjectPrivateKey, "der").privateKey
          };
        case "1.2.840.10040.4.1":
          return D.algorithm.params.priv_key = asn1.DSAparam.decode(D.subjectPrivateKey, "der"), {
            type: "dsa",
            params: D.algorithm.params
          };
        default:
          throw new Error("unknown key id " + S);
      }
    case "RSA PUBLIC KEY":
      return asn1.RSAPublicKey.decode(T, "der");
    case "RSA PRIVATE KEY":
      return asn1.RSAPrivateKey.decode(T, "der");
    case "DSA PRIVATE KEY":
      return {
        type: "dsa",
        params: asn1.DSAPrivateKey.decode(T, "der")
      };
    case "EC PRIVATE KEY":
      return T = asn1.ECPrivateKey.decode(T, "der"), {
        curve: T.parameters.value,
        privateKey: T.privateKey
      };
    default:
      throw new Error("unknown key type " + $);
  }
}
parseKeys$2.signature = asn1.signature;
var parseAsn1 = parseKeys$2;
const require$$4$1 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign) return sign.exports;
  hasRequiredSign = 1;
  var w = safeBufferExports$2.Buffer, M = browser$8, x = browserifyRsa, $ = requireElliptic().ec, T = bnExports$4, S = parseAsn1, D = require$$4$1, F = 1;
  function z(de, ne, ge, pe, $e) {
    var Re = S(ne);
    if (Re.curve) {
      if (pe !== "ecdsa" && pe !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return Z(de, Re);
    } else if (Re.type === "dsa") {
      if (pe !== "dsa")
        throw new Error("wrong private key type");
      return H(de, Re, ge);
    }
    if (pe !== "rsa" && pe !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (ne.padding !== void 0 && ne.padding !== F)
      throw new Error("illegal or unsupported padding mode");
    de = w.concat([$e, de]);
    for (var Pe = Re.modulus.byteLength(), Oe = [0, 1]; de.length + Oe.length + 1 < Pe; )
      Oe.push(255);
    Oe.push(0);
    for (var xe = -1; ++xe < de.length; )
      Oe.push(de[xe]);
    var rt = x(Oe, Re);
    return rt;
  }
  function Z(de, ne) {
    var ge = D[ne.curve.join(".")];
    if (!ge)
      throw new Error("unknown curve " + ne.curve.join("."));
    var pe = new $(ge), $e = pe.keyFromPrivate(ne.privateKey), Re = $e.sign(de);
    return w.from(Re.toDER());
  }
  function H(de, ne, ge) {
    for (var pe = ne.params.priv_key, $e = ne.params.p, Re = ne.params.q, Pe = ne.params.g, Oe = new T(0), xe, rt = Q(de, Re).mod(Re), N = !1, y = X(pe, Re, de, ge); N === !1; )
      xe = ce(Re, y, ge), Oe = me(Pe, xe, $e, Re), N = xe.invm(Re).imul(rt.add(pe.mul(Oe))).mod(Re), N.cmpn(0) === 0 && (N = !1, Oe = new T(0));
    return V(Oe, N);
  }
  function V(de, ne) {
    de = de.toArray(), ne = ne.toArray(), de[0] & 128 && (de = [0].concat(de)), ne[0] & 128 && (ne = [0].concat(ne));
    var ge = de.length + ne.length + 4, pe = [
      48,
      ge,
      2,
      de.length
    ];
    return pe = pe.concat(de, [2, ne.length], ne), w.from(pe);
  }
  function X(de, ne, ge, pe) {
    if (de = w.from(de.toArray()), de.length < ne.byteLength()) {
      var $e = w.alloc(ne.byteLength() - de.length);
      de = w.concat([$e, de]);
    }
    var Re = ge.length, Pe = fe(ge, ne), Oe = w.alloc(Re);
    Oe.fill(1);
    var xe = w.alloc(Re);
    return xe = M(pe, xe).update(Oe).update(w.from([0])).update(de).update(Pe).digest(), Oe = M(pe, xe).update(Oe).digest(), xe = M(pe, xe).update(Oe).update(w.from([1])).update(de).update(Pe).digest(), Oe = M(pe, xe).update(Oe).digest(), { k: xe, v: Oe };
  }
  function Q(de, ne) {
    var ge = new T(de), pe = (de.length << 3) - ne.bitLength();
    return pe > 0 && ge.ishrn(pe), ge;
  }
  function fe(de, ne) {
    de = Q(de, ne), de = de.mod(ne);
    var ge = w.from(de.toArray());
    if (ge.length < ne.byteLength()) {
      var pe = w.alloc(ne.byteLength() - ge.length);
      ge = w.concat([pe, ge]);
    }
    return ge;
  }
  function ce(de, ne, ge) {
    var pe, $e;
    do {
      for (pe = w.alloc(0); pe.length * 8 < de.bitLength(); )
        ne.v = M(ge, ne.k).update(ne.v).digest(), pe = w.concat([pe, ne.v]);
      $e = Q(pe, de), ne.k = M(ge, ne.k).update(ne.v).update(w.from([0])).digest(), ne.v = M(ge, ne.k).update(ne.v).digest();
    } while ($e.cmp(de) !== -1);
    return $e;
  }
  function me(de, ne, ge, pe) {
    return de.toRed(T.mont(ge)).redPow(ne).fromRed().mod(pe);
  }
  return sign.exports = z, sign.exports.getKey = X, sign.exports.makeKey = ce, sign.exports;
}
var verify_1, hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify) return verify_1;
  hasRequiredVerify = 1;
  var w = safeBufferExports$2.Buffer, M = bnExports$4, x = requireElliptic().ec, $ = parseAsn1, T = require$$4$1;
  function S(Z, H, V, X, Q) {
    var fe = $(V);
    if (fe.type === "ec") {
      if (X !== "ecdsa" && X !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return D(Z, H, fe);
    } else if (fe.type === "dsa") {
      if (X !== "dsa")
        throw new Error("wrong public key type");
      return F(Z, H, fe);
    }
    if (X !== "rsa" && X !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    H = w.concat([Q, H]);
    for (var ce = fe.modulus.byteLength(), me = [1], de = 0; H.length + me.length + 2 < ce; )
      me.push(255), de += 1;
    me.push(0);
    for (var ne = -1; ++ne < H.length; )
      me.push(H[ne]);
    me = w.from(me);
    var ge = M.mont(fe.modulus);
    Z = new M(Z).toRed(ge), Z = Z.redPow(new M(fe.publicExponent)), Z = w.from(Z.fromRed().toArray());
    var pe = de < 8 ? 1 : 0;
    for (ce = Math.min(Z.length, me.length), Z.length !== me.length && (pe = 1), ne = -1; ++ne < ce; )
      pe |= Z[ne] ^ me[ne];
    return pe === 0;
  }
  function D(Z, H, V) {
    var X = T[V.data.algorithm.curve.join(".")];
    if (!X)
      throw new Error("unknown curve " + V.data.algorithm.curve.join("."));
    var Q = new x(X), fe = V.data.subjectPrivateKey.data;
    return Q.verify(H, Z, fe);
  }
  function F(Z, H, V) {
    var X = V.data.p, Q = V.data.q, fe = V.data.g, ce = V.data.pub_key, me = $.signature.decode(Z, "der"), de = me.s, ne = me.r;
    z(de, Q), z(ne, Q);
    var ge = M.mont(X), pe = de.invm(Q), $e = fe.toRed(ge).redPow(new M(H).mul(pe).mod(Q)).fromRed().mul(ce.toRed(ge).redPow(ne.mul(pe).mod(Q)).fromRed()).mod(X).mod(Q);
    return $e.cmp(ne) === 0;
  }
  function z(Z, H) {
    if (Z.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (Z.cmp(H) >= 0)
      throw new Error("invalid sig");
  }
  return verify_1 = S, verify_1;
}
var browser$3, hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1) return browser$3;
  hasRequiredBrowser$1 = 1;
  var w = safeBufferExports$2.Buffer, M = browser$9, x = readableBrowserExports, $ = inherits_browserExports, T = requireSign(), S = requireVerify(), D = require$$6;
  Object.keys(D).forEach(function(V) {
    D[V].id = w.from(D[V].id, "hex"), D[V.toLowerCase()] = D[V];
  });
  function F(V) {
    x.Writable.call(this);
    var X = D[V];
    if (!X)
      throw new Error("Unknown message digest");
    this._hashType = X.hash, this._hash = M(X.hash), this._tag = X.id, this._signType = X.sign;
  }
  $(F, x.Writable), F.prototype._write = function(X, Q, fe) {
    this._hash.update(X), fe();
  }, F.prototype.update = function(X, Q) {
    return this._hash.update(typeof X == "string" ? w.from(X, Q) : X), this;
  }, F.prototype.sign = function(X, Q) {
    this.end();
    var fe = this._hash.digest(), ce = T(fe, X, this._hashType, this._signType, this._tag);
    return Q ? ce.toString(Q) : ce;
  };
  function z(V) {
    x.Writable.call(this);
    var X = D[V];
    if (!X)
      throw new Error("Unknown message digest");
    this._hash = M(X.hash), this._tag = X.id, this._signType = X.sign;
  }
  $(z, x.Writable), z.prototype._write = function(X, Q, fe) {
    this._hash.update(X), fe();
  }, z.prototype.update = function(X, Q) {
    return this._hash.update(typeof X == "string" ? w.from(X, Q) : X), this;
  }, z.prototype.verify = function(X, Q, fe) {
    var ce = typeof Q == "string" ? w.from(Q, fe) : Q;
    this.end();
    var me = this._hash.digest();
    return S(ce, me, X, this._signType, this._tag);
  };
  function Z(V) {
    return new F(V);
  }
  function H(V) {
    return new z(V);
  }
  return browser$3 = {
    Sign: Z,
    Verify: H,
    createSign: Z,
    createVerify: H
  }, browser$3;
}
var bn$1 = { exports: {} };
bn$1.exports;
(function(w) {
  (function(M, x) {
    function $(N, y) {
      if (!N) throw new Error(y || "Assertion failed");
    }
    function T(N, y) {
      N.super_ = y;
      var E = function() {
      };
      E.prototype = y.prototype, N.prototype = new E(), N.prototype.constructor = N;
    }
    function S(N, y, E) {
      if (S.isBN(N))
        return N;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, N !== null && ((y === "le" || y === "be") && (E = y, y = 10), this._init(N || 0, y || 10, E || "be"));
    }
    typeof M == "object" ? M.exports = S : x.BN = S, S.BN = S, S.wordSize = 26;
    var D;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? D = window.Buffer : D = dist.Buffer;
    } catch {
    }
    S.isBN = function(y) {
      return y instanceof S ? !0 : y !== null && typeof y == "object" && y.constructor.wordSize === S.wordSize && Array.isArray(y.words);
    }, S.max = function(y, E) {
      return y.cmp(E) > 0 ? y : E;
    }, S.min = function(y, E) {
      return y.cmp(E) < 0 ? y : E;
    }, S.prototype._init = function(y, E, A) {
      if (typeof y == "number")
        return this._initNumber(y, E, A);
      if (typeof y == "object")
        return this._initArray(y, E, A);
      E === "hex" && (E = 16), $(E === (E | 0) && E >= 2 && E <= 36), y = y.toString().replace(/\s+/g, "");
      var B = 0;
      y[0] === "-" && (B++, this.negative = 1), B < y.length && (E === 16 ? this._parseHex(y, B, A) : (this._parseBase(y, E, B), A === "le" && this._initArray(this.toArray(), E, A)));
    }, S.prototype._initNumber = function(y, E, A) {
      y < 0 && (this.negative = 1, y = -y), y < 67108864 ? (this.words = [y & 67108863], this.length = 1) : y < 4503599627370496 ? (this.words = [
        y & 67108863,
        y / 67108864 & 67108863
      ], this.length = 2) : ($(y < 9007199254740992), this.words = [
        y & 67108863,
        y / 67108864 & 67108863,
        1
      ], this.length = 3), A === "le" && this._initArray(this.toArray(), E, A);
    }, S.prototype._initArray = function(y, E, A) {
      if ($(typeof y.length == "number"), y.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(y.length / 3), this.words = new Array(this.length);
      for (var B = 0; B < this.length; B++)
        this.words[B] = 0;
      var O, C, L = 0;
      if (A === "be")
        for (B = y.length - 1, O = 0; B >= 0; B -= 3)
          C = y[B] | y[B - 1] << 8 | y[B - 2] << 16, this.words[O] |= C << L & 67108863, this.words[O + 1] = C >>> 26 - L & 67108863, L += 24, L >= 26 && (L -= 26, O++);
      else if (A === "le")
        for (B = 0, O = 0; B < y.length; B += 3)
          C = y[B] | y[B + 1] << 8 | y[B + 2] << 16, this.words[O] |= C << L & 67108863, this.words[O + 1] = C >>> 26 - L & 67108863, L += 24, L >= 26 && (L -= 26, O++);
      return this.strip();
    };
    function F(N, y) {
      var E = N.charCodeAt(y);
      return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
    }
    function z(N, y, E) {
      var A = F(N, E);
      return E - 1 >= y && (A |= F(N, E - 1) << 4), A;
    }
    S.prototype._parseHex = function(y, E, A) {
      this.length = Math.ceil((y.length - E) / 6), this.words = new Array(this.length);
      for (var B = 0; B < this.length; B++)
        this.words[B] = 0;
      var O = 0, C = 0, L;
      if (A === "be")
        for (B = y.length - 1; B >= E; B -= 2)
          L = z(y, E, B) << O, this.words[C] |= L & 67108863, O >= 18 ? (O -= 18, C += 1, this.words[C] |= L >>> 26) : O += 8;
      else {
        var P = y.length - E;
        for (B = P % 2 === 0 ? E + 1 : E; B < y.length; B += 2)
          L = z(y, E, B) << O, this.words[C] |= L & 67108863, O >= 18 ? (O -= 18, C += 1, this.words[C] |= L >>> 26) : O += 8;
      }
      this.strip();
    };
    function Z(N, y, E, A) {
      for (var B = 0, O = Math.min(N.length, E), C = y; C < O; C++) {
        var L = N.charCodeAt(C) - 48;
        B *= A, L >= 49 ? B += L - 49 + 10 : L >= 17 ? B += L - 17 + 10 : B += L;
      }
      return B;
    }
    S.prototype._parseBase = function(y, E, A) {
      this.words = [0], this.length = 1;
      for (var B = 0, O = 1; O <= 67108863; O *= E)
        B++;
      B--, O = O / E | 0;
      for (var C = y.length - A, L = C % B, P = Math.min(C, C - L) + A, _ = 0, I = A; I < P; I += B)
        _ = Z(y, I, I + B, E), this.imuln(O), this.words[0] + _ < 67108864 ? this.words[0] += _ : this._iaddn(_);
      if (L !== 0) {
        var U = 1;
        for (_ = Z(y, I, y.length, E), I = 0; I < L; I++)
          U *= E;
        this.imuln(U), this.words[0] + _ < 67108864 ? this.words[0] += _ : this._iaddn(_);
      }
      this.strip();
    }, S.prototype.copy = function(y) {
      y.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        y.words[E] = this.words[E];
      y.length = this.length, y.negative = this.negative, y.red = this.red;
    }, S.prototype.clone = function() {
      var y = new S(null);
      return this.copy(y), y;
    }, S.prototype._expand = function(y) {
      for (; this.length < y; )
        this.words[this.length++] = 0;
      return this;
    }, S.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, S.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, S.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var H = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], V = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], X = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    S.prototype.toString = function(y, E) {
      y = y || 10, E = E | 0 || 1;
      var A;
      if (y === 16 || y === "hex") {
        A = "";
        for (var B = 0, O = 0, C = 0; C < this.length; C++) {
          var L = this.words[C], P = ((L << B | O) & 16777215).toString(16);
          O = L >>> 24 - B & 16777215, B += 2, B >= 26 && (B -= 26, C--), O !== 0 || C !== this.length - 1 ? A = H[6 - P.length] + P + A : A = P + A;
        }
        for (O !== 0 && (A = O.toString(16) + A); A.length % E !== 0; )
          A = "0" + A;
        return this.negative !== 0 && (A = "-" + A), A;
      }
      if (y === (y | 0) && y >= 2 && y <= 36) {
        var _ = V[y], I = X[y];
        A = "";
        var U = this.clone();
        for (U.negative = 0; !U.isZero(); ) {
          var Y = U.modn(I).toString(y);
          U = U.idivn(I), U.isZero() ? A = Y + A : A = H[_ - Y.length] + Y + A;
        }
        for (this.isZero() && (A = "0" + A); A.length % E !== 0; )
          A = "0" + A;
        return this.negative !== 0 && (A = "-" + A), A;
      }
      $(!1, "Base should be between 2 and 36");
    }, S.prototype.toNumber = function() {
      var y = this.words[0];
      return this.length === 2 ? y += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? y += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && $(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -y : y;
    }, S.prototype.toJSON = function() {
      return this.toString(16);
    }, S.prototype.toBuffer = function(y, E) {
      return $(typeof D < "u"), this.toArrayLike(D, y, E);
    }, S.prototype.toArray = function(y, E) {
      return this.toArrayLike(Array, y, E);
    }, S.prototype.toArrayLike = function(y, E, A) {
      var B = this.byteLength(), O = A || Math.max(1, B);
      $(B <= O, "byte array longer than desired length"), $(O > 0, "Requested array length <= 0"), this.strip();
      var C = E === "le", L = new y(O), P, _, I = this.clone();
      if (C) {
        for (_ = 0; !I.isZero(); _++)
          P = I.andln(255), I.iushrn(8), L[_] = P;
        for (; _ < O; _++)
          L[_] = 0;
      } else {
        for (_ = 0; _ < O - B; _++)
          L[_] = 0;
        for (_ = 0; !I.isZero(); _++)
          P = I.andln(255), I.iushrn(8), L[O - _ - 1] = P;
      }
      return L;
    }, Math.clz32 ? S.prototype._countBits = function(y) {
      return 32 - Math.clz32(y);
    } : S.prototype._countBits = function(y) {
      var E = y, A = 0;
      return E >= 4096 && (A += 13, E >>>= 13), E >= 64 && (A += 7, E >>>= 7), E >= 8 && (A += 4, E >>>= 4), E >= 2 && (A += 2, E >>>= 2), A + E;
    }, S.prototype._zeroBits = function(y) {
      if (y === 0) return 26;
      var E = y, A = 0;
      return E & 8191 || (A += 13, E >>>= 13), E & 127 || (A += 7, E >>>= 7), E & 15 || (A += 4, E >>>= 4), E & 3 || (A += 2, E >>>= 2), E & 1 || A++, A;
    }, S.prototype.bitLength = function() {
      var y = this.words[this.length - 1], E = this._countBits(y);
      return (this.length - 1) * 26 + E;
    };
    function Q(N) {
      for (var y = new Array(N.bitLength()), E = 0; E < y.length; E++) {
        var A = E / 26 | 0, B = E % 26;
        y[E] = (N.words[A] & 1 << B) >>> B;
      }
      return y;
    }
    S.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var y = 0, E = 0; E < this.length; E++) {
        var A = this._zeroBits(this.words[E]);
        if (y += A, A !== 26) break;
      }
      return y;
    }, S.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, S.prototype.toTwos = function(y) {
      return this.negative !== 0 ? this.abs().inotn(y).iaddn(1) : this.clone();
    }, S.prototype.fromTwos = function(y) {
      return this.testn(y - 1) ? this.notn(y).iaddn(1).ineg() : this.clone();
    }, S.prototype.isNeg = function() {
      return this.negative !== 0;
    }, S.prototype.neg = function() {
      return this.clone().ineg();
    }, S.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, S.prototype.iuor = function(y) {
      for (; this.length < y.length; )
        this.words[this.length++] = 0;
      for (var E = 0; E < y.length; E++)
        this.words[E] = this.words[E] | y.words[E];
      return this.strip();
    }, S.prototype.ior = function(y) {
      return $((this.negative | y.negative) === 0), this.iuor(y);
    }, S.prototype.or = function(y) {
      return this.length > y.length ? this.clone().ior(y) : y.clone().ior(this);
    }, S.prototype.uor = function(y) {
      return this.length > y.length ? this.clone().iuor(y) : y.clone().iuor(this);
    }, S.prototype.iuand = function(y) {
      var E;
      this.length > y.length ? E = y : E = this;
      for (var A = 0; A < E.length; A++)
        this.words[A] = this.words[A] & y.words[A];
      return this.length = E.length, this.strip();
    }, S.prototype.iand = function(y) {
      return $((this.negative | y.negative) === 0), this.iuand(y);
    }, S.prototype.and = function(y) {
      return this.length > y.length ? this.clone().iand(y) : y.clone().iand(this);
    }, S.prototype.uand = function(y) {
      return this.length > y.length ? this.clone().iuand(y) : y.clone().iuand(this);
    }, S.prototype.iuxor = function(y) {
      var E, A;
      this.length > y.length ? (E = this, A = y) : (E = y, A = this);
      for (var B = 0; B < A.length; B++)
        this.words[B] = E.words[B] ^ A.words[B];
      if (this !== E)
        for (; B < E.length; B++)
          this.words[B] = E.words[B];
      return this.length = E.length, this.strip();
    }, S.prototype.ixor = function(y) {
      return $((this.negative | y.negative) === 0), this.iuxor(y);
    }, S.prototype.xor = function(y) {
      return this.length > y.length ? this.clone().ixor(y) : y.clone().ixor(this);
    }, S.prototype.uxor = function(y) {
      return this.length > y.length ? this.clone().iuxor(y) : y.clone().iuxor(this);
    }, S.prototype.inotn = function(y) {
      $(typeof y == "number" && y >= 0);
      var E = Math.ceil(y / 26) | 0, A = y % 26;
      this._expand(E), A > 0 && E--;
      for (var B = 0; B < E; B++)
        this.words[B] = ~this.words[B] & 67108863;
      return A > 0 && (this.words[B] = ~this.words[B] & 67108863 >> 26 - A), this.strip();
    }, S.prototype.notn = function(y) {
      return this.clone().inotn(y);
    }, S.prototype.setn = function(y, E) {
      $(typeof y == "number" && y >= 0);
      var A = y / 26 | 0, B = y % 26;
      return this._expand(A + 1), E ? this.words[A] = this.words[A] | 1 << B : this.words[A] = this.words[A] & ~(1 << B), this.strip();
    }, S.prototype.iadd = function(y) {
      var E;
      if (this.negative !== 0 && y.negative === 0)
        return this.negative = 0, E = this.isub(y), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && y.negative !== 0)
        return y.negative = 0, E = this.isub(y), y.negative = 1, E._normSign();
      var A, B;
      this.length > y.length ? (A = this, B = y) : (A = y, B = this);
      for (var O = 0, C = 0; C < B.length; C++)
        E = (A.words[C] | 0) + (B.words[C] | 0) + O, this.words[C] = E & 67108863, O = E >>> 26;
      for (; O !== 0 && C < A.length; C++)
        E = (A.words[C] | 0) + O, this.words[C] = E & 67108863, O = E >>> 26;
      if (this.length = A.length, O !== 0)
        this.words[this.length] = O, this.length++;
      else if (A !== this)
        for (; C < A.length; C++)
          this.words[C] = A.words[C];
      return this;
    }, S.prototype.add = function(y) {
      var E;
      return y.negative !== 0 && this.negative === 0 ? (y.negative = 0, E = this.sub(y), y.negative ^= 1, E) : y.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = y.sub(this), this.negative = 1, E) : this.length > y.length ? this.clone().iadd(y) : y.clone().iadd(this);
    }, S.prototype.isub = function(y) {
      if (y.negative !== 0) {
        y.negative = 0;
        var E = this.iadd(y);
        return y.negative = 1, E._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(y), this.negative = 1, this._normSign();
      var A = this.cmp(y);
      if (A === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var B, O;
      A > 0 ? (B = this, O = y) : (B = y, O = this);
      for (var C = 0, L = 0; L < O.length; L++)
        E = (B.words[L] | 0) - (O.words[L] | 0) + C, C = E >> 26, this.words[L] = E & 67108863;
      for (; C !== 0 && L < B.length; L++)
        E = (B.words[L] | 0) + C, C = E >> 26, this.words[L] = E & 67108863;
      if (C === 0 && L < B.length && B !== this)
        for (; L < B.length; L++)
          this.words[L] = B.words[L];
      return this.length = Math.max(this.length, L), B !== this && (this.negative = 1), this.strip();
    }, S.prototype.sub = function(y) {
      return this.clone().isub(y);
    };
    function fe(N, y, E) {
      E.negative = y.negative ^ N.negative;
      var A = N.length + y.length | 0;
      E.length = A, A = A - 1 | 0;
      var B = N.words[0] | 0, O = y.words[0] | 0, C = B * O, L = C & 67108863, P = C / 67108864 | 0;
      E.words[0] = L;
      for (var _ = 1; _ < A; _++) {
        for (var I = P >>> 26, U = P & 67108863, Y = Math.min(_, y.length - 1), te = Math.max(0, _ - N.length + 1); te <= Y; te++) {
          var oe = _ - te | 0;
          B = N.words[oe] | 0, O = y.words[te] | 0, C = B * O + U, I += C / 67108864 | 0, U = C & 67108863;
        }
        E.words[_] = U | 0, P = I | 0;
      }
      return P !== 0 ? E.words[_] = P | 0 : E.length--, E.strip();
    }
    var ce = function(y, E, A) {
      var B = y.words, O = E.words, C = A.words, L = 0, P, _, I, U = B[0] | 0, Y = U & 8191, te = U >>> 13, oe = B[1] | 0, re = oe & 8191, ee = oe >>> 13, ae = B[2] | 0, ue = ae & 8191, ye = ae >>> 13, ve = B[3] | 0, he = ve & 8191, Me = ve >>> 13, Qe = B[4] | 0, Ie = Qe & 8191, De = Qe >>> 13, at = B[5] | 0, ke = at & 8191, Se = at >>> 13, lt = B[6] | 0, qe = lt & 8191, He = lt >>> 13, ot = B[7] | 0, be = ot & 8191, _e = ot >>> 13, it = B[8] | 0, Ae = it & 8191, Be = it >>> 13, nt = B[9] | 0, Te = nt & 8191, Ue = nt >>> 13, st = O[0] | 0, Le = st & 8191, Ge = st >>> 13, pt = O[1] | 0, je = pt & 8191, Je = pt >>> 13, dt = O[2] | 0, ze = dt & 8191, et = dt >>> 13, yt = O[3] | 0, Ke = yt & 8191, Ye = yt >>> 13, gt = O[4] | 0, We = gt & 8191, Xe = gt >>> 13, bt = O[5] | 0, se = bt & 8191, J = bt >>> 13, ie = O[6] | 0, le = ie & 8191, we = ie >>> 13, Ce = O[7] | 0, Ee = Ce & 8191, Fe = Ce >>> 13, ut = O[8] | 0, Ne = ut & 8191, Ve = ut >>> 13, ht = O[9] | 0, Ze = ht & 8191, tt = ht >>> 13;
      A.negative = y.negative ^ E.negative, A.length = 19, P = Math.imul(Y, Le), _ = Math.imul(Y, Ge), _ = _ + Math.imul(te, Le) | 0, I = Math.imul(te, Ge);
      var vt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, P = Math.imul(re, Le), _ = Math.imul(re, Ge), _ = _ + Math.imul(ee, Le) | 0, I = Math.imul(ee, Ge), P = P + Math.imul(Y, je) | 0, _ = _ + Math.imul(Y, Je) | 0, _ = _ + Math.imul(te, je) | 0, I = I + Math.imul(te, Je) | 0;
      var mt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, P = Math.imul(ue, Le), _ = Math.imul(ue, Ge), _ = _ + Math.imul(ye, Le) | 0, I = Math.imul(ye, Ge), P = P + Math.imul(re, je) | 0, _ = _ + Math.imul(re, Je) | 0, _ = _ + Math.imul(ee, je) | 0, I = I + Math.imul(ee, Je) | 0, P = P + Math.imul(Y, ze) | 0, _ = _ + Math.imul(Y, et) | 0, _ = _ + Math.imul(te, ze) | 0, I = I + Math.imul(te, et) | 0;
      var wt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, P = Math.imul(he, Le), _ = Math.imul(he, Ge), _ = _ + Math.imul(Me, Le) | 0, I = Math.imul(Me, Ge), P = P + Math.imul(ue, je) | 0, _ = _ + Math.imul(ue, Je) | 0, _ = _ + Math.imul(ye, je) | 0, I = I + Math.imul(ye, Je) | 0, P = P + Math.imul(re, ze) | 0, _ = _ + Math.imul(re, et) | 0, _ = _ + Math.imul(ee, ze) | 0, I = I + Math.imul(ee, et) | 0, P = P + Math.imul(Y, Ke) | 0, _ = _ + Math.imul(Y, Ye) | 0, _ = _ + Math.imul(te, Ke) | 0, I = I + Math.imul(te, Ye) | 0;
      var Mt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, P = Math.imul(Ie, Le), _ = Math.imul(Ie, Ge), _ = _ + Math.imul(De, Le) | 0, I = Math.imul(De, Ge), P = P + Math.imul(he, je) | 0, _ = _ + Math.imul(he, Je) | 0, _ = _ + Math.imul(Me, je) | 0, I = I + Math.imul(Me, Je) | 0, P = P + Math.imul(ue, ze) | 0, _ = _ + Math.imul(ue, et) | 0, _ = _ + Math.imul(ye, ze) | 0, I = I + Math.imul(ye, et) | 0, P = P + Math.imul(re, Ke) | 0, _ = _ + Math.imul(re, Ye) | 0, _ = _ + Math.imul(ee, Ke) | 0, I = I + Math.imul(ee, Ye) | 0, P = P + Math.imul(Y, We) | 0, _ = _ + Math.imul(Y, Xe) | 0, _ = _ + Math.imul(te, We) | 0, I = I + Math.imul(te, Xe) | 0;
      var _t = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, P = Math.imul(ke, Le), _ = Math.imul(ke, Ge), _ = _ + Math.imul(Se, Le) | 0, I = Math.imul(Se, Ge), P = P + Math.imul(Ie, je) | 0, _ = _ + Math.imul(Ie, Je) | 0, _ = _ + Math.imul(De, je) | 0, I = I + Math.imul(De, Je) | 0, P = P + Math.imul(he, ze) | 0, _ = _ + Math.imul(he, et) | 0, _ = _ + Math.imul(Me, ze) | 0, I = I + Math.imul(Me, et) | 0, P = P + Math.imul(ue, Ke) | 0, _ = _ + Math.imul(ue, Ye) | 0, _ = _ + Math.imul(ye, Ke) | 0, I = I + Math.imul(ye, Ye) | 0, P = P + Math.imul(re, We) | 0, _ = _ + Math.imul(re, Xe) | 0, _ = _ + Math.imul(ee, We) | 0, I = I + Math.imul(ee, Xe) | 0, P = P + Math.imul(Y, se) | 0, _ = _ + Math.imul(Y, J) | 0, _ = _ + Math.imul(te, se) | 0, I = I + Math.imul(te, J) | 0;
      var xt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, P = Math.imul(qe, Le), _ = Math.imul(qe, Ge), _ = _ + Math.imul(He, Le) | 0, I = Math.imul(He, Ge), P = P + Math.imul(ke, je) | 0, _ = _ + Math.imul(ke, Je) | 0, _ = _ + Math.imul(Se, je) | 0, I = I + Math.imul(Se, Je) | 0, P = P + Math.imul(Ie, ze) | 0, _ = _ + Math.imul(Ie, et) | 0, _ = _ + Math.imul(De, ze) | 0, I = I + Math.imul(De, et) | 0, P = P + Math.imul(he, Ke) | 0, _ = _ + Math.imul(he, Ye) | 0, _ = _ + Math.imul(Me, Ke) | 0, I = I + Math.imul(Me, Ye) | 0, P = P + Math.imul(ue, We) | 0, _ = _ + Math.imul(ue, Xe) | 0, _ = _ + Math.imul(ye, We) | 0, I = I + Math.imul(ye, Xe) | 0, P = P + Math.imul(re, se) | 0, _ = _ + Math.imul(re, J) | 0, _ = _ + Math.imul(ee, se) | 0, I = I + Math.imul(ee, J) | 0, P = P + Math.imul(Y, le) | 0, _ = _ + Math.imul(Y, we) | 0, _ = _ + Math.imul(te, le) | 0, I = I + Math.imul(te, we) | 0;
      var Et = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, P = Math.imul(be, Le), _ = Math.imul(be, Ge), _ = _ + Math.imul(_e, Le) | 0, I = Math.imul(_e, Ge), P = P + Math.imul(qe, je) | 0, _ = _ + Math.imul(qe, Je) | 0, _ = _ + Math.imul(He, je) | 0, I = I + Math.imul(He, Je) | 0, P = P + Math.imul(ke, ze) | 0, _ = _ + Math.imul(ke, et) | 0, _ = _ + Math.imul(Se, ze) | 0, I = I + Math.imul(Se, et) | 0, P = P + Math.imul(Ie, Ke) | 0, _ = _ + Math.imul(Ie, Ye) | 0, _ = _ + Math.imul(De, Ke) | 0, I = I + Math.imul(De, Ye) | 0, P = P + Math.imul(he, We) | 0, _ = _ + Math.imul(he, Xe) | 0, _ = _ + Math.imul(Me, We) | 0, I = I + Math.imul(Me, Xe) | 0, P = P + Math.imul(ue, se) | 0, _ = _ + Math.imul(ue, J) | 0, _ = _ + Math.imul(ye, se) | 0, I = I + Math.imul(ye, J) | 0, P = P + Math.imul(re, le) | 0, _ = _ + Math.imul(re, we) | 0, _ = _ + Math.imul(ee, le) | 0, I = I + Math.imul(ee, we) | 0, P = P + Math.imul(Y, Ee) | 0, _ = _ + Math.imul(Y, Fe) | 0, _ = _ + Math.imul(te, Ee) | 0, I = I + Math.imul(te, Fe) | 0;
      var St = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, P = Math.imul(Ae, Le), _ = Math.imul(Ae, Ge), _ = _ + Math.imul(Be, Le) | 0, I = Math.imul(Be, Ge), P = P + Math.imul(be, je) | 0, _ = _ + Math.imul(be, Je) | 0, _ = _ + Math.imul(_e, je) | 0, I = I + Math.imul(_e, Je) | 0, P = P + Math.imul(qe, ze) | 0, _ = _ + Math.imul(qe, et) | 0, _ = _ + Math.imul(He, ze) | 0, I = I + Math.imul(He, et) | 0, P = P + Math.imul(ke, Ke) | 0, _ = _ + Math.imul(ke, Ye) | 0, _ = _ + Math.imul(Se, Ke) | 0, I = I + Math.imul(Se, Ye) | 0, P = P + Math.imul(Ie, We) | 0, _ = _ + Math.imul(Ie, Xe) | 0, _ = _ + Math.imul(De, We) | 0, I = I + Math.imul(De, Xe) | 0, P = P + Math.imul(he, se) | 0, _ = _ + Math.imul(he, J) | 0, _ = _ + Math.imul(Me, se) | 0, I = I + Math.imul(Me, J) | 0, P = P + Math.imul(ue, le) | 0, _ = _ + Math.imul(ue, we) | 0, _ = _ + Math.imul(ye, le) | 0, I = I + Math.imul(ye, we) | 0, P = P + Math.imul(re, Ee) | 0, _ = _ + Math.imul(re, Fe) | 0, _ = _ + Math.imul(ee, Ee) | 0, I = I + Math.imul(ee, Fe) | 0, P = P + Math.imul(Y, Ne) | 0, _ = _ + Math.imul(Y, Ve) | 0, _ = _ + Math.imul(te, Ne) | 0, I = I + Math.imul(te, Ve) | 0;
      var $t = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, P = Math.imul(Te, Le), _ = Math.imul(Te, Ge), _ = _ + Math.imul(Ue, Le) | 0, I = Math.imul(Ue, Ge), P = P + Math.imul(Ae, je) | 0, _ = _ + Math.imul(Ae, Je) | 0, _ = _ + Math.imul(Be, je) | 0, I = I + Math.imul(Be, Je) | 0, P = P + Math.imul(be, ze) | 0, _ = _ + Math.imul(be, et) | 0, _ = _ + Math.imul(_e, ze) | 0, I = I + Math.imul(_e, et) | 0, P = P + Math.imul(qe, Ke) | 0, _ = _ + Math.imul(qe, Ye) | 0, _ = _ + Math.imul(He, Ke) | 0, I = I + Math.imul(He, Ye) | 0, P = P + Math.imul(ke, We) | 0, _ = _ + Math.imul(ke, Xe) | 0, _ = _ + Math.imul(Se, We) | 0, I = I + Math.imul(Se, Xe) | 0, P = P + Math.imul(Ie, se) | 0, _ = _ + Math.imul(Ie, J) | 0, _ = _ + Math.imul(De, se) | 0, I = I + Math.imul(De, J) | 0, P = P + Math.imul(he, le) | 0, _ = _ + Math.imul(he, we) | 0, _ = _ + Math.imul(Me, le) | 0, I = I + Math.imul(Me, we) | 0, P = P + Math.imul(ue, Ee) | 0, _ = _ + Math.imul(ue, Fe) | 0, _ = _ + Math.imul(ye, Ee) | 0, I = I + Math.imul(ye, Fe) | 0, P = P + Math.imul(re, Ne) | 0, _ = _ + Math.imul(re, Ve) | 0, _ = _ + Math.imul(ee, Ne) | 0, I = I + Math.imul(ee, Ve) | 0, P = P + Math.imul(Y, Ze) | 0, _ = _ + Math.imul(Y, tt) | 0, _ = _ + Math.imul(te, Ze) | 0, I = I + Math.imul(te, tt) | 0;
      var At = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, P = Math.imul(Te, je), _ = Math.imul(Te, Je), _ = _ + Math.imul(Ue, je) | 0, I = Math.imul(Ue, Je), P = P + Math.imul(Ae, ze) | 0, _ = _ + Math.imul(Ae, et) | 0, _ = _ + Math.imul(Be, ze) | 0, I = I + Math.imul(Be, et) | 0, P = P + Math.imul(be, Ke) | 0, _ = _ + Math.imul(be, Ye) | 0, _ = _ + Math.imul(_e, Ke) | 0, I = I + Math.imul(_e, Ye) | 0, P = P + Math.imul(qe, We) | 0, _ = _ + Math.imul(qe, Xe) | 0, _ = _ + Math.imul(He, We) | 0, I = I + Math.imul(He, Xe) | 0, P = P + Math.imul(ke, se) | 0, _ = _ + Math.imul(ke, J) | 0, _ = _ + Math.imul(Se, se) | 0, I = I + Math.imul(Se, J) | 0, P = P + Math.imul(Ie, le) | 0, _ = _ + Math.imul(Ie, we) | 0, _ = _ + Math.imul(De, le) | 0, I = I + Math.imul(De, we) | 0, P = P + Math.imul(he, Ee) | 0, _ = _ + Math.imul(he, Fe) | 0, _ = _ + Math.imul(Me, Ee) | 0, I = I + Math.imul(Me, Fe) | 0, P = P + Math.imul(ue, Ne) | 0, _ = _ + Math.imul(ue, Ve) | 0, _ = _ + Math.imul(ye, Ne) | 0, I = I + Math.imul(ye, Ve) | 0, P = P + Math.imul(re, Ze) | 0, _ = _ + Math.imul(re, tt) | 0, _ = _ + Math.imul(ee, Ze) | 0, I = I + Math.imul(ee, tt) | 0;
      var Rt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, P = Math.imul(Te, ze), _ = Math.imul(Te, et), _ = _ + Math.imul(Ue, ze) | 0, I = Math.imul(Ue, et), P = P + Math.imul(Ae, Ke) | 0, _ = _ + Math.imul(Ae, Ye) | 0, _ = _ + Math.imul(Be, Ke) | 0, I = I + Math.imul(Be, Ye) | 0, P = P + Math.imul(be, We) | 0, _ = _ + Math.imul(be, Xe) | 0, _ = _ + Math.imul(_e, We) | 0, I = I + Math.imul(_e, Xe) | 0, P = P + Math.imul(qe, se) | 0, _ = _ + Math.imul(qe, J) | 0, _ = _ + Math.imul(He, se) | 0, I = I + Math.imul(He, J) | 0, P = P + Math.imul(ke, le) | 0, _ = _ + Math.imul(ke, we) | 0, _ = _ + Math.imul(Se, le) | 0, I = I + Math.imul(Se, we) | 0, P = P + Math.imul(Ie, Ee) | 0, _ = _ + Math.imul(Ie, Fe) | 0, _ = _ + Math.imul(De, Ee) | 0, I = I + Math.imul(De, Fe) | 0, P = P + Math.imul(he, Ne) | 0, _ = _ + Math.imul(he, Ve) | 0, _ = _ + Math.imul(Me, Ne) | 0, I = I + Math.imul(Me, Ve) | 0, P = P + Math.imul(ue, Ze) | 0, _ = _ + Math.imul(ue, tt) | 0, _ = _ + Math.imul(ye, Ze) | 0, I = I + Math.imul(ye, tt) | 0;
      var Bt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, P = Math.imul(Te, Ke), _ = Math.imul(Te, Ye), _ = _ + Math.imul(Ue, Ke) | 0, I = Math.imul(Ue, Ye), P = P + Math.imul(Ae, We) | 0, _ = _ + Math.imul(Ae, Xe) | 0, _ = _ + Math.imul(Be, We) | 0, I = I + Math.imul(Be, Xe) | 0, P = P + Math.imul(be, se) | 0, _ = _ + Math.imul(be, J) | 0, _ = _ + Math.imul(_e, se) | 0, I = I + Math.imul(_e, J) | 0, P = P + Math.imul(qe, le) | 0, _ = _ + Math.imul(qe, we) | 0, _ = _ + Math.imul(He, le) | 0, I = I + Math.imul(He, we) | 0, P = P + Math.imul(ke, Ee) | 0, _ = _ + Math.imul(ke, Fe) | 0, _ = _ + Math.imul(Se, Ee) | 0, I = I + Math.imul(Se, Fe) | 0, P = P + Math.imul(Ie, Ne) | 0, _ = _ + Math.imul(Ie, Ve) | 0, _ = _ + Math.imul(De, Ne) | 0, I = I + Math.imul(De, Ve) | 0, P = P + Math.imul(he, Ze) | 0, _ = _ + Math.imul(he, tt) | 0, _ = _ + Math.imul(Me, Ze) | 0, I = I + Math.imul(Me, tt) | 0;
      var Tt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, P = Math.imul(Te, We), _ = Math.imul(Te, Xe), _ = _ + Math.imul(Ue, We) | 0, I = Math.imul(Ue, Xe), P = P + Math.imul(Ae, se) | 0, _ = _ + Math.imul(Ae, J) | 0, _ = _ + Math.imul(Be, se) | 0, I = I + Math.imul(Be, J) | 0, P = P + Math.imul(be, le) | 0, _ = _ + Math.imul(be, we) | 0, _ = _ + Math.imul(_e, le) | 0, I = I + Math.imul(_e, we) | 0, P = P + Math.imul(qe, Ee) | 0, _ = _ + Math.imul(qe, Fe) | 0, _ = _ + Math.imul(He, Ee) | 0, I = I + Math.imul(He, Fe) | 0, P = P + Math.imul(ke, Ne) | 0, _ = _ + Math.imul(ke, Ve) | 0, _ = _ + Math.imul(Se, Ne) | 0, I = I + Math.imul(Se, Ve) | 0, P = P + Math.imul(Ie, Ze) | 0, _ = _ + Math.imul(Ie, tt) | 0, _ = _ + Math.imul(De, Ze) | 0, I = I + Math.imul(De, tt) | 0;
      var Pt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, P = Math.imul(Te, se), _ = Math.imul(Te, J), _ = _ + Math.imul(Ue, se) | 0, I = Math.imul(Ue, J), P = P + Math.imul(Ae, le) | 0, _ = _ + Math.imul(Ae, we) | 0, _ = _ + Math.imul(Be, le) | 0, I = I + Math.imul(Be, we) | 0, P = P + Math.imul(be, Ee) | 0, _ = _ + Math.imul(be, Fe) | 0, _ = _ + Math.imul(_e, Ee) | 0, I = I + Math.imul(_e, Fe) | 0, P = P + Math.imul(qe, Ne) | 0, _ = _ + Math.imul(qe, Ve) | 0, _ = _ + Math.imul(He, Ne) | 0, I = I + Math.imul(He, Ve) | 0, P = P + Math.imul(ke, Ze) | 0, _ = _ + Math.imul(ke, tt) | 0, _ = _ + Math.imul(Se, Ze) | 0, I = I + Math.imul(Se, tt) | 0;
      var It = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, P = Math.imul(Te, le), _ = Math.imul(Te, we), _ = _ + Math.imul(Ue, le) | 0, I = Math.imul(Ue, we), P = P + Math.imul(Ae, Ee) | 0, _ = _ + Math.imul(Ae, Fe) | 0, _ = _ + Math.imul(Be, Ee) | 0, I = I + Math.imul(Be, Fe) | 0, P = P + Math.imul(be, Ne) | 0, _ = _ + Math.imul(be, Ve) | 0, _ = _ + Math.imul(_e, Ne) | 0, I = I + Math.imul(_e, Ve) | 0, P = P + Math.imul(qe, Ze) | 0, _ = _ + Math.imul(qe, tt) | 0, _ = _ + Math.imul(He, Ze) | 0, I = I + Math.imul(He, tt) | 0;
      var Ot = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, P = Math.imul(Te, Ee), _ = Math.imul(Te, Fe), _ = _ + Math.imul(Ue, Ee) | 0, I = Math.imul(Ue, Fe), P = P + Math.imul(Ae, Ne) | 0, _ = _ + Math.imul(Ae, Ve) | 0, _ = _ + Math.imul(Be, Ne) | 0, I = I + Math.imul(Be, Ve) | 0, P = P + Math.imul(be, Ze) | 0, _ = _ + Math.imul(be, tt) | 0, _ = _ + Math.imul(_e, Ze) | 0, I = I + Math.imul(_e, tt) | 0;
      var Ct = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, P = Math.imul(Te, Ne), _ = Math.imul(Te, Ve), _ = _ + Math.imul(Ue, Ne) | 0, I = Math.imul(Ue, Ve), P = P + Math.imul(Ae, Ze) | 0, _ = _ + Math.imul(Ae, tt) | 0, _ = _ + Math.imul(Be, Ze) | 0, I = I + Math.imul(Be, tt) | 0;
      var Dt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, P = Math.imul(Te, Ze), _ = Math.imul(Te, tt), _ = _ + Math.imul(Ue, Ze) | 0, I = Math.imul(Ue, tt);
      var kt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      return L = (I + (_ >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, C[0] = vt, C[1] = mt, C[2] = wt, C[3] = Mt, C[4] = _t, C[5] = xt, C[6] = Et, C[7] = St, C[8] = $t, C[9] = At, C[10] = Rt, C[11] = Bt, C[12] = Tt, C[13] = Pt, C[14] = It, C[15] = Ot, C[16] = Ct, C[17] = Dt, C[18] = kt, L !== 0 && (C[19] = L, A.length++), A;
    };
    Math.imul || (ce = fe);
    function me(N, y, E) {
      E.negative = y.negative ^ N.negative, E.length = N.length + y.length;
      for (var A = 0, B = 0, O = 0; O < E.length - 1; O++) {
        var C = B;
        B = 0;
        for (var L = A & 67108863, P = Math.min(O, y.length - 1), _ = Math.max(0, O - N.length + 1); _ <= P; _++) {
          var I = O - _, U = N.words[I] | 0, Y = y.words[_] | 0, te = U * Y, oe = te & 67108863;
          C = C + (te / 67108864 | 0) | 0, oe = oe + L | 0, L = oe & 67108863, C = C + (oe >>> 26) | 0, B += C >>> 26, C &= 67108863;
        }
        E.words[O] = L, A = C, C = B;
      }
      return A !== 0 ? E.words[O] = A : E.length--, E.strip();
    }
    function de(N, y, E) {
      var A = new ne();
      return A.mulp(N, y, E);
    }
    S.prototype.mulTo = function(y, E) {
      var A, B = this.length + y.length;
      return this.length === 10 && y.length === 10 ? A = ce(this, y, E) : B < 63 ? A = fe(this, y, E) : B < 1024 ? A = me(this, y, E) : A = de(this, y, E), A;
    };
    function ne(N, y) {
      this.x = N, this.y = y;
    }
    ne.prototype.makeRBT = function(y) {
      for (var E = new Array(y), A = S.prototype._countBits(y) - 1, B = 0; B < y; B++)
        E[B] = this.revBin(B, A, y);
      return E;
    }, ne.prototype.revBin = function(y, E, A) {
      if (y === 0 || y === A - 1) return y;
      for (var B = 0, O = 0; O < E; O++)
        B |= (y & 1) << E - O - 1, y >>= 1;
      return B;
    }, ne.prototype.permute = function(y, E, A, B, O, C) {
      for (var L = 0; L < C; L++)
        B[L] = E[y[L]], O[L] = A[y[L]];
    }, ne.prototype.transform = function(y, E, A, B, O, C) {
      this.permute(C, y, E, A, B, O);
      for (var L = 1; L < O; L <<= 1)
        for (var P = L << 1, _ = Math.cos(2 * Math.PI / P), I = Math.sin(2 * Math.PI / P), U = 0; U < O; U += P)
          for (var Y = _, te = I, oe = 0; oe < L; oe++) {
            var re = A[U + oe], ee = B[U + oe], ae = A[U + oe + L], ue = B[U + oe + L], ye = Y * ae - te * ue;
            ue = Y * ue + te * ae, ae = ye, A[U + oe] = re + ae, B[U + oe] = ee + ue, A[U + oe + L] = re - ae, B[U + oe + L] = ee - ue, oe !== P && (ye = _ * Y - I * te, te = _ * te + I * Y, Y = ye);
          }
    }, ne.prototype.guessLen13b = function(y, E) {
      var A = Math.max(E, y) | 1, B = A & 1, O = 0;
      for (A = A / 2 | 0; A; A = A >>> 1)
        O++;
      return 1 << O + 1 + B;
    }, ne.prototype.conjugate = function(y, E, A) {
      if (!(A <= 1))
        for (var B = 0; B < A / 2; B++) {
          var O = y[B];
          y[B] = y[A - B - 1], y[A - B - 1] = O, O = E[B], E[B] = -E[A - B - 1], E[A - B - 1] = -O;
        }
    }, ne.prototype.normalize13b = function(y, E) {
      for (var A = 0, B = 0; B < E / 2; B++) {
        var O = Math.round(y[2 * B + 1] / E) * 8192 + Math.round(y[2 * B] / E) + A;
        y[B] = O & 67108863, O < 67108864 ? A = 0 : A = O / 67108864 | 0;
      }
      return y;
    }, ne.prototype.convert13b = function(y, E, A, B) {
      for (var O = 0, C = 0; C < E; C++)
        O = O + (y[C] | 0), A[2 * C] = O & 8191, O = O >>> 13, A[2 * C + 1] = O & 8191, O = O >>> 13;
      for (C = 2 * E; C < B; ++C)
        A[C] = 0;
      $(O === 0), $((O & -8192) === 0);
    }, ne.prototype.stub = function(y) {
      for (var E = new Array(y), A = 0; A < y; A++)
        E[A] = 0;
      return E;
    }, ne.prototype.mulp = function(y, E, A) {
      var B = 2 * this.guessLen13b(y.length, E.length), O = this.makeRBT(B), C = this.stub(B), L = new Array(B), P = new Array(B), _ = new Array(B), I = new Array(B), U = new Array(B), Y = new Array(B), te = A.words;
      te.length = B, this.convert13b(y.words, y.length, L, B), this.convert13b(E.words, E.length, I, B), this.transform(L, C, P, _, B, O), this.transform(I, C, U, Y, B, O);
      for (var oe = 0; oe < B; oe++) {
        var re = P[oe] * U[oe] - _[oe] * Y[oe];
        _[oe] = P[oe] * Y[oe] + _[oe] * U[oe], P[oe] = re;
      }
      return this.conjugate(P, _, B), this.transform(P, _, te, C, B, O), this.conjugate(te, C, B), this.normalize13b(te, B), A.negative = y.negative ^ E.negative, A.length = y.length + E.length, A.strip();
    }, S.prototype.mul = function(y) {
      var E = new S(null);
      return E.words = new Array(this.length + y.length), this.mulTo(y, E);
    }, S.prototype.mulf = function(y) {
      var E = new S(null);
      return E.words = new Array(this.length + y.length), de(this, y, E);
    }, S.prototype.imul = function(y) {
      return this.clone().mulTo(y, this);
    }, S.prototype.imuln = function(y) {
      $(typeof y == "number"), $(y < 67108864);
      for (var E = 0, A = 0; A < this.length; A++) {
        var B = (this.words[A] | 0) * y, O = (B & 67108863) + (E & 67108863);
        E >>= 26, E += B / 67108864 | 0, E += O >>> 26, this.words[A] = O & 67108863;
      }
      return E !== 0 && (this.words[A] = E, this.length++), this.length = y === 0 ? 1 : this.length, this;
    }, S.prototype.muln = function(y) {
      return this.clone().imuln(y);
    }, S.prototype.sqr = function() {
      return this.mul(this);
    }, S.prototype.isqr = function() {
      return this.imul(this.clone());
    }, S.prototype.pow = function(y) {
      var E = Q(y);
      if (E.length === 0) return new S(1);
      for (var A = this, B = 0; B < E.length && E[B] === 0; B++, A = A.sqr())
        ;
      if (++B < E.length)
        for (var O = A.sqr(); B < E.length; B++, O = O.sqr())
          E[B] !== 0 && (A = A.mul(O));
      return A;
    }, S.prototype.iushln = function(y) {
      $(typeof y == "number" && y >= 0);
      var E = y % 26, A = (y - E) / 26, B = 67108863 >>> 26 - E << 26 - E, O;
      if (E !== 0) {
        var C = 0;
        for (O = 0; O < this.length; O++) {
          var L = this.words[O] & B, P = (this.words[O] | 0) - L << E;
          this.words[O] = P | C, C = L >>> 26 - E;
        }
        C && (this.words[O] = C, this.length++);
      }
      if (A !== 0) {
        for (O = this.length - 1; O >= 0; O--)
          this.words[O + A] = this.words[O];
        for (O = 0; O < A; O++)
          this.words[O] = 0;
        this.length += A;
      }
      return this.strip();
    }, S.prototype.ishln = function(y) {
      return $(this.negative === 0), this.iushln(y);
    }, S.prototype.iushrn = function(y, E, A) {
      $(typeof y == "number" && y >= 0);
      var B;
      E ? B = (E - E % 26) / 26 : B = 0;
      var O = y % 26, C = Math.min((y - O) / 26, this.length), L = 67108863 ^ 67108863 >>> O << O, P = A;
      if (B -= C, B = Math.max(0, B), P) {
        for (var _ = 0; _ < C; _++)
          P.words[_] = this.words[_];
        P.length = C;
      }
      if (C !== 0) if (this.length > C)
        for (this.length -= C, _ = 0; _ < this.length; _++)
          this.words[_] = this.words[_ + C];
      else
        this.words[0] = 0, this.length = 1;
      var I = 0;
      for (_ = this.length - 1; _ >= 0 && (I !== 0 || _ >= B); _--) {
        var U = this.words[_] | 0;
        this.words[_] = I << 26 - O | U >>> O, I = U & L;
      }
      return P && I !== 0 && (P.words[P.length++] = I), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, S.prototype.ishrn = function(y, E, A) {
      return $(this.negative === 0), this.iushrn(y, E, A);
    }, S.prototype.shln = function(y) {
      return this.clone().ishln(y);
    }, S.prototype.ushln = function(y) {
      return this.clone().iushln(y);
    }, S.prototype.shrn = function(y) {
      return this.clone().ishrn(y);
    }, S.prototype.ushrn = function(y) {
      return this.clone().iushrn(y);
    }, S.prototype.testn = function(y) {
      $(typeof y == "number" && y >= 0);
      var E = y % 26, A = (y - E) / 26, B = 1 << E;
      if (this.length <= A) return !1;
      var O = this.words[A];
      return !!(O & B);
    }, S.prototype.imaskn = function(y) {
      $(typeof y == "number" && y >= 0);
      var E = y % 26, A = (y - E) / 26;
      if ($(this.negative === 0, "imaskn works only with positive numbers"), this.length <= A)
        return this;
      if (E !== 0 && A++, this.length = Math.min(A, this.length), E !== 0) {
        var B = 67108863 ^ 67108863 >>> E << E;
        this.words[this.length - 1] &= B;
      }
      return this.strip();
    }, S.prototype.maskn = function(y) {
      return this.clone().imaskn(y);
    }, S.prototype.iaddn = function(y) {
      return $(typeof y == "number"), $(y < 67108864), y < 0 ? this.isubn(-y) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < y ? (this.words[0] = y - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(y), this.negative = 1, this) : this._iaddn(y);
    }, S.prototype._iaddn = function(y) {
      this.words[0] += y;
      for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
        this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
      return this.length = Math.max(this.length, E + 1), this;
    }, S.prototype.isubn = function(y) {
      if ($(typeof y == "number"), $(y < 67108864), y < 0) return this.iaddn(-y);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(y), this.negative = 1, this;
      if (this.words[0] -= y, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var E = 0; E < this.length && this.words[E] < 0; E++)
          this.words[E] += 67108864, this.words[E + 1] -= 1;
      return this.strip();
    }, S.prototype.addn = function(y) {
      return this.clone().iaddn(y);
    }, S.prototype.subn = function(y) {
      return this.clone().isubn(y);
    }, S.prototype.iabs = function() {
      return this.negative = 0, this;
    }, S.prototype.abs = function() {
      return this.clone().iabs();
    }, S.prototype._ishlnsubmul = function(y, E, A) {
      var B = y.length + A, O;
      this._expand(B);
      var C, L = 0;
      for (O = 0; O < y.length; O++) {
        C = (this.words[O + A] | 0) + L;
        var P = (y.words[O] | 0) * E;
        C -= P & 67108863, L = (C >> 26) - (P / 67108864 | 0), this.words[O + A] = C & 67108863;
      }
      for (; O < this.length - A; O++)
        C = (this.words[O + A] | 0) + L, L = C >> 26, this.words[O + A] = C & 67108863;
      if (L === 0) return this.strip();
      for ($(L === -1), L = 0, O = 0; O < this.length; O++)
        C = -(this.words[O] | 0) + L, L = C >> 26, this.words[O] = C & 67108863;
      return this.negative = 1, this.strip();
    }, S.prototype._wordDiv = function(y, E) {
      var A = this.length - y.length, B = this.clone(), O = y, C = O.words[O.length - 1] | 0, L = this._countBits(C);
      A = 26 - L, A !== 0 && (O = O.ushln(A), B.iushln(A), C = O.words[O.length - 1] | 0);
      var P = B.length - O.length, _;
      if (E !== "mod") {
        _ = new S(null), _.length = P + 1, _.words = new Array(_.length);
        for (var I = 0; I < _.length; I++)
          _.words[I] = 0;
      }
      var U = B.clone()._ishlnsubmul(O, 1, P);
      U.negative === 0 && (B = U, _ && (_.words[P] = 1));
      for (var Y = P - 1; Y >= 0; Y--) {
        var te = (B.words[O.length + Y] | 0) * 67108864 + (B.words[O.length + Y - 1] | 0);
        for (te = Math.min(te / C | 0, 67108863), B._ishlnsubmul(O, te, Y); B.negative !== 0; )
          te--, B.negative = 0, B._ishlnsubmul(O, 1, Y), B.isZero() || (B.negative ^= 1);
        _ && (_.words[Y] = te);
      }
      return _ && _.strip(), B.strip(), E !== "div" && A !== 0 && B.iushrn(A), {
        div: _ || null,
        mod: B
      };
    }, S.prototype.divmod = function(y, E, A) {
      if ($(!y.isZero()), this.isZero())
        return {
          div: new S(0),
          mod: new S(0)
        };
      var B, O, C;
      return this.negative !== 0 && y.negative === 0 ? (C = this.neg().divmod(y, E), E !== "mod" && (B = C.div.neg()), E !== "div" && (O = C.mod.neg(), A && O.negative !== 0 && O.iadd(y)), {
        div: B,
        mod: O
      }) : this.negative === 0 && y.negative !== 0 ? (C = this.divmod(y.neg(), E), E !== "mod" && (B = C.div.neg()), {
        div: B,
        mod: C.mod
      }) : this.negative & y.negative ? (C = this.neg().divmod(y.neg(), E), E !== "div" && (O = C.mod.neg(), A && O.negative !== 0 && O.isub(y)), {
        div: C.div,
        mod: O
      }) : y.length > this.length || this.cmp(y) < 0 ? {
        div: new S(0),
        mod: this
      } : y.length === 1 ? E === "div" ? {
        div: this.divn(y.words[0]),
        mod: null
      } : E === "mod" ? {
        div: null,
        mod: new S(this.modn(y.words[0]))
      } : {
        div: this.divn(y.words[0]),
        mod: new S(this.modn(y.words[0]))
      } : this._wordDiv(y, E);
    }, S.prototype.div = function(y) {
      return this.divmod(y, "div", !1).div;
    }, S.prototype.mod = function(y) {
      return this.divmod(y, "mod", !1).mod;
    }, S.prototype.umod = function(y) {
      return this.divmod(y, "mod", !0).mod;
    }, S.prototype.divRound = function(y) {
      var E = this.divmod(y);
      if (E.mod.isZero()) return E.div;
      var A = E.div.negative !== 0 ? E.mod.isub(y) : E.mod, B = y.ushrn(1), O = y.andln(1), C = A.cmp(B);
      return C < 0 || O === 1 && C === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
    }, S.prototype.modn = function(y) {
      $(y <= 67108863);
      for (var E = (1 << 26) % y, A = 0, B = this.length - 1; B >= 0; B--)
        A = (E * A + (this.words[B] | 0)) % y;
      return A;
    }, S.prototype.idivn = function(y) {
      $(y <= 67108863);
      for (var E = 0, A = this.length - 1; A >= 0; A--) {
        var B = (this.words[A] | 0) + E * 67108864;
        this.words[A] = B / y | 0, E = B % y;
      }
      return this.strip();
    }, S.prototype.divn = function(y) {
      return this.clone().idivn(y);
    }, S.prototype.egcd = function(y) {
      $(y.negative === 0), $(!y.isZero());
      var E = this, A = y.clone();
      E.negative !== 0 ? E = E.umod(y) : E = E.clone();
      for (var B = new S(1), O = new S(0), C = new S(0), L = new S(1), P = 0; E.isEven() && A.isEven(); )
        E.iushrn(1), A.iushrn(1), ++P;
      for (var _ = A.clone(), I = E.clone(); !E.isZero(); ) {
        for (var U = 0, Y = 1; !(E.words[0] & Y) && U < 26; ++U, Y <<= 1) ;
        if (U > 0)
          for (E.iushrn(U); U-- > 0; )
            (B.isOdd() || O.isOdd()) && (B.iadd(_), O.isub(I)), B.iushrn(1), O.iushrn(1);
        for (var te = 0, oe = 1; !(A.words[0] & oe) && te < 26; ++te, oe <<= 1) ;
        if (te > 0)
          for (A.iushrn(te); te-- > 0; )
            (C.isOdd() || L.isOdd()) && (C.iadd(_), L.isub(I)), C.iushrn(1), L.iushrn(1);
        E.cmp(A) >= 0 ? (E.isub(A), B.isub(C), O.isub(L)) : (A.isub(E), C.isub(B), L.isub(O));
      }
      return {
        a: C,
        b: L,
        gcd: A.iushln(P)
      };
    }, S.prototype._invmp = function(y) {
      $(y.negative === 0), $(!y.isZero());
      var E = this, A = y.clone();
      E.negative !== 0 ? E = E.umod(y) : E = E.clone();
      for (var B = new S(1), O = new S(0), C = A.clone(); E.cmpn(1) > 0 && A.cmpn(1) > 0; ) {
        for (var L = 0, P = 1; !(E.words[0] & P) && L < 26; ++L, P <<= 1) ;
        if (L > 0)
          for (E.iushrn(L); L-- > 0; )
            B.isOdd() && B.iadd(C), B.iushrn(1);
        for (var _ = 0, I = 1; !(A.words[0] & I) && _ < 26; ++_, I <<= 1) ;
        if (_ > 0)
          for (A.iushrn(_); _-- > 0; )
            O.isOdd() && O.iadd(C), O.iushrn(1);
        E.cmp(A) >= 0 ? (E.isub(A), B.isub(O)) : (A.isub(E), O.isub(B));
      }
      var U;
      return E.cmpn(1) === 0 ? U = B : U = O, U.cmpn(0) < 0 && U.iadd(y), U;
    }, S.prototype.gcd = function(y) {
      if (this.isZero()) return y.abs();
      if (y.isZero()) return this.abs();
      var E = this.clone(), A = y.clone();
      E.negative = 0, A.negative = 0;
      for (var B = 0; E.isEven() && A.isEven(); B++)
        E.iushrn(1), A.iushrn(1);
      do {
        for (; E.isEven(); )
          E.iushrn(1);
        for (; A.isEven(); )
          A.iushrn(1);
        var O = E.cmp(A);
        if (O < 0) {
          var C = E;
          E = A, A = C;
        } else if (O === 0 || A.cmpn(1) === 0)
          break;
        E.isub(A);
      } while (!0);
      return A.iushln(B);
    }, S.prototype.invm = function(y) {
      return this.egcd(y).a.umod(y);
    }, S.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, S.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, S.prototype.andln = function(y) {
      return this.words[0] & y;
    }, S.prototype.bincn = function(y) {
      $(typeof y == "number");
      var E = y % 26, A = (y - E) / 26, B = 1 << E;
      if (this.length <= A)
        return this._expand(A + 1), this.words[A] |= B, this;
      for (var O = B, C = A; O !== 0 && C < this.length; C++) {
        var L = this.words[C] | 0;
        L += O, O = L >>> 26, L &= 67108863, this.words[C] = L;
      }
      return O !== 0 && (this.words[C] = O, this.length++), this;
    }, S.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, S.prototype.cmpn = function(y) {
      var E = y < 0;
      if (this.negative !== 0 && !E) return -1;
      if (this.negative === 0 && E) return 1;
      this.strip();
      var A;
      if (this.length > 1)
        A = 1;
      else {
        E && (y = -y), $(y <= 67108863, "Number is too big");
        var B = this.words[0] | 0;
        A = B === y ? 0 : B < y ? -1 : 1;
      }
      return this.negative !== 0 ? -A | 0 : A;
    }, S.prototype.cmp = function(y) {
      if (this.negative !== 0 && y.negative === 0) return -1;
      if (this.negative === 0 && y.negative !== 0) return 1;
      var E = this.ucmp(y);
      return this.negative !== 0 ? -E | 0 : E;
    }, S.prototype.ucmp = function(y) {
      if (this.length > y.length) return 1;
      if (this.length < y.length) return -1;
      for (var E = 0, A = this.length - 1; A >= 0; A--) {
        var B = this.words[A] | 0, O = y.words[A] | 0;
        if (B !== O) {
          B < O ? E = -1 : B > O && (E = 1);
          break;
        }
      }
      return E;
    }, S.prototype.gtn = function(y) {
      return this.cmpn(y) === 1;
    }, S.prototype.gt = function(y) {
      return this.cmp(y) === 1;
    }, S.prototype.gten = function(y) {
      return this.cmpn(y) >= 0;
    }, S.prototype.gte = function(y) {
      return this.cmp(y) >= 0;
    }, S.prototype.ltn = function(y) {
      return this.cmpn(y) === -1;
    }, S.prototype.lt = function(y) {
      return this.cmp(y) === -1;
    }, S.prototype.lten = function(y) {
      return this.cmpn(y) <= 0;
    }, S.prototype.lte = function(y) {
      return this.cmp(y) <= 0;
    }, S.prototype.eqn = function(y) {
      return this.cmpn(y) === 0;
    }, S.prototype.eq = function(y) {
      return this.cmp(y) === 0;
    }, S.red = function(y) {
      return new xe(y);
    }, S.prototype.toRed = function(y) {
      return $(!this.red, "Already a number in reduction context"), $(this.negative === 0, "red works only with positives"), y.convertTo(this)._forceRed(y);
    }, S.prototype.fromRed = function() {
      return $(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, S.prototype._forceRed = function(y) {
      return this.red = y, this;
    }, S.prototype.forceRed = function(y) {
      return $(!this.red, "Already a number in reduction context"), this._forceRed(y);
    }, S.prototype.redAdd = function(y) {
      return $(this.red, "redAdd works only with red numbers"), this.red.add(this, y);
    }, S.prototype.redIAdd = function(y) {
      return $(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, y);
    }, S.prototype.redSub = function(y) {
      return $(this.red, "redSub works only with red numbers"), this.red.sub(this, y);
    }, S.prototype.redISub = function(y) {
      return $(this.red, "redISub works only with red numbers"), this.red.isub(this, y);
    }, S.prototype.redShl = function(y) {
      return $(this.red, "redShl works only with red numbers"), this.red.shl(this, y);
    }, S.prototype.redMul = function(y) {
      return $(this.red, "redMul works only with red numbers"), this.red._verify2(this, y), this.red.mul(this, y);
    }, S.prototype.redIMul = function(y) {
      return $(this.red, "redMul works only with red numbers"), this.red._verify2(this, y), this.red.imul(this, y);
    }, S.prototype.redSqr = function() {
      return $(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, S.prototype.redISqr = function() {
      return $(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, S.prototype.redSqrt = function() {
      return $(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, S.prototype.redInvm = function() {
      return $(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, S.prototype.redNeg = function() {
      return $(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, S.prototype.redPow = function(y) {
      return $(this.red && !y.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, y);
    };
    var ge = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function pe(N, y) {
      this.name = N, this.p = new S(y, 16), this.n = this.p.bitLength(), this.k = new S(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    pe.prototype._tmp = function() {
      var y = new S(null);
      return y.words = new Array(Math.ceil(this.n / 13)), y;
    }, pe.prototype.ireduce = function(y) {
      var E = y, A;
      do
        this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), A = E.bitLength();
      while (A > this.n);
      var B = A < this.n ? -1 : E.ucmp(this.p);
      return B === 0 ? (E.words[0] = 0, E.length = 1) : B > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
    }, pe.prototype.split = function(y, E) {
      y.iushrn(this.n, 0, E);
    }, pe.prototype.imulK = function(y) {
      return y.imul(this.k);
    };
    function $e() {
      pe.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    T($e, pe), $e.prototype.split = function(y, E) {
      for (var A = 4194303, B = Math.min(y.length, 9), O = 0; O < B; O++)
        E.words[O] = y.words[O];
      if (E.length = B, y.length <= 9) {
        y.words[0] = 0, y.length = 1;
        return;
      }
      var C = y.words[9];
      for (E.words[E.length++] = C & A, O = 10; O < y.length; O++) {
        var L = y.words[O] | 0;
        y.words[O - 10] = (L & A) << 4 | C >>> 22, C = L;
      }
      C >>>= 22, y.words[O - 10] = C, C === 0 && y.length > 10 ? y.length -= 10 : y.length -= 9;
    }, $e.prototype.imulK = function(y) {
      y.words[y.length] = 0, y.words[y.length + 1] = 0, y.length += 2;
      for (var E = 0, A = 0; A < y.length; A++) {
        var B = y.words[A] | 0;
        E += B * 977, y.words[A] = E & 67108863, E = B * 64 + (E / 67108864 | 0);
      }
      return y.words[y.length - 1] === 0 && (y.length--, y.words[y.length - 1] === 0 && y.length--), y;
    };
    function Re() {
      pe.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    T(Re, pe);
    function Pe() {
      pe.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    T(Pe, pe);
    function Oe() {
      pe.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    T(Oe, pe), Oe.prototype.imulK = function(y) {
      for (var E = 0, A = 0; A < y.length; A++) {
        var B = (y.words[A] | 0) * 19 + E, O = B & 67108863;
        B >>>= 26, y.words[A] = O, E = B;
      }
      return E !== 0 && (y.words[y.length++] = E), y;
    }, S._prime = function(y) {
      if (ge[y]) return ge[y];
      var E;
      if (y === "k256")
        E = new $e();
      else if (y === "p224")
        E = new Re();
      else if (y === "p192")
        E = new Pe();
      else if (y === "p25519")
        E = new Oe();
      else
        throw new Error("Unknown prime " + y);
      return ge[y] = E, E;
    };
    function xe(N) {
      if (typeof N == "string") {
        var y = S._prime(N);
        this.m = y.p, this.prime = y;
      } else
        $(N.gtn(1), "modulus must be greater than 1"), this.m = N, this.prime = null;
    }
    xe.prototype._verify1 = function(y) {
      $(y.negative === 0, "red works only with positives"), $(y.red, "red works only with red numbers");
    }, xe.prototype._verify2 = function(y, E) {
      $((y.negative | E.negative) === 0, "red works only with positives"), $(
        y.red && y.red === E.red,
        "red works only with red numbers"
      );
    }, xe.prototype.imod = function(y) {
      return this.prime ? this.prime.ireduce(y)._forceRed(this) : y.umod(this.m)._forceRed(this);
    }, xe.prototype.neg = function(y) {
      return y.isZero() ? y.clone() : this.m.sub(y)._forceRed(this);
    }, xe.prototype.add = function(y, E) {
      this._verify2(y, E);
      var A = y.add(E);
      return A.cmp(this.m) >= 0 && A.isub(this.m), A._forceRed(this);
    }, xe.prototype.iadd = function(y, E) {
      this._verify2(y, E);
      var A = y.iadd(E);
      return A.cmp(this.m) >= 0 && A.isub(this.m), A;
    }, xe.prototype.sub = function(y, E) {
      this._verify2(y, E);
      var A = y.sub(E);
      return A.cmpn(0) < 0 && A.iadd(this.m), A._forceRed(this);
    }, xe.prototype.isub = function(y, E) {
      this._verify2(y, E);
      var A = y.isub(E);
      return A.cmpn(0) < 0 && A.iadd(this.m), A;
    }, xe.prototype.shl = function(y, E) {
      return this._verify1(y), this.imod(y.ushln(E));
    }, xe.prototype.imul = function(y, E) {
      return this._verify2(y, E), this.imod(y.imul(E));
    }, xe.prototype.mul = function(y, E) {
      return this._verify2(y, E), this.imod(y.mul(E));
    }, xe.prototype.isqr = function(y) {
      return this.imul(y, y.clone());
    }, xe.prototype.sqr = function(y) {
      return this.mul(y, y);
    }, xe.prototype.sqrt = function(y) {
      if (y.isZero()) return y.clone();
      var E = this.m.andln(3);
      if ($(E % 2 === 1), E === 3) {
        var A = this.m.add(new S(1)).iushrn(2);
        return this.pow(y, A);
      }
      for (var B = this.m.subn(1), O = 0; !B.isZero() && B.andln(1) === 0; )
        O++, B.iushrn(1);
      $(!B.isZero());
      var C = new S(1).toRed(this), L = C.redNeg(), P = this.m.subn(1).iushrn(1), _ = this.m.bitLength();
      for (_ = new S(2 * _ * _).toRed(this); this.pow(_, P).cmp(L) !== 0; )
        _.redIAdd(L);
      for (var I = this.pow(_, B), U = this.pow(y, B.addn(1).iushrn(1)), Y = this.pow(y, B), te = O; Y.cmp(C) !== 0; ) {
        for (var oe = Y, re = 0; oe.cmp(C) !== 0; re++)
          oe = oe.redSqr();
        $(re < te);
        var ee = this.pow(I, new S(1).iushln(te - re - 1));
        U = U.redMul(ee), I = ee.redSqr(), Y = Y.redMul(I), te = re;
      }
      return U;
    }, xe.prototype.invm = function(y) {
      var E = y._invmp(this.m);
      return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
    }, xe.prototype.pow = function(y, E) {
      if (E.isZero()) return new S(1).toRed(this);
      if (E.cmpn(1) === 0) return y.clone();
      var A = 4, B = new Array(1 << A);
      B[0] = new S(1).toRed(this), B[1] = y;
      for (var O = 2; O < B.length; O++)
        B[O] = this.mul(B[O - 1], y);
      var C = B[0], L = 0, P = 0, _ = E.bitLength() % 26;
      for (_ === 0 && (_ = 26), O = E.length - 1; O >= 0; O--) {
        for (var I = E.words[O], U = _ - 1; U >= 0; U--) {
          var Y = I >> U & 1;
          if (C !== B[0] && (C = this.sqr(C)), Y === 0 && L === 0) {
            P = 0;
            continue;
          }
          L <<= 1, L |= Y, P++, !(P !== A && (O !== 0 || U !== 0)) && (C = this.mul(C, B[L]), P = 0, L = 0);
        }
        _ = 26;
      }
      return C;
    }, xe.prototype.convertTo = function(y) {
      var E = y.umod(this.m);
      return E === y ? E.clone() : E;
    }, xe.prototype.convertFrom = function(y) {
      var E = y.clone();
      return E.red = null, E;
    }, S.mont = function(y) {
      return new rt(y);
    };
    function rt(N) {
      xe.call(this, N), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new S(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    T(rt, xe), rt.prototype.convertTo = function(y) {
      return this.imod(y.ushln(this.shift));
    }, rt.prototype.convertFrom = function(y) {
      var E = this.imod(y.mul(this.rinv));
      return E.red = null, E;
    }, rt.prototype.imul = function(y, E) {
      if (y.isZero() || E.isZero())
        return y.words[0] = 0, y.length = 1, y;
      var A = y.imul(E), B = A.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), O = A.isub(B).iushrn(this.shift), C = O;
      return O.cmp(this.m) >= 0 ? C = O.isub(this.m) : O.cmpn(0) < 0 && (C = O.iadd(this.m)), C._forceRed(this);
    }, rt.prototype.mul = function(y, E) {
      if (y.isZero() || E.isZero()) return new S(0)._forceRed(this);
      var A = y.mul(E), B = A.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), O = A.isub(B).iushrn(this.shift), C = O;
      return O.cmp(this.m) >= 0 ? C = O.isub(this.m) : O.cmpn(0) < 0 && (C = O.iadd(this.m)), C._forceRed(this);
    }, rt.prototype.invm = function(y) {
      var E = this.imod(y._invmp(this.m).mul(this.r2));
      return E._forceRed(this);
    };
  })(w, commonjsGlobal);
})(bn$1);
var bnExports$1 = bn$1.exports, browser$2, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser$2;
  hasRequiredBrowser = 1;
  var w = requireElliptic(), M = bnExports$1;
  browser$2 = function(D) {
    return new $(D);
  };
  var x = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  x.p224 = x.secp224r1, x.p256 = x.secp256r1 = x.prime256v1, x.p192 = x.secp192r1 = x.prime192v1, x.p384 = x.secp384r1, x.p521 = x.secp521r1;
  function $(S) {
    this.curveType = x[S], this.curveType || (this.curveType = {
      name: S
    }), this.curve = new w.ec(this.curveType.name), this.keys = void 0;
  }
  $.prototype.generateKeys = function(S, D) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(S, D);
  }, $.prototype.computeSecret = function(S, D, F) {
    D = D || "utf8", Buffer$D.isBuffer(S) || (S = new Buffer$D(S, D));
    var z = this.curve.keyFromPublic(S).getPublic(), Z = z.mul(this.keys.getPrivate()).getX();
    return T(Z, F, this.curveType.byteLength);
  }, $.prototype.getPublicKey = function(S, D) {
    var F = this.keys.getPublic(D === "compressed", !0);
    return D === "hybrid" && (F[F.length - 1] % 2 ? F[0] = 7 : F[0] = 6), T(F, S);
  }, $.prototype.getPrivateKey = function(S) {
    return T(this.keys.getPrivate(), S);
  }, $.prototype.setPublicKey = function(S, D) {
    return D = D || "utf8", Buffer$D.isBuffer(S) || (S = new Buffer$D(S, D)), this.keys._importPublic(S), this;
  }, $.prototype.setPrivateKey = function(S, D) {
    D = D || "utf8", Buffer$D.isBuffer(S) || (S = new Buffer$D(S, D));
    var F = new M(S);
    return F = F.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(F), this;
  };
  function T(S, D, F) {
    Array.isArray(S) || (S = S.toArray());
    var z = new Buffer$D(S);
    if (F && z.length < F) {
      var Z = new Buffer$D(F - z.length);
      Z.fill(0), z = Buffer$D.concat([Z, z]);
    }
    return D ? z.toString(D) : z;
  }
  return browser$2;
}
var browser$1 = {}, createHash$2 = browser$9, Buffer$4 = safeBufferExports$2.Buffer, mgf$2 = function(w, M) {
  for (var x = Buffer$4.alloc(0), $ = 0, T; x.length < M; )
    T = i2ops($++), x = Buffer$4.concat([x, createHash$2("sha1").update(w).update(T).digest()]);
  return x.slice(0, M);
};
function i2ops(w) {
  var M = Buffer$4.allocUnsafe(4);
  return M.writeUInt32BE(w, 0), M;
}
var xor$2 = function w(M, x) {
  for (var $ = M.length, T = -1; ++T < $; )
    M[T] ^= x[T];
  return M;
}, bn = { exports: {} };
bn.exports;
(function(w) {
  (function(M, x) {
    function $(N, y) {
      if (!N) throw new Error(y || "Assertion failed");
    }
    function T(N, y) {
      N.super_ = y;
      var E = function() {
      };
      E.prototype = y.prototype, N.prototype = new E(), N.prototype.constructor = N;
    }
    function S(N, y, E) {
      if (S.isBN(N))
        return N;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, N !== null && ((y === "le" || y === "be") && (E = y, y = 10), this._init(N || 0, y || 10, E || "be"));
    }
    typeof M == "object" ? M.exports = S : x.BN = S, S.BN = S, S.wordSize = 26;
    var D;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? D = window.Buffer : D = dist.Buffer;
    } catch {
    }
    S.isBN = function(y) {
      return y instanceof S ? !0 : y !== null && typeof y == "object" && y.constructor.wordSize === S.wordSize && Array.isArray(y.words);
    }, S.max = function(y, E) {
      return y.cmp(E) > 0 ? y : E;
    }, S.min = function(y, E) {
      return y.cmp(E) < 0 ? y : E;
    }, S.prototype._init = function(y, E, A) {
      if (typeof y == "number")
        return this._initNumber(y, E, A);
      if (typeof y == "object")
        return this._initArray(y, E, A);
      E === "hex" && (E = 16), $(E === (E | 0) && E >= 2 && E <= 36), y = y.toString().replace(/\s+/g, "");
      var B = 0;
      y[0] === "-" && (B++, this.negative = 1), B < y.length && (E === 16 ? this._parseHex(y, B, A) : (this._parseBase(y, E, B), A === "le" && this._initArray(this.toArray(), E, A)));
    }, S.prototype._initNumber = function(y, E, A) {
      y < 0 && (this.negative = 1, y = -y), y < 67108864 ? (this.words = [y & 67108863], this.length = 1) : y < 4503599627370496 ? (this.words = [
        y & 67108863,
        y / 67108864 & 67108863
      ], this.length = 2) : ($(y < 9007199254740992), this.words = [
        y & 67108863,
        y / 67108864 & 67108863,
        1
      ], this.length = 3), A === "le" && this._initArray(this.toArray(), E, A);
    }, S.prototype._initArray = function(y, E, A) {
      if ($(typeof y.length == "number"), y.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(y.length / 3), this.words = new Array(this.length);
      for (var B = 0; B < this.length; B++)
        this.words[B] = 0;
      var O, C, L = 0;
      if (A === "be")
        for (B = y.length - 1, O = 0; B >= 0; B -= 3)
          C = y[B] | y[B - 1] << 8 | y[B - 2] << 16, this.words[O] |= C << L & 67108863, this.words[O + 1] = C >>> 26 - L & 67108863, L += 24, L >= 26 && (L -= 26, O++);
      else if (A === "le")
        for (B = 0, O = 0; B < y.length; B += 3)
          C = y[B] | y[B + 1] << 8 | y[B + 2] << 16, this.words[O] |= C << L & 67108863, this.words[O + 1] = C >>> 26 - L & 67108863, L += 24, L >= 26 && (L -= 26, O++);
      return this.strip();
    };
    function F(N, y) {
      var E = N.charCodeAt(y);
      return E >= 65 && E <= 70 ? E - 55 : E >= 97 && E <= 102 ? E - 87 : E - 48 & 15;
    }
    function z(N, y, E) {
      var A = F(N, E);
      return E - 1 >= y && (A |= F(N, E - 1) << 4), A;
    }
    S.prototype._parseHex = function(y, E, A) {
      this.length = Math.ceil((y.length - E) / 6), this.words = new Array(this.length);
      for (var B = 0; B < this.length; B++)
        this.words[B] = 0;
      var O = 0, C = 0, L;
      if (A === "be")
        for (B = y.length - 1; B >= E; B -= 2)
          L = z(y, E, B) << O, this.words[C] |= L & 67108863, O >= 18 ? (O -= 18, C += 1, this.words[C] |= L >>> 26) : O += 8;
      else {
        var P = y.length - E;
        for (B = P % 2 === 0 ? E + 1 : E; B < y.length; B += 2)
          L = z(y, E, B) << O, this.words[C] |= L & 67108863, O >= 18 ? (O -= 18, C += 1, this.words[C] |= L >>> 26) : O += 8;
      }
      this.strip();
    };
    function Z(N, y, E, A) {
      for (var B = 0, O = Math.min(N.length, E), C = y; C < O; C++) {
        var L = N.charCodeAt(C) - 48;
        B *= A, L >= 49 ? B += L - 49 + 10 : L >= 17 ? B += L - 17 + 10 : B += L;
      }
      return B;
    }
    S.prototype._parseBase = function(y, E, A) {
      this.words = [0], this.length = 1;
      for (var B = 0, O = 1; O <= 67108863; O *= E)
        B++;
      B--, O = O / E | 0;
      for (var C = y.length - A, L = C % B, P = Math.min(C, C - L) + A, _ = 0, I = A; I < P; I += B)
        _ = Z(y, I, I + B, E), this.imuln(O), this.words[0] + _ < 67108864 ? this.words[0] += _ : this._iaddn(_);
      if (L !== 0) {
        var U = 1;
        for (_ = Z(y, I, y.length, E), I = 0; I < L; I++)
          U *= E;
        this.imuln(U), this.words[0] + _ < 67108864 ? this.words[0] += _ : this._iaddn(_);
      }
      this.strip();
    }, S.prototype.copy = function(y) {
      y.words = new Array(this.length);
      for (var E = 0; E < this.length; E++)
        y.words[E] = this.words[E];
      y.length = this.length, y.negative = this.negative, y.red = this.red;
    }, S.prototype.clone = function() {
      var y = new S(null);
      return this.copy(y), y;
    }, S.prototype._expand = function(y) {
      for (; this.length < y; )
        this.words[this.length++] = 0;
      return this;
    }, S.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, S.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, S.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var H = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], V = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], X = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    S.prototype.toString = function(y, E) {
      y = y || 10, E = E | 0 || 1;
      var A;
      if (y === 16 || y === "hex") {
        A = "";
        for (var B = 0, O = 0, C = 0; C < this.length; C++) {
          var L = this.words[C], P = ((L << B | O) & 16777215).toString(16);
          O = L >>> 24 - B & 16777215, B += 2, B >= 26 && (B -= 26, C--), O !== 0 || C !== this.length - 1 ? A = H[6 - P.length] + P + A : A = P + A;
        }
        for (O !== 0 && (A = O.toString(16) + A); A.length % E !== 0; )
          A = "0" + A;
        return this.negative !== 0 && (A = "-" + A), A;
      }
      if (y === (y | 0) && y >= 2 && y <= 36) {
        var _ = V[y], I = X[y];
        A = "";
        var U = this.clone();
        for (U.negative = 0; !U.isZero(); ) {
          var Y = U.modn(I).toString(y);
          U = U.idivn(I), U.isZero() ? A = Y + A : A = H[_ - Y.length] + Y + A;
        }
        for (this.isZero() && (A = "0" + A); A.length % E !== 0; )
          A = "0" + A;
        return this.negative !== 0 && (A = "-" + A), A;
      }
      $(!1, "Base should be between 2 and 36");
    }, S.prototype.toNumber = function() {
      var y = this.words[0];
      return this.length === 2 ? y += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? y += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && $(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -y : y;
    }, S.prototype.toJSON = function() {
      return this.toString(16);
    }, S.prototype.toBuffer = function(y, E) {
      return $(typeof D < "u"), this.toArrayLike(D, y, E);
    }, S.prototype.toArray = function(y, E) {
      return this.toArrayLike(Array, y, E);
    }, S.prototype.toArrayLike = function(y, E, A) {
      var B = this.byteLength(), O = A || Math.max(1, B);
      $(B <= O, "byte array longer than desired length"), $(O > 0, "Requested array length <= 0"), this.strip();
      var C = E === "le", L = new y(O), P, _, I = this.clone();
      if (C) {
        for (_ = 0; !I.isZero(); _++)
          P = I.andln(255), I.iushrn(8), L[_] = P;
        for (; _ < O; _++)
          L[_] = 0;
      } else {
        for (_ = 0; _ < O - B; _++)
          L[_] = 0;
        for (_ = 0; !I.isZero(); _++)
          P = I.andln(255), I.iushrn(8), L[O - _ - 1] = P;
      }
      return L;
    }, Math.clz32 ? S.prototype._countBits = function(y) {
      return 32 - Math.clz32(y);
    } : S.prototype._countBits = function(y) {
      var E = y, A = 0;
      return E >= 4096 && (A += 13, E >>>= 13), E >= 64 && (A += 7, E >>>= 7), E >= 8 && (A += 4, E >>>= 4), E >= 2 && (A += 2, E >>>= 2), A + E;
    }, S.prototype._zeroBits = function(y) {
      if (y === 0) return 26;
      var E = y, A = 0;
      return E & 8191 || (A += 13, E >>>= 13), E & 127 || (A += 7, E >>>= 7), E & 15 || (A += 4, E >>>= 4), E & 3 || (A += 2, E >>>= 2), E & 1 || A++, A;
    }, S.prototype.bitLength = function() {
      var y = this.words[this.length - 1], E = this._countBits(y);
      return (this.length - 1) * 26 + E;
    };
    function Q(N) {
      for (var y = new Array(N.bitLength()), E = 0; E < y.length; E++) {
        var A = E / 26 | 0, B = E % 26;
        y[E] = (N.words[A] & 1 << B) >>> B;
      }
      return y;
    }
    S.prototype.zeroBits = function() {
      if (this.isZero()) return 0;
      for (var y = 0, E = 0; E < this.length; E++) {
        var A = this._zeroBits(this.words[E]);
        if (y += A, A !== 26) break;
      }
      return y;
    }, S.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, S.prototype.toTwos = function(y) {
      return this.negative !== 0 ? this.abs().inotn(y).iaddn(1) : this.clone();
    }, S.prototype.fromTwos = function(y) {
      return this.testn(y - 1) ? this.notn(y).iaddn(1).ineg() : this.clone();
    }, S.prototype.isNeg = function() {
      return this.negative !== 0;
    }, S.prototype.neg = function() {
      return this.clone().ineg();
    }, S.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, S.prototype.iuor = function(y) {
      for (; this.length < y.length; )
        this.words[this.length++] = 0;
      for (var E = 0; E < y.length; E++)
        this.words[E] = this.words[E] | y.words[E];
      return this.strip();
    }, S.prototype.ior = function(y) {
      return $((this.negative | y.negative) === 0), this.iuor(y);
    }, S.prototype.or = function(y) {
      return this.length > y.length ? this.clone().ior(y) : y.clone().ior(this);
    }, S.prototype.uor = function(y) {
      return this.length > y.length ? this.clone().iuor(y) : y.clone().iuor(this);
    }, S.prototype.iuand = function(y) {
      var E;
      this.length > y.length ? E = y : E = this;
      for (var A = 0; A < E.length; A++)
        this.words[A] = this.words[A] & y.words[A];
      return this.length = E.length, this.strip();
    }, S.prototype.iand = function(y) {
      return $((this.negative | y.negative) === 0), this.iuand(y);
    }, S.prototype.and = function(y) {
      return this.length > y.length ? this.clone().iand(y) : y.clone().iand(this);
    }, S.prototype.uand = function(y) {
      return this.length > y.length ? this.clone().iuand(y) : y.clone().iuand(this);
    }, S.prototype.iuxor = function(y) {
      var E, A;
      this.length > y.length ? (E = this, A = y) : (E = y, A = this);
      for (var B = 0; B < A.length; B++)
        this.words[B] = E.words[B] ^ A.words[B];
      if (this !== E)
        for (; B < E.length; B++)
          this.words[B] = E.words[B];
      return this.length = E.length, this.strip();
    }, S.prototype.ixor = function(y) {
      return $((this.negative | y.negative) === 0), this.iuxor(y);
    }, S.prototype.xor = function(y) {
      return this.length > y.length ? this.clone().ixor(y) : y.clone().ixor(this);
    }, S.prototype.uxor = function(y) {
      return this.length > y.length ? this.clone().iuxor(y) : y.clone().iuxor(this);
    }, S.prototype.inotn = function(y) {
      $(typeof y == "number" && y >= 0);
      var E = Math.ceil(y / 26) | 0, A = y % 26;
      this._expand(E), A > 0 && E--;
      for (var B = 0; B < E; B++)
        this.words[B] = ~this.words[B] & 67108863;
      return A > 0 && (this.words[B] = ~this.words[B] & 67108863 >> 26 - A), this.strip();
    }, S.prototype.notn = function(y) {
      return this.clone().inotn(y);
    }, S.prototype.setn = function(y, E) {
      $(typeof y == "number" && y >= 0);
      var A = y / 26 | 0, B = y % 26;
      return this._expand(A + 1), E ? this.words[A] = this.words[A] | 1 << B : this.words[A] = this.words[A] & ~(1 << B), this.strip();
    }, S.prototype.iadd = function(y) {
      var E;
      if (this.negative !== 0 && y.negative === 0)
        return this.negative = 0, E = this.isub(y), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && y.negative !== 0)
        return y.negative = 0, E = this.isub(y), y.negative = 1, E._normSign();
      var A, B;
      this.length > y.length ? (A = this, B = y) : (A = y, B = this);
      for (var O = 0, C = 0; C < B.length; C++)
        E = (A.words[C] | 0) + (B.words[C] | 0) + O, this.words[C] = E & 67108863, O = E >>> 26;
      for (; O !== 0 && C < A.length; C++)
        E = (A.words[C] | 0) + O, this.words[C] = E & 67108863, O = E >>> 26;
      if (this.length = A.length, O !== 0)
        this.words[this.length] = O, this.length++;
      else if (A !== this)
        for (; C < A.length; C++)
          this.words[C] = A.words[C];
      return this;
    }, S.prototype.add = function(y) {
      var E;
      return y.negative !== 0 && this.negative === 0 ? (y.negative = 0, E = this.sub(y), y.negative ^= 1, E) : y.negative === 0 && this.negative !== 0 ? (this.negative = 0, E = y.sub(this), this.negative = 1, E) : this.length > y.length ? this.clone().iadd(y) : y.clone().iadd(this);
    }, S.prototype.isub = function(y) {
      if (y.negative !== 0) {
        y.negative = 0;
        var E = this.iadd(y);
        return y.negative = 1, E._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(y), this.negative = 1, this._normSign();
      var A = this.cmp(y);
      if (A === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var B, O;
      A > 0 ? (B = this, O = y) : (B = y, O = this);
      for (var C = 0, L = 0; L < O.length; L++)
        E = (B.words[L] | 0) - (O.words[L] | 0) + C, C = E >> 26, this.words[L] = E & 67108863;
      for (; C !== 0 && L < B.length; L++)
        E = (B.words[L] | 0) + C, C = E >> 26, this.words[L] = E & 67108863;
      if (C === 0 && L < B.length && B !== this)
        for (; L < B.length; L++)
          this.words[L] = B.words[L];
      return this.length = Math.max(this.length, L), B !== this && (this.negative = 1), this.strip();
    }, S.prototype.sub = function(y) {
      return this.clone().isub(y);
    };
    function fe(N, y, E) {
      E.negative = y.negative ^ N.negative;
      var A = N.length + y.length | 0;
      E.length = A, A = A - 1 | 0;
      var B = N.words[0] | 0, O = y.words[0] | 0, C = B * O, L = C & 67108863, P = C / 67108864 | 0;
      E.words[0] = L;
      for (var _ = 1; _ < A; _++) {
        for (var I = P >>> 26, U = P & 67108863, Y = Math.min(_, y.length - 1), te = Math.max(0, _ - N.length + 1); te <= Y; te++) {
          var oe = _ - te | 0;
          B = N.words[oe] | 0, O = y.words[te] | 0, C = B * O + U, I += C / 67108864 | 0, U = C & 67108863;
        }
        E.words[_] = U | 0, P = I | 0;
      }
      return P !== 0 ? E.words[_] = P | 0 : E.length--, E.strip();
    }
    var ce = function(y, E, A) {
      var B = y.words, O = E.words, C = A.words, L = 0, P, _, I, U = B[0] | 0, Y = U & 8191, te = U >>> 13, oe = B[1] | 0, re = oe & 8191, ee = oe >>> 13, ae = B[2] | 0, ue = ae & 8191, ye = ae >>> 13, ve = B[3] | 0, he = ve & 8191, Me = ve >>> 13, Qe = B[4] | 0, Ie = Qe & 8191, De = Qe >>> 13, at = B[5] | 0, ke = at & 8191, Se = at >>> 13, lt = B[6] | 0, qe = lt & 8191, He = lt >>> 13, ot = B[7] | 0, be = ot & 8191, _e = ot >>> 13, it = B[8] | 0, Ae = it & 8191, Be = it >>> 13, nt = B[9] | 0, Te = nt & 8191, Ue = nt >>> 13, st = O[0] | 0, Le = st & 8191, Ge = st >>> 13, pt = O[1] | 0, je = pt & 8191, Je = pt >>> 13, dt = O[2] | 0, ze = dt & 8191, et = dt >>> 13, yt = O[3] | 0, Ke = yt & 8191, Ye = yt >>> 13, gt = O[4] | 0, We = gt & 8191, Xe = gt >>> 13, bt = O[5] | 0, se = bt & 8191, J = bt >>> 13, ie = O[6] | 0, le = ie & 8191, we = ie >>> 13, Ce = O[7] | 0, Ee = Ce & 8191, Fe = Ce >>> 13, ut = O[8] | 0, Ne = ut & 8191, Ve = ut >>> 13, ht = O[9] | 0, Ze = ht & 8191, tt = ht >>> 13;
      A.negative = y.negative ^ E.negative, A.length = 19, P = Math.imul(Y, Le), _ = Math.imul(Y, Ge), _ = _ + Math.imul(te, Le) | 0, I = Math.imul(te, Ge);
      var vt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (vt >>> 26) | 0, vt &= 67108863, P = Math.imul(re, Le), _ = Math.imul(re, Ge), _ = _ + Math.imul(ee, Le) | 0, I = Math.imul(ee, Ge), P = P + Math.imul(Y, je) | 0, _ = _ + Math.imul(Y, Je) | 0, _ = _ + Math.imul(te, je) | 0, I = I + Math.imul(te, Je) | 0;
      var mt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (mt >>> 26) | 0, mt &= 67108863, P = Math.imul(ue, Le), _ = Math.imul(ue, Ge), _ = _ + Math.imul(ye, Le) | 0, I = Math.imul(ye, Ge), P = P + Math.imul(re, je) | 0, _ = _ + Math.imul(re, Je) | 0, _ = _ + Math.imul(ee, je) | 0, I = I + Math.imul(ee, Je) | 0, P = P + Math.imul(Y, ze) | 0, _ = _ + Math.imul(Y, et) | 0, _ = _ + Math.imul(te, ze) | 0, I = I + Math.imul(te, et) | 0;
      var wt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (wt >>> 26) | 0, wt &= 67108863, P = Math.imul(he, Le), _ = Math.imul(he, Ge), _ = _ + Math.imul(Me, Le) | 0, I = Math.imul(Me, Ge), P = P + Math.imul(ue, je) | 0, _ = _ + Math.imul(ue, Je) | 0, _ = _ + Math.imul(ye, je) | 0, I = I + Math.imul(ye, Je) | 0, P = P + Math.imul(re, ze) | 0, _ = _ + Math.imul(re, et) | 0, _ = _ + Math.imul(ee, ze) | 0, I = I + Math.imul(ee, et) | 0, P = P + Math.imul(Y, Ke) | 0, _ = _ + Math.imul(Y, Ye) | 0, _ = _ + Math.imul(te, Ke) | 0, I = I + Math.imul(te, Ye) | 0;
      var Mt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Mt >>> 26) | 0, Mt &= 67108863, P = Math.imul(Ie, Le), _ = Math.imul(Ie, Ge), _ = _ + Math.imul(De, Le) | 0, I = Math.imul(De, Ge), P = P + Math.imul(he, je) | 0, _ = _ + Math.imul(he, Je) | 0, _ = _ + Math.imul(Me, je) | 0, I = I + Math.imul(Me, Je) | 0, P = P + Math.imul(ue, ze) | 0, _ = _ + Math.imul(ue, et) | 0, _ = _ + Math.imul(ye, ze) | 0, I = I + Math.imul(ye, et) | 0, P = P + Math.imul(re, Ke) | 0, _ = _ + Math.imul(re, Ye) | 0, _ = _ + Math.imul(ee, Ke) | 0, I = I + Math.imul(ee, Ye) | 0, P = P + Math.imul(Y, We) | 0, _ = _ + Math.imul(Y, Xe) | 0, _ = _ + Math.imul(te, We) | 0, I = I + Math.imul(te, Xe) | 0;
      var _t = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (_t >>> 26) | 0, _t &= 67108863, P = Math.imul(ke, Le), _ = Math.imul(ke, Ge), _ = _ + Math.imul(Se, Le) | 0, I = Math.imul(Se, Ge), P = P + Math.imul(Ie, je) | 0, _ = _ + Math.imul(Ie, Je) | 0, _ = _ + Math.imul(De, je) | 0, I = I + Math.imul(De, Je) | 0, P = P + Math.imul(he, ze) | 0, _ = _ + Math.imul(he, et) | 0, _ = _ + Math.imul(Me, ze) | 0, I = I + Math.imul(Me, et) | 0, P = P + Math.imul(ue, Ke) | 0, _ = _ + Math.imul(ue, Ye) | 0, _ = _ + Math.imul(ye, Ke) | 0, I = I + Math.imul(ye, Ye) | 0, P = P + Math.imul(re, We) | 0, _ = _ + Math.imul(re, Xe) | 0, _ = _ + Math.imul(ee, We) | 0, I = I + Math.imul(ee, Xe) | 0, P = P + Math.imul(Y, se) | 0, _ = _ + Math.imul(Y, J) | 0, _ = _ + Math.imul(te, se) | 0, I = I + Math.imul(te, J) | 0;
      var xt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (xt >>> 26) | 0, xt &= 67108863, P = Math.imul(qe, Le), _ = Math.imul(qe, Ge), _ = _ + Math.imul(He, Le) | 0, I = Math.imul(He, Ge), P = P + Math.imul(ke, je) | 0, _ = _ + Math.imul(ke, Je) | 0, _ = _ + Math.imul(Se, je) | 0, I = I + Math.imul(Se, Je) | 0, P = P + Math.imul(Ie, ze) | 0, _ = _ + Math.imul(Ie, et) | 0, _ = _ + Math.imul(De, ze) | 0, I = I + Math.imul(De, et) | 0, P = P + Math.imul(he, Ke) | 0, _ = _ + Math.imul(he, Ye) | 0, _ = _ + Math.imul(Me, Ke) | 0, I = I + Math.imul(Me, Ye) | 0, P = P + Math.imul(ue, We) | 0, _ = _ + Math.imul(ue, Xe) | 0, _ = _ + Math.imul(ye, We) | 0, I = I + Math.imul(ye, Xe) | 0, P = P + Math.imul(re, se) | 0, _ = _ + Math.imul(re, J) | 0, _ = _ + Math.imul(ee, se) | 0, I = I + Math.imul(ee, J) | 0, P = P + Math.imul(Y, le) | 0, _ = _ + Math.imul(Y, we) | 0, _ = _ + Math.imul(te, le) | 0, I = I + Math.imul(te, we) | 0;
      var Et = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Et >>> 26) | 0, Et &= 67108863, P = Math.imul(be, Le), _ = Math.imul(be, Ge), _ = _ + Math.imul(_e, Le) | 0, I = Math.imul(_e, Ge), P = P + Math.imul(qe, je) | 0, _ = _ + Math.imul(qe, Je) | 0, _ = _ + Math.imul(He, je) | 0, I = I + Math.imul(He, Je) | 0, P = P + Math.imul(ke, ze) | 0, _ = _ + Math.imul(ke, et) | 0, _ = _ + Math.imul(Se, ze) | 0, I = I + Math.imul(Se, et) | 0, P = P + Math.imul(Ie, Ke) | 0, _ = _ + Math.imul(Ie, Ye) | 0, _ = _ + Math.imul(De, Ke) | 0, I = I + Math.imul(De, Ye) | 0, P = P + Math.imul(he, We) | 0, _ = _ + Math.imul(he, Xe) | 0, _ = _ + Math.imul(Me, We) | 0, I = I + Math.imul(Me, Xe) | 0, P = P + Math.imul(ue, se) | 0, _ = _ + Math.imul(ue, J) | 0, _ = _ + Math.imul(ye, se) | 0, I = I + Math.imul(ye, J) | 0, P = P + Math.imul(re, le) | 0, _ = _ + Math.imul(re, we) | 0, _ = _ + Math.imul(ee, le) | 0, I = I + Math.imul(ee, we) | 0, P = P + Math.imul(Y, Ee) | 0, _ = _ + Math.imul(Y, Fe) | 0, _ = _ + Math.imul(te, Ee) | 0, I = I + Math.imul(te, Fe) | 0;
      var St = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (St >>> 26) | 0, St &= 67108863, P = Math.imul(Ae, Le), _ = Math.imul(Ae, Ge), _ = _ + Math.imul(Be, Le) | 0, I = Math.imul(Be, Ge), P = P + Math.imul(be, je) | 0, _ = _ + Math.imul(be, Je) | 0, _ = _ + Math.imul(_e, je) | 0, I = I + Math.imul(_e, Je) | 0, P = P + Math.imul(qe, ze) | 0, _ = _ + Math.imul(qe, et) | 0, _ = _ + Math.imul(He, ze) | 0, I = I + Math.imul(He, et) | 0, P = P + Math.imul(ke, Ke) | 0, _ = _ + Math.imul(ke, Ye) | 0, _ = _ + Math.imul(Se, Ke) | 0, I = I + Math.imul(Se, Ye) | 0, P = P + Math.imul(Ie, We) | 0, _ = _ + Math.imul(Ie, Xe) | 0, _ = _ + Math.imul(De, We) | 0, I = I + Math.imul(De, Xe) | 0, P = P + Math.imul(he, se) | 0, _ = _ + Math.imul(he, J) | 0, _ = _ + Math.imul(Me, se) | 0, I = I + Math.imul(Me, J) | 0, P = P + Math.imul(ue, le) | 0, _ = _ + Math.imul(ue, we) | 0, _ = _ + Math.imul(ye, le) | 0, I = I + Math.imul(ye, we) | 0, P = P + Math.imul(re, Ee) | 0, _ = _ + Math.imul(re, Fe) | 0, _ = _ + Math.imul(ee, Ee) | 0, I = I + Math.imul(ee, Fe) | 0, P = P + Math.imul(Y, Ne) | 0, _ = _ + Math.imul(Y, Ve) | 0, _ = _ + Math.imul(te, Ne) | 0, I = I + Math.imul(te, Ve) | 0;
      var $t = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + ($t >>> 26) | 0, $t &= 67108863, P = Math.imul(Te, Le), _ = Math.imul(Te, Ge), _ = _ + Math.imul(Ue, Le) | 0, I = Math.imul(Ue, Ge), P = P + Math.imul(Ae, je) | 0, _ = _ + Math.imul(Ae, Je) | 0, _ = _ + Math.imul(Be, je) | 0, I = I + Math.imul(Be, Je) | 0, P = P + Math.imul(be, ze) | 0, _ = _ + Math.imul(be, et) | 0, _ = _ + Math.imul(_e, ze) | 0, I = I + Math.imul(_e, et) | 0, P = P + Math.imul(qe, Ke) | 0, _ = _ + Math.imul(qe, Ye) | 0, _ = _ + Math.imul(He, Ke) | 0, I = I + Math.imul(He, Ye) | 0, P = P + Math.imul(ke, We) | 0, _ = _ + Math.imul(ke, Xe) | 0, _ = _ + Math.imul(Se, We) | 0, I = I + Math.imul(Se, Xe) | 0, P = P + Math.imul(Ie, se) | 0, _ = _ + Math.imul(Ie, J) | 0, _ = _ + Math.imul(De, se) | 0, I = I + Math.imul(De, J) | 0, P = P + Math.imul(he, le) | 0, _ = _ + Math.imul(he, we) | 0, _ = _ + Math.imul(Me, le) | 0, I = I + Math.imul(Me, we) | 0, P = P + Math.imul(ue, Ee) | 0, _ = _ + Math.imul(ue, Fe) | 0, _ = _ + Math.imul(ye, Ee) | 0, I = I + Math.imul(ye, Fe) | 0, P = P + Math.imul(re, Ne) | 0, _ = _ + Math.imul(re, Ve) | 0, _ = _ + Math.imul(ee, Ne) | 0, I = I + Math.imul(ee, Ve) | 0, P = P + Math.imul(Y, Ze) | 0, _ = _ + Math.imul(Y, tt) | 0, _ = _ + Math.imul(te, Ze) | 0, I = I + Math.imul(te, tt) | 0;
      var At = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, P = Math.imul(Te, je), _ = Math.imul(Te, Je), _ = _ + Math.imul(Ue, je) | 0, I = Math.imul(Ue, Je), P = P + Math.imul(Ae, ze) | 0, _ = _ + Math.imul(Ae, et) | 0, _ = _ + Math.imul(Be, ze) | 0, I = I + Math.imul(Be, et) | 0, P = P + Math.imul(be, Ke) | 0, _ = _ + Math.imul(be, Ye) | 0, _ = _ + Math.imul(_e, Ke) | 0, I = I + Math.imul(_e, Ye) | 0, P = P + Math.imul(qe, We) | 0, _ = _ + Math.imul(qe, Xe) | 0, _ = _ + Math.imul(He, We) | 0, I = I + Math.imul(He, Xe) | 0, P = P + Math.imul(ke, se) | 0, _ = _ + Math.imul(ke, J) | 0, _ = _ + Math.imul(Se, se) | 0, I = I + Math.imul(Se, J) | 0, P = P + Math.imul(Ie, le) | 0, _ = _ + Math.imul(Ie, we) | 0, _ = _ + Math.imul(De, le) | 0, I = I + Math.imul(De, we) | 0, P = P + Math.imul(he, Ee) | 0, _ = _ + Math.imul(he, Fe) | 0, _ = _ + Math.imul(Me, Ee) | 0, I = I + Math.imul(Me, Fe) | 0, P = P + Math.imul(ue, Ne) | 0, _ = _ + Math.imul(ue, Ve) | 0, _ = _ + Math.imul(ye, Ne) | 0, I = I + Math.imul(ye, Ve) | 0, P = P + Math.imul(re, Ze) | 0, _ = _ + Math.imul(re, tt) | 0, _ = _ + Math.imul(ee, Ze) | 0, I = I + Math.imul(ee, tt) | 0;
      var Rt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Rt >>> 26) | 0, Rt &= 67108863, P = Math.imul(Te, ze), _ = Math.imul(Te, et), _ = _ + Math.imul(Ue, ze) | 0, I = Math.imul(Ue, et), P = P + Math.imul(Ae, Ke) | 0, _ = _ + Math.imul(Ae, Ye) | 0, _ = _ + Math.imul(Be, Ke) | 0, I = I + Math.imul(Be, Ye) | 0, P = P + Math.imul(be, We) | 0, _ = _ + Math.imul(be, Xe) | 0, _ = _ + Math.imul(_e, We) | 0, I = I + Math.imul(_e, Xe) | 0, P = P + Math.imul(qe, se) | 0, _ = _ + Math.imul(qe, J) | 0, _ = _ + Math.imul(He, se) | 0, I = I + Math.imul(He, J) | 0, P = P + Math.imul(ke, le) | 0, _ = _ + Math.imul(ke, we) | 0, _ = _ + Math.imul(Se, le) | 0, I = I + Math.imul(Se, we) | 0, P = P + Math.imul(Ie, Ee) | 0, _ = _ + Math.imul(Ie, Fe) | 0, _ = _ + Math.imul(De, Ee) | 0, I = I + Math.imul(De, Fe) | 0, P = P + Math.imul(he, Ne) | 0, _ = _ + Math.imul(he, Ve) | 0, _ = _ + Math.imul(Me, Ne) | 0, I = I + Math.imul(Me, Ve) | 0, P = P + Math.imul(ue, Ze) | 0, _ = _ + Math.imul(ue, tt) | 0, _ = _ + Math.imul(ye, Ze) | 0, I = I + Math.imul(ye, tt) | 0;
      var Bt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, P = Math.imul(Te, Ke), _ = Math.imul(Te, Ye), _ = _ + Math.imul(Ue, Ke) | 0, I = Math.imul(Ue, Ye), P = P + Math.imul(Ae, We) | 0, _ = _ + Math.imul(Ae, Xe) | 0, _ = _ + Math.imul(Be, We) | 0, I = I + Math.imul(Be, Xe) | 0, P = P + Math.imul(be, se) | 0, _ = _ + Math.imul(be, J) | 0, _ = _ + Math.imul(_e, se) | 0, I = I + Math.imul(_e, J) | 0, P = P + Math.imul(qe, le) | 0, _ = _ + Math.imul(qe, we) | 0, _ = _ + Math.imul(He, le) | 0, I = I + Math.imul(He, we) | 0, P = P + Math.imul(ke, Ee) | 0, _ = _ + Math.imul(ke, Fe) | 0, _ = _ + Math.imul(Se, Ee) | 0, I = I + Math.imul(Se, Fe) | 0, P = P + Math.imul(Ie, Ne) | 0, _ = _ + Math.imul(Ie, Ve) | 0, _ = _ + Math.imul(De, Ne) | 0, I = I + Math.imul(De, Ve) | 0, P = P + Math.imul(he, Ze) | 0, _ = _ + Math.imul(he, tt) | 0, _ = _ + Math.imul(Me, Ze) | 0, I = I + Math.imul(Me, tt) | 0;
      var Tt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Tt >>> 26) | 0, Tt &= 67108863, P = Math.imul(Te, We), _ = Math.imul(Te, Xe), _ = _ + Math.imul(Ue, We) | 0, I = Math.imul(Ue, Xe), P = P + Math.imul(Ae, se) | 0, _ = _ + Math.imul(Ae, J) | 0, _ = _ + Math.imul(Be, se) | 0, I = I + Math.imul(Be, J) | 0, P = P + Math.imul(be, le) | 0, _ = _ + Math.imul(be, we) | 0, _ = _ + Math.imul(_e, le) | 0, I = I + Math.imul(_e, we) | 0, P = P + Math.imul(qe, Ee) | 0, _ = _ + Math.imul(qe, Fe) | 0, _ = _ + Math.imul(He, Ee) | 0, I = I + Math.imul(He, Fe) | 0, P = P + Math.imul(ke, Ne) | 0, _ = _ + Math.imul(ke, Ve) | 0, _ = _ + Math.imul(Se, Ne) | 0, I = I + Math.imul(Se, Ve) | 0, P = P + Math.imul(Ie, Ze) | 0, _ = _ + Math.imul(Ie, tt) | 0, _ = _ + Math.imul(De, Ze) | 0, I = I + Math.imul(De, tt) | 0;
      var Pt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Pt >>> 26) | 0, Pt &= 67108863, P = Math.imul(Te, se), _ = Math.imul(Te, J), _ = _ + Math.imul(Ue, se) | 0, I = Math.imul(Ue, J), P = P + Math.imul(Ae, le) | 0, _ = _ + Math.imul(Ae, we) | 0, _ = _ + Math.imul(Be, le) | 0, I = I + Math.imul(Be, we) | 0, P = P + Math.imul(be, Ee) | 0, _ = _ + Math.imul(be, Fe) | 0, _ = _ + Math.imul(_e, Ee) | 0, I = I + Math.imul(_e, Fe) | 0, P = P + Math.imul(qe, Ne) | 0, _ = _ + Math.imul(qe, Ve) | 0, _ = _ + Math.imul(He, Ne) | 0, I = I + Math.imul(He, Ve) | 0, P = P + Math.imul(ke, Ze) | 0, _ = _ + Math.imul(ke, tt) | 0, _ = _ + Math.imul(Se, Ze) | 0, I = I + Math.imul(Se, tt) | 0;
      var It = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (It >>> 26) | 0, It &= 67108863, P = Math.imul(Te, le), _ = Math.imul(Te, we), _ = _ + Math.imul(Ue, le) | 0, I = Math.imul(Ue, we), P = P + Math.imul(Ae, Ee) | 0, _ = _ + Math.imul(Ae, Fe) | 0, _ = _ + Math.imul(Be, Ee) | 0, I = I + Math.imul(Be, Fe) | 0, P = P + Math.imul(be, Ne) | 0, _ = _ + Math.imul(be, Ve) | 0, _ = _ + Math.imul(_e, Ne) | 0, I = I + Math.imul(_e, Ve) | 0, P = P + Math.imul(qe, Ze) | 0, _ = _ + Math.imul(qe, tt) | 0, _ = _ + Math.imul(He, Ze) | 0, I = I + Math.imul(He, tt) | 0;
      var Ot = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Ot >>> 26) | 0, Ot &= 67108863, P = Math.imul(Te, Ee), _ = Math.imul(Te, Fe), _ = _ + Math.imul(Ue, Ee) | 0, I = Math.imul(Ue, Fe), P = P + Math.imul(Ae, Ne) | 0, _ = _ + Math.imul(Ae, Ve) | 0, _ = _ + Math.imul(Be, Ne) | 0, I = I + Math.imul(Be, Ve) | 0, P = P + Math.imul(be, Ze) | 0, _ = _ + Math.imul(be, tt) | 0, _ = _ + Math.imul(_e, Ze) | 0, I = I + Math.imul(_e, tt) | 0;
      var Ct = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Ct >>> 26) | 0, Ct &= 67108863, P = Math.imul(Te, Ne), _ = Math.imul(Te, Ve), _ = _ + Math.imul(Ue, Ne) | 0, I = Math.imul(Ue, Ve), P = P + Math.imul(Ae, Ze) | 0, _ = _ + Math.imul(Ae, tt) | 0, _ = _ + Math.imul(Be, Ze) | 0, I = I + Math.imul(Be, tt) | 0;
      var Dt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      L = (I + (_ >>> 13) | 0) + (Dt >>> 26) | 0, Dt &= 67108863, P = Math.imul(Te, Ze), _ = Math.imul(Te, tt), _ = _ + Math.imul(Ue, Ze) | 0, I = Math.imul(Ue, tt);
      var kt = (L + P | 0) + ((_ & 8191) << 13) | 0;
      return L = (I + (_ >>> 13) | 0) + (kt >>> 26) | 0, kt &= 67108863, C[0] = vt, C[1] = mt, C[2] = wt, C[3] = Mt, C[4] = _t, C[5] = xt, C[6] = Et, C[7] = St, C[8] = $t, C[9] = At, C[10] = Rt, C[11] = Bt, C[12] = Tt, C[13] = Pt, C[14] = It, C[15] = Ot, C[16] = Ct, C[17] = Dt, C[18] = kt, L !== 0 && (C[19] = L, A.length++), A;
    };
    Math.imul || (ce = fe);
    function me(N, y, E) {
      E.negative = y.negative ^ N.negative, E.length = N.length + y.length;
      for (var A = 0, B = 0, O = 0; O < E.length - 1; O++) {
        var C = B;
        B = 0;
        for (var L = A & 67108863, P = Math.min(O, y.length - 1), _ = Math.max(0, O - N.length + 1); _ <= P; _++) {
          var I = O - _, U = N.words[I] | 0, Y = y.words[_] | 0, te = U * Y, oe = te & 67108863;
          C = C + (te / 67108864 | 0) | 0, oe = oe + L | 0, L = oe & 67108863, C = C + (oe >>> 26) | 0, B += C >>> 26, C &= 67108863;
        }
        E.words[O] = L, A = C, C = B;
      }
      return A !== 0 ? E.words[O] = A : E.length--, E.strip();
    }
    function de(N, y, E) {
      var A = new ne();
      return A.mulp(N, y, E);
    }
    S.prototype.mulTo = function(y, E) {
      var A, B = this.length + y.length;
      return this.length === 10 && y.length === 10 ? A = ce(this, y, E) : B < 63 ? A = fe(this, y, E) : B < 1024 ? A = me(this, y, E) : A = de(this, y, E), A;
    };
    function ne(N, y) {
      this.x = N, this.y = y;
    }
    ne.prototype.makeRBT = function(y) {
      for (var E = new Array(y), A = S.prototype._countBits(y) - 1, B = 0; B < y; B++)
        E[B] = this.revBin(B, A, y);
      return E;
    }, ne.prototype.revBin = function(y, E, A) {
      if (y === 0 || y === A - 1) return y;
      for (var B = 0, O = 0; O < E; O++)
        B |= (y & 1) << E - O - 1, y >>= 1;
      return B;
    }, ne.prototype.permute = function(y, E, A, B, O, C) {
      for (var L = 0; L < C; L++)
        B[L] = E[y[L]], O[L] = A[y[L]];
    }, ne.prototype.transform = function(y, E, A, B, O, C) {
      this.permute(C, y, E, A, B, O);
      for (var L = 1; L < O; L <<= 1)
        for (var P = L << 1, _ = Math.cos(2 * Math.PI / P), I = Math.sin(2 * Math.PI / P), U = 0; U < O; U += P)
          for (var Y = _, te = I, oe = 0; oe < L; oe++) {
            var re = A[U + oe], ee = B[U + oe], ae = A[U + oe + L], ue = B[U + oe + L], ye = Y * ae - te * ue;
            ue = Y * ue + te * ae, ae = ye, A[U + oe] = re + ae, B[U + oe] = ee + ue, A[U + oe + L] = re - ae, B[U + oe + L] = ee - ue, oe !== P && (ye = _ * Y - I * te, te = _ * te + I * Y, Y = ye);
          }
    }, ne.prototype.guessLen13b = function(y, E) {
      var A = Math.max(E, y) | 1, B = A & 1, O = 0;
      for (A = A / 2 | 0; A; A = A >>> 1)
        O++;
      return 1 << O + 1 + B;
    }, ne.prototype.conjugate = function(y, E, A) {
      if (!(A <= 1))
        for (var B = 0; B < A / 2; B++) {
          var O = y[B];
          y[B] = y[A - B - 1], y[A - B - 1] = O, O = E[B], E[B] = -E[A - B - 1], E[A - B - 1] = -O;
        }
    }, ne.prototype.normalize13b = function(y, E) {
      for (var A = 0, B = 0; B < E / 2; B++) {
        var O = Math.round(y[2 * B + 1] / E) * 8192 + Math.round(y[2 * B] / E) + A;
        y[B] = O & 67108863, O < 67108864 ? A = 0 : A = O / 67108864 | 0;
      }
      return y;
    }, ne.prototype.convert13b = function(y, E, A, B) {
      for (var O = 0, C = 0; C < E; C++)
        O = O + (y[C] | 0), A[2 * C] = O & 8191, O = O >>> 13, A[2 * C + 1] = O & 8191, O = O >>> 13;
      for (C = 2 * E; C < B; ++C)
        A[C] = 0;
      $(O === 0), $((O & -8192) === 0);
    }, ne.prototype.stub = function(y) {
      for (var E = new Array(y), A = 0; A < y; A++)
        E[A] = 0;
      return E;
    }, ne.prototype.mulp = function(y, E, A) {
      var B = 2 * this.guessLen13b(y.length, E.length), O = this.makeRBT(B), C = this.stub(B), L = new Array(B), P = new Array(B), _ = new Array(B), I = new Array(B), U = new Array(B), Y = new Array(B), te = A.words;
      te.length = B, this.convert13b(y.words, y.length, L, B), this.convert13b(E.words, E.length, I, B), this.transform(L, C, P, _, B, O), this.transform(I, C, U, Y, B, O);
      for (var oe = 0; oe < B; oe++) {
        var re = P[oe] * U[oe] - _[oe] * Y[oe];
        _[oe] = P[oe] * Y[oe] + _[oe] * U[oe], P[oe] = re;
      }
      return this.conjugate(P, _, B), this.transform(P, _, te, C, B, O), this.conjugate(te, C, B), this.normalize13b(te, B), A.negative = y.negative ^ E.negative, A.length = y.length + E.length, A.strip();
    }, S.prototype.mul = function(y) {
      var E = new S(null);
      return E.words = new Array(this.length + y.length), this.mulTo(y, E);
    }, S.prototype.mulf = function(y) {
      var E = new S(null);
      return E.words = new Array(this.length + y.length), de(this, y, E);
    }, S.prototype.imul = function(y) {
      return this.clone().mulTo(y, this);
    }, S.prototype.imuln = function(y) {
      $(typeof y == "number"), $(y < 67108864);
      for (var E = 0, A = 0; A < this.length; A++) {
        var B = (this.words[A] | 0) * y, O = (B & 67108863) + (E & 67108863);
        E >>= 26, E += B / 67108864 | 0, E += O >>> 26, this.words[A] = O & 67108863;
      }
      return E !== 0 && (this.words[A] = E, this.length++), this.length = y === 0 ? 1 : this.length, this;
    }, S.prototype.muln = function(y) {
      return this.clone().imuln(y);
    }, S.prototype.sqr = function() {
      return this.mul(this);
    }, S.prototype.isqr = function() {
      return this.imul(this.clone());
    }, S.prototype.pow = function(y) {
      var E = Q(y);
      if (E.length === 0) return new S(1);
      for (var A = this, B = 0; B < E.length && E[B] === 0; B++, A = A.sqr())
        ;
      if (++B < E.length)
        for (var O = A.sqr(); B < E.length; B++, O = O.sqr())
          E[B] !== 0 && (A = A.mul(O));
      return A;
    }, S.prototype.iushln = function(y) {
      $(typeof y == "number" && y >= 0);
      var E = y % 26, A = (y - E) / 26, B = 67108863 >>> 26 - E << 26 - E, O;
      if (E !== 0) {
        var C = 0;
        for (O = 0; O < this.length; O++) {
          var L = this.words[O] & B, P = (this.words[O] | 0) - L << E;
          this.words[O] = P | C, C = L >>> 26 - E;
        }
        C && (this.words[O] = C, this.length++);
      }
      if (A !== 0) {
        for (O = this.length - 1; O >= 0; O--)
          this.words[O + A] = this.words[O];
        for (O = 0; O < A; O++)
          this.words[O] = 0;
        this.length += A;
      }
      return this.strip();
    }, S.prototype.ishln = function(y) {
      return $(this.negative === 0), this.iushln(y);
    }, S.prototype.iushrn = function(y, E, A) {
      $(typeof y == "number" && y >= 0);
      var B;
      E ? B = (E - E % 26) / 26 : B = 0;
      var O = y % 26, C = Math.min((y - O) / 26, this.length), L = 67108863 ^ 67108863 >>> O << O, P = A;
      if (B -= C, B = Math.max(0, B), P) {
        for (var _ = 0; _ < C; _++)
          P.words[_] = this.words[_];
        P.length = C;
      }
      if (C !== 0) if (this.length > C)
        for (this.length -= C, _ = 0; _ < this.length; _++)
          this.words[_] = this.words[_ + C];
      else
        this.words[0] = 0, this.length = 1;
      var I = 0;
      for (_ = this.length - 1; _ >= 0 && (I !== 0 || _ >= B); _--) {
        var U = this.words[_] | 0;
        this.words[_] = I << 26 - O | U >>> O, I = U & L;
      }
      return P && I !== 0 && (P.words[P.length++] = I), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, S.prototype.ishrn = function(y, E, A) {
      return $(this.negative === 0), this.iushrn(y, E, A);
    }, S.prototype.shln = function(y) {
      return this.clone().ishln(y);
    }, S.prototype.ushln = function(y) {
      return this.clone().iushln(y);
    }, S.prototype.shrn = function(y) {
      return this.clone().ishrn(y);
    }, S.prototype.ushrn = function(y) {
      return this.clone().iushrn(y);
    }, S.prototype.testn = function(y) {
      $(typeof y == "number" && y >= 0);
      var E = y % 26, A = (y - E) / 26, B = 1 << E;
      if (this.length <= A) return !1;
      var O = this.words[A];
      return !!(O & B);
    }, S.prototype.imaskn = function(y) {
      $(typeof y == "number" && y >= 0);
      var E = y % 26, A = (y - E) / 26;
      if ($(this.negative === 0, "imaskn works only with positive numbers"), this.length <= A)
        return this;
      if (E !== 0 && A++, this.length = Math.min(A, this.length), E !== 0) {
        var B = 67108863 ^ 67108863 >>> E << E;
        this.words[this.length - 1] &= B;
      }
      return this.strip();
    }, S.prototype.maskn = function(y) {
      return this.clone().imaskn(y);
    }, S.prototype.iaddn = function(y) {
      return $(typeof y == "number"), $(y < 67108864), y < 0 ? this.isubn(-y) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < y ? (this.words[0] = y - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(y), this.negative = 1, this) : this._iaddn(y);
    }, S.prototype._iaddn = function(y) {
      this.words[0] += y;
      for (var E = 0; E < this.length && this.words[E] >= 67108864; E++)
        this.words[E] -= 67108864, E === this.length - 1 ? this.words[E + 1] = 1 : this.words[E + 1]++;
      return this.length = Math.max(this.length, E + 1), this;
    }, S.prototype.isubn = function(y) {
      if ($(typeof y == "number"), $(y < 67108864), y < 0) return this.iaddn(-y);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(y), this.negative = 1, this;
      if (this.words[0] -= y, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var E = 0; E < this.length && this.words[E] < 0; E++)
          this.words[E] += 67108864, this.words[E + 1] -= 1;
      return this.strip();
    }, S.prototype.addn = function(y) {
      return this.clone().iaddn(y);
    }, S.prototype.subn = function(y) {
      return this.clone().isubn(y);
    }, S.prototype.iabs = function() {
      return this.negative = 0, this;
    }, S.prototype.abs = function() {
      return this.clone().iabs();
    }, S.prototype._ishlnsubmul = function(y, E, A) {
      var B = y.length + A, O;
      this._expand(B);
      var C, L = 0;
      for (O = 0; O < y.length; O++) {
        C = (this.words[O + A] | 0) + L;
        var P = (y.words[O] | 0) * E;
        C -= P & 67108863, L = (C >> 26) - (P / 67108864 | 0), this.words[O + A] = C & 67108863;
      }
      for (; O < this.length - A; O++)
        C = (this.words[O + A] | 0) + L, L = C >> 26, this.words[O + A] = C & 67108863;
      if (L === 0) return this.strip();
      for ($(L === -1), L = 0, O = 0; O < this.length; O++)
        C = -(this.words[O] | 0) + L, L = C >> 26, this.words[O] = C & 67108863;
      return this.negative = 1, this.strip();
    }, S.prototype._wordDiv = function(y, E) {
      var A = this.length - y.length, B = this.clone(), O = y, C = O.words[O.length - 1] | 0, L = this._countBits(C);
      A = 26 - L, A !== 0 && (O = O.ushln(A), B.iushln(A), C = O.words[O.length - 1] | 0);
      var P = B.length - O.length, _;
      if (E !== "mod") {
        _ = new S(null), _.length = P + 1, _.words = new Array(_.length);
        for (var I = 0; I < _.length; I++)
          _.words[I] = 0;
      }
      var U = B.clone()._ishlnsubmul(O, 1, P);
      U.negative === 0 && (B = U, _ && (_.words[P] = 1));
      for (var Y = P - 1; Y >= 0; Y--) {
        var te = (B.words[O.length + Y] | 0) * 67108864 + (B.words[O.length + Y - 1] | 0);
        for (te = Math.min(te / C | 0, 67108863), B._ishlnsubmul(O, te, Y); B.negative !== 0; )
          te--, B.negative = 0, B._ishlnsubmul(O, 1, Y), B.isZero() || (B.negative ^= 1);
        _ && (_.words[Y] = te);
      }
      return _ && _.strip(), B.strip(), E !== "div" && A !== 0 && B.iushrn(A), {
        div: _ || null,
        mod: B
      };
    }, S.prototype.divmod = function(y, E, A) {
      if ($(!y.isZero()), this.isZero())
        return {
          div: new S(0),
          mod: new S(0)
        };
      var B, O, C;
      return this.negative !== 0 && y.negative === 0 ? (C = this.neg().divmod(y, E), E !== "mod" && (B = C.div.neg()), E !== "div" && (O = C.mod.neg(), A && O.negative !== 0 && O.iadd(y)), {
        div: B,
        mod: O
      }) : this.negative === 0 && y.negative !== 0 ? (C = this.divmod(y.neg(), E), E !== "mod" && (B = C.div.neg()), {
        div: B,
        mod: C.mod
      }) : this.negative & y.negative ? (C = this.neg().divmod(y.neg(), E), E !== "div" && (O = C.mod.neg(), A && O.negative !== 0 && O.isub(y)), {
        div: C.div,
        mod: O
      }) : y.length > this.length || this.cmp(y) < 0 ? {
        div: new S(0),
        mod: this
      } : y.length === 1 ? E === "div" ? {
        div: this.divn(y.words[0]),
        mod: null
      } : E === "mod" ? {
        div: null,
        mod: new S(this.modn(y.words[0]))
      } : {
        div: this.divn(y.words[0]),
        mod: new S(this.modn(y.words[0]))
      } : this._wordDiv(y, E);
    }, S.prototype.div = function(y) {
      return this.divmod(y, "div", !1).div;
    }, S.prototype.mod = function(y) {
      return this.divmod(y, "mod", !1).mod;
    }, S.prototype.umod = function(y) {
      return this.divmod(y, "mod", !0).mod;
    }, S.prototype.divRound = function(y) {
      var E = this.divmod(y);
      if (E.mod.isZero()) return E.div;
      var A = E.div.negative !== 0 ? E.mod.isub(y) : E.mod, B = y.ushrn(1), O = y.andln(1), C = A.cmp(B);
      return C < 0 || O === 1 && C === 0 ? E.div : E.div.negative !== 0 ? E.div.isubn(1) : E.div.iaddn(1);
    }, S.prototype.modn = function(y) {
      $(y <= 67108863);
      for (var E = (1 << 26) % y, A = 0, B = this.length - 1; B >= 0; B--)
        A = (E * A + (this.words[B] | 0)) % y;
      return A;
    }, S.prototype.idivn = function(y) {
      $(y <= 67108863);
      for (var E = 0, A = this.length - 1; A >= 0; A--) {
        var B = (this.words[A] | 0) + E * 67108864;
        this.words[A] = B / y | 0, E = B % y;
      }
      return this.strip();
    }, S.prototype.divn = function(y) {
      return this.clone().idivn(y);
    }, S.prototype.egcd = function(y) {
      $(y.negative === 0), $(!y.isZero());
      var E = this, A = y.clone();
      E.negative !== 0 ? E = E.umod(y) : E = E.clone();
      for (var B = new S(1), O = new S(0), C = new S(0), L = new S(1), P = 0; E.isEven() && A.isEven(); )
        E.iushrn(1), A.iushrn(1), ++P;
      for (var _ = A.clone(), I = E.clone(); !E.isZero(); ) {
        for (var U = 0, Y = 1; !(E.words[0] & Y) && U < 26; ++U, Y <<= 1) ;
        if (U > 0)
          for (E.iushrn(U); U-- > 0; )
            (B.isOdd() || O.isOdd()) && (B.iadd(_), O.isub(I)), B.iushrn(1), O.iushrn(1);
        for (var te = 0, oe = 1; !(A.words[0] & oe) && te < 26; ++te, oe <<= 1) ;
        if (te > 0)
          for (A.iushrn(te); te-- > 0; )
            (C.isOdd() || L.isOdd()) && (C.iadd(_), L.isub(I)), C.iushrn(1), L.iushrn(1);
        E.cmp(A) >= 0 ? (E.isub(A), B.isub(C), O.isub(L)) : (A.isub(E), C.isub(B), L.isub(O));
      }
      return {
        a: C,
        b: L,
        gcd: A.iushln(P)
      };
    }, S.prototype._invmp = function(y) {
      $(y.negative === 0), $(!y.isZero());
      var E = this, A = y.clone();
      E.negative !== 0 ? E = E.umod(y) : E = E.clone();
      for (var B = new S(1), O = new S(0), C = A.clone(); E.cmpn(1) > 0 && A.cmpn(1) > 0; ) {
        for (var L = 0, P = 1; !(E.words[0] & P) && L < 26; ++L, P <<= 1) ;
        if (L > 0)
          for (E.iushrn(L); L-- > 0; )
            B.isOdd() && B.iadd(C), B.iushrn(1);
        for (var _ = 0, I = 1; !(A.words[0] & I) && _ < 26; ++_, I <<= 1) ;
        if (_ > 0)
          for (A.iushrn(_); _-- > 0; )
            O.isOdd() && O.iadd(C), O.iushrn(1);
        E.cmp(A) >= 0 ? (E.isub(A), B.isub(O)) : (A.isub(E), O.isub(B));
      }
      var U;
      return E.cmpn(1) === 0 ? U = B : U = O, U.cmpn(0) < 0 && U.iadd(y), U;
    }, S.prototype.gcd = function(y) {
      if (this.isZero()) return y.abs();
      if (y.isZero()) return this.abs();
      var E = this.clone(), A = y.clone();
      E.negative = 0, A.negative = 0;
      for (var B = 0; E.isEven() && A.isEven(); B++)
        E.iushrn(1), A.iushrn(1);
      do {
        for (; E.isEven(); )
          E.iushrn(1);
        for (; A.isEven(); )
          A.iushrn(1);
        var O = E.cmp(A);
        if (O < 0) {
          var C = E;
          E = A, A = C;
        } else if (O === 0 || A.cmpn(1) === 0)
          break;
        E.isub(A);
      } while (!0);
      return A.iushln(B);
    }, S.prototype.invm = function(y) {
      return this.egcd(y).a.umod(y);
    }, S.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, S.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, S.prototype.andln = function(y) {
      return this.words[0] & y;
    }, S.prototype.bincn = function(y) {
      $(typeof y == "number");
      var E = y % 26, A = (y - E) / 26, B = 1 << E;
      if (this.length <= A)
        return this._expand(A + 1), this.words[A] |= B, this;
      for (var O = B, C = A; O !== 0 && C < this.length; C++) {
        var L = this.words[C] | 0;
        L += O, O = L >>> 26, L &= 67108863, this.words[C] = L;
      }
      return O !== 0 && (this.words[C] = O, this.length++), this;
    }, S.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, S.prototype.cmpn = function(y) {
      var E = y < 0;
      if (this.negative !== 0 && !E) return -1;
      if (this.negative === 0 && E) return 1;
      this.strip();
      var A;
      if (this.length > 1)
        A = 1;
      else {
        E && (y = -y), $(y <= 67108863, "Number is too big");
        var B = this.words[0] | 0;
        A = B === y ? 0 : B < y ? -1 : 1;
      }
      return this.negative !== 0 ? -A | 0 : A;
    }, S.prototype.cmp = function(y) {
      if (this.negative !== 0 && y.negative === 0) return -1;
      if (this.negative === 0 && y.negative !== 0) return 1;
      var E = this.ucmp(y);
      return this.negative !== 0 ? -E | 0 : E;
    }, S.prototype.ucmp = function(y) {
      if (this.length > y.length) return 1;
      if (this.length < y.length) return -1;
      for (var E = 0, A = this.length - 1; A >= 0; A--) {
        var B = this.words[A] | 0, O = y.words[A] | 0;
        if (B !== O) {
          B < O ? E = -1 : B > O && (E = 1);
          break;
        }
      }
      return E;
    }, S.prototype.gtn = function(y) {
      return this.cmpn(y) === 1;
    }, S.prototype.gt = function(y) {
      return this.cmp(y) === 1;
    }, S.prototype.gten = function(y) {
      return this.cmpn(y) >= 0;
    }, S.prototype.gte = function(y) {
      return this.cmp(y) >= 0;
    }, S.prototype.ltn = function(y) {
      return this.cmpn(y) === -1;
    }, S.prototype.lt = function(y) {
      return this.cmp(y) === -1;
    }, S.prototype.lten = function(y) {
      return this.cmpn(y) <= 0;
    }, S.prototype.lte = function(y) {
      return this.cmp(y) <= 0;
    }, S.prototype.eqn = function(y) {
      return this.cmpn(y) === 0;
    }, S.prototype.eq = function(y) {
      return this.cmp(y) === 0;
    }, S.red = function(y) {
      return new xe(y);
    }, S.prototype.toRed = function(y) {
      return $(!this.red, "Already a number in reduction context"), $(this.negative === 0, "red works only with positives"), y.convertTo(this)._forceRed(y);
    }, S.prototype.fromRed = function() {
      return $(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, S.prototype._forceRed = function(y) {
      return this.red = y, this;
    }, S.prototype.forceRed = function(y) {
      return $(!this.red, "Already a number in reduction context"), this._forceRed(y);
    }, S.prototype.redAdd = function(y) {
      return $(this.red, "redAdd works only with red numbers"), this.red.add(this, y);
    }, S.prototype.redIAdd = function(y) {
      return $(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, y);
    }, S.prototype.redSub = function(y) {
      return $(this.red, "redSub works only with red numbers"), this.red.sub(this, y);
    }, S.prototype.redISub = function(y) {
      return $(this.red, "redISub works only with red numbers"), this.red.isub(this, y);
    }, S.prototype.redShl = function(y) {
      return $(this.red, "redShl works only with red numbers"), this.red.shl(this, y);
    }, S.prototype.redMul = function(y) {
      return $(this.red, "redMul works only with red numbers"), this.red._verify2(this, y), this.red.mul(this, y);
    }, S.prototype.redIMul = function(y) {
      return $(this.red, "redMul works only with red numbers"), this.red._verify2(this, y), this.red.imul(this, y);
    }, S.prototype.redSqr = function() {
      return $(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, S.prototype.redISqr = function() {
      return $(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, S.prototype.redSqrt = function() {
      return $(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, S.prototype.redInvm = function() {
      return $(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, S.prototype.redNeg = function() {
      return $(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, S.prototype.redPow = function(y) {
      return $(this.red && !y.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, y);
    };
    var ge = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function pe(N, y) {
      this.name = N, this.p = new S(y, 16), this.n = this.p.bitLength(), this.k = new S(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    pe.prototype._tmp = function() {
      var y = new S(null);
      return y.words = new Array(Math.ceil(this.n / 13)), y;
    }, pe.prototype.ireduce = function(y) {
      var E = y, A;
      do
        this.split(E, this.tmp), E = this.imulK(E), E = E.iadd(this.tmp), A = E.bitLength();
      while (A > this.n);
      var B = A < this.n ? -1 : E.ucmp(this.p);
      return B === 0 ? (E.words[0] = 0, E.length = 1) : B > 0 ? E.isub(this.p) : E.strip !== void 0 ? E.strip() : E._strip(), E;
    }, pe.prototype.split = function(y, E) {
      y.iushrn(this.n, 0, E);
    }, pe.prototype.imulK = function(y) {
      return y.imul(this.k);
    };
    function $e() {
      pe.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    T($e, pe), $e.prototype.split = function(y, E) {
      for (var A = 4194303, B = Math.min(y.length, 9), O = 0; O < B; O++)
        E.words[O] = y.words[O];
      if (E.length = B, y.length <= 9) {
        y.words[0] = 0, y.length = 1;
        return;
      }
      var C = y.words[9];
      for (E.words[E.length++] = C & A, O = 10; O < y.length; O++) {
        var L = y.words[O] | 0;
        y.words[O - 10] = (L & A) << 4 | C >>> 22, C = L;
      }
      C >>>= 22, y.words[O - 10] = C, C === 0 && y.length > 10 ? y.length -= 10 : y.length -= 9;
    }, $e.prototype.imulK = function(y) {
      y.words[y.length] = 0, y.words[y.length + 1] = 0, y.length += 2;
      for (var E = 0, A = 0; A < y.length; A++) {
        var B = y.words[A] | 0;
        E += B * 977, y.words[A] = E & 67108863, E = B * 64 + (E / 67108864 | 0);
      }
      return y.words[y.length - 1] === 0 && (y.length--, y.words[y.length - 1] === 0 && y.length--), y;
    };
    function Re() {
      pe.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    T(Re, pe);
    function Pe() {
      pe.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    T(Pe, pe);
    function Oe() {
      pe.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    T(Oe, pe), Oe.prototype.imulK = function(y) {
      for (var E = 0, A = 0; A < y.length; A++) {
        var B = (y.words[A] | 0) * 19 + E, O = B & 67108863;
        B >>>= 26, y.words[A] = O, E = B;
      }
      return E !== 0 && (y.words[y.length++] = E), y;
    }, S._prime = function(y) {
      if (ge[y]) return ge[y];
      var E;
      if (y === "k256")
        E = new $e();
      else if (y === "p224")
        E = new Re();
      else if (y === "p192")
        E = new Pe();
      else if (y === "p25519")
        E = new Oe();
      else
        throw new Error("Unknown prime " + y);
      return ge[y] = E, E;
    };
    function xe(N) {
      if (typeof N == "string") {
        var y = S._prime(N);
        this.m = y.p, this.prime = y;
      } else
        $(N.gtn(1), "modulus must be greater than 1"), this.m = N, this.prime = null;
    }
    xe.prototype._verify1 = function(y) {
      $(y.negative === 0, "red works only with positives"), $(y.red, "red works only with red numbers");
    }, xe.prototype._verify2 = function(y, E) {
      $((y.negative | E.negative) === 0, "red works only with positives"), $(
        y.red && y.red === E.red,
        "red works only with red numbers"
      );
    }, xe.prototype.imod = function(y) {
      return this.prime ? this.prime.ireduce(y)._forceRed(this) : y.umod(this.m)._forceRed(this);
    }, xe.prototype.neg = function(y) {
      return y.isZero() ? y.clone() : this.m.sub(y)._forceRed(this);
    }, xe.prototype.add = function(y, E) {
      this._verify2(y, E);
      var A = y.add(E);
      return A.cmp(this.m) >= 0 && A.isub(this.m), A._forceRed(this);
    }, xe.prototype.iadd = function(y, E) {
      this._verify2(y, E);
      var A = y.iadd(E);
      return A.cmp(this.m) >= 0 && A.isub(this.m), A;
    }, xe.prototype.sub = function(y, E) {
      this._verify2(y, E);
      var A = y.sub(E);
      return A.cmpn(0) < 0 && A.iadd(this.m), A._forceRed(this);
    }, xe.prototype.isub = function(y, E) {
      this._verify2(y, E);
      var A = y.isub(E);
      return A.cmpn(0) < 0 && A.iadd(this.m), A;
    }, xe.prototype.shl = function(y, E) {
      return this._verify1(y), this.imod(y.ushln(E));
    }, xe.prototype.imul = function(y, E) {
      return this._verify2(y, E), this.imod(y.imul(E));
    }, xe.prototype.mul = function(y, E) {
      return this._verify2(y, E), this.imod(y.mul(E));
    }, xe.prototype.isqr = function(y) {
      return this.imul(y, y.clone());
    }, xe.prototype.sqr = function(y) {
      return this.mul(y, y);
    }, xe.prototype.sqrt = function(y) {
      if (y.isZero()) return y.clone();
      var E = this.m.andln(3);
      if ($(E % 2 === 1), E === 3) {
        var A = this.m.add(new S(1)).iushrn(2);
        return this.pow(y, A);
      }
      for (var B = this.m.subn(1), O = 0; !B.isZero() && B.andln(1) === 0; )
        O++, B.iushrn(1);
      $(!B.isZero());
      var C = new S(1).toRed(this), L = C.redNeg(), P = this.m.subn(1).iushrn(1), _ = this.m.bitLength();
      for (_ = new S(2 * _ * _).toRed(this); this.pow(_, P).cmp(L) !== 0; )
        _.redIAdd(L);
      for (var I = this.pow(_, B), U = this.pow(y, B.addn(1).iushrn(1)), Y = this.pow(y, B), te = O; Y.cmp(C) !== 0; ) {
        for (var oe = Y, re = 0; oe.cmp(C) !== 0; re++)
          oe = oe.redSqr();
        $(re < te);
        var ee = this.pow(I, new S(1).iushln(te - re - 1));
        U = U.redMul(ee), I = ee.redSqr(), Y = Y.redMul(I), te = re;
      }
      return U;
    }, xe.prototype.invm = function(y) {
      var E = y._invmp(this.m);
      return E.negative !== 0 ? (E.negative = 0, this.imod(E).redNeg()) : this.imod(E);
    }, xe.prototype.pow = function(y, E) {
      if (E.isZero()) return new S(1).toRed(this);
      if (E.cmpn(1) === 0) return y.clone();
      var A = 4, B = new Array(1 << A);
      B[0] = new S(1).toRed(this), B[1] = y;
      for (var O = 2; O < B.length; O++)
        B[O] = this.mul(B[O - 1], y);
      var C = B[0], L = 0, P = 0, _ = E.bitLength() % 26;
      for (_ === 0 && (_ = 26), O = E.length - 1; O >= 0; O--) {
        for (var I = E.words[O], U = _ - 1; U >= 0; U--) {
          var Y = I >> U & 1;
          if (C !== B[0] && (C = this.sqr(C)), Y === 0 && L === 0) {
            P = 0;
            continue;
          }
          L <<= 1, L |= Y, P++, !(P !== A && (O !== 0 || U !== 0)) && (C = this.mul(C, B[L]), P = 0, L = 0);
        }
        _ = 26;
      }
      return C;
    }, xe.prototype.convertTo = function(y) {
      var E = y.umod(this.m);
      return E === y ? E.clone() : E;
    }, xe.prototype.convertFrom = function(y) {
      var E = y.clone();
      return E.red = null, E;
    }, S.mont = function(y) {
      return new rt(y);
    };
    function rt(N) {
      xe.call(this, N), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new S(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    T(rt, xe), rt.prototype.convertTo = function(y) {
      return this.imod(y.ushln(this.shift));
    }, rt.prototype.convertFrom = function(y) {
      var E = this.imod(y.mul(this.rinv));
      return E.red = null, E;
    }, rt.prototype.imul = function(y, E) {
      if (y.isZero() || E.isZero())
        return y.words[0] = 0, y.length = 1, y;
      var A = y.imul(E), B = A.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), O = A.isub(B).iushrn(this.shift), C = O;
      return O.cmp(this.m) >= 0 ? C = O.isub(this.m) : O.cmpn(0) < 0 && (C = O.iadd(this.m)), C._forceRed(this);
    }, rt.prototype.mul = function(y, E) {
      if (y.isZero() || E.isZero()) return new S(0)._forceRed(this);
      var A = y.mul(E), B = A.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), O = A.isub(B).iushrn(this.shift), C = O;
      return O.cmp(this.m) >= 0 ? C = O.isub(this.m) : O.cmpn(0) < 0 && (C = O.iadd(this.m)), C._forceRed(this);
    }, rt.prototype.invm = function(y) {
      var E = this.imod(y._invmp(this.m).mul(this.r2));
      return E._forceRed(this);
    };
  })(w, commonjsGlobal);
})(bn);
var bnExports = bn.exports, BN$2 = bnExports, Buffer$3 = safeBufferExports$2.Buffer;
function withPublic$2(w, M) {
  return Buffer$3.from(w.toRed(BN$2.mont(M.modulus)).redPow(new BN$2(M.publicExponent)).fromRed().toArray());
}
var withPublic_1 = withPublic$2, parseKeys$1 = parseAsn1, randomBytes = browserExports, createHash$1 = browser$9, mgf$1 = mgf$2, xor$1 = xor$2, BN$1 = bnExports, withPublic$1 = withPublic_1, crt$1 = browserifyRsa, Buffer$2 = safeBufferExports$2.Buffer, publicEncrypt = function w(M, x, $) {
  var T;
  M.padding ? T = M.padding : $ ? T = 1 : T = 4;
  var S = parseKeys$1(M), D;
  if (T === 4)
    D = oaep$1(S, x);
  else if (T === 1)
    D = pkcs1$1(S, x, $);
  else if (T === 3) {
    if (D = new BN$1(x), D.cmp(S.modulus) >= 0)
      throw new Error("data too long for modulus");
  } else
    throw new Error("unknown padding");
  return $ ? crt$1(D, S) : withPublic$1(D, S);
};
function oaep$1(w, M) {
  var x = w.modulus.byteLength(), $ = M.length, T = createHash$1("sha1").update(Buffer$2.alloc(0)).digest(), S = T.length, D = 2 * S;
  if ($ > x - D - 2)
    throw new Error("message too long");
  var F = Buffer$2.alloc(x - $ - D - 2), z = x - S - 1, Z = randomBytes(S), H = xor$1(Buffer$2.concat([T, F, Buffer$2.alloc(1, 1), M], z), mgf$1(Z, z)), V = xor$1(Z, mgf$1(H, S));
  return new BN$1(Buffer$2.concat([Buffer$2.alloc(1), V, H], x));
}
function pkcs1$1(w, M, x) {
  var $ = M.length, T = w.modulus.byteLength();
  if ($ > T - 11)
    throw new Error("message too long");
  var S;
  return x ? S = Buffer$2.alloc(T - $ - 3, 255) : S = nonZero(T - $ - 3), new BN$1(Buffer$2.concat([Buffer$2.from([0, x ? 1 : 2]), S, Buffer$2.alloc(1), M], T));
}
function nonZero(w) {
  for (var M = Buffer$2.allocUnsafe(w), x = 0, $ = randomBytes(w * 2), T = 0, S; x < w; )
    T === $.length && ($ = randomBytes(w * 2), T = 0), S = $[T++], S && (M[x++] = S);
  return M;
}
var parseKeys = parseAsn1, mgf = mgf$2, xor = xor$2, BN = bnExports, crt = browserifyRsa, createHash = browser$9, withPublic = withPublic_1, Buffer$1 = safeBufferExports$2.Buffer, privateDecrypt = function w(M, x, $) {
  var T;
  M.padding ? T = M.padding : $ ? T = 1 : T = 4;
  var S = parseKeys(M), D = S.modulus.byteLength();
  if (x.length > D || new BN(x).cmp(S.modulus) >= 0)
    throw new Error("decryption error");
  var F;
  $ ? F = withPublic(new BN(x), S) : F = crt(x, S);
  var z = Buffer$1.alloc(D - F.length);
  if (F = Buffer$1.concat([z, F], D), T === 4)
    return oaep(S, F);
  if (T === 1)
    return pkcs1(S, F, $);
  if (T === 3)
    return F;
  throw new Error("unknown padding");
};
function oaep(w, M) {
  var x = w.modulus.byteLength(), $ = createHash("sha1").update(Buffer$1.alloc(0)).digest(), T = $.length;
  if (M[0] !== 0)
    throw new Error("decryption error");
  var S = M.slice(1, T + 1), D = M.slice(T + 1), F = xor(S, mgf(D, T)), z = xor(D, mgf(F, x - T - 1));
  if (compare$1($, z.slice(0, T)))
    throw new Error("decryption error");
  for (var Z = T; z[Z] === 0; )
    Z++;
  if (z[Z++] !== 1)
    throw new Error("decryption error");
  return z.slice(Z);
}
function pkcs1(w, M, x) {
  for (var $ = M.slice(0, 2), T = 2, S = 0; M[T++] !== 0; )
    if (T >= M.length) {
      S++;
      break;
    }
  var D = M.slice(2, T - 1);
  if (($.toString("hex") !== "0002" && !x || $.toString("hex") !== "0001" && x) && S++, D.length < 8 && S++, S)
    throw new Error("decryption error");
  return M.slice(T);
}
function compare$1(w, M) {
  w = Buffer$1.from(w), M = Buffer$1.from(M);
  var x = 0, $ = w.length;
  w.length !== M.length && (x++, $ = Math.min(w.length, M.length));
  for (var T = -1; ++T < $; )
    x += w[T] ^ M[T];
  return x;
}
(function(w) {
  w.publicEncrypt = publicEncrypt, w.privateDecrypt = privateDecrypt, w.privateEncrypt = function(x, $) {
    return w.publicEncrypt(x, $, !0);
  }, w.publicDecrypt = function(x, $) {
    return w.privateDecrypt(x, $, !0);
  };
})(browser$1);
var browser = {};
function oldBrowser() {
  throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
}
var safeBuffer = safeBufferExports$2, randombytes = browserExports, Buffer = safeBuffer.Buffer, kBufferMaxLength = safeBuffer.kMaxLength, crypto$2 = commonjsGlobal.crypto || commonjsGlobal.msCrypto, kMaxUint32 = Math.pow(2, 32) - 1;
function assertOffset(w, M) {
  if (typeof w != "number" || w !== w)
    throw new TypeError("offset must be a number");
  if (w > kMaxUint32 || w < 0)
    throw new TypeError("offset must be a uint32");
  if (w > kBufferMaxLength || w > M)
    throw new RangeError("offset out of range");
}
function assertSize(w, M, x) {
  if (typeof w != "number" || w !== w)
    throw new TypeError("size must be a number");
  if (w > kMaxUint32 || w < 0)
    throw new TypeError("size must be a uint32");
  if (w + M > x || w > kBufferMaxLength)
    throw new RangeError("buffer too small");
}
crypto$2 && crypto$2.getRandomValues || !process$1.browser ? (browser.randomFill = randomFill, browser.randomFillSync = randomFillSync) : (browser.randomFill = oldBrowser, browser.randomFillSync = oldBrowser);
function randomFill(w, M, x, $) {
  if (!Buffer.isBuffer(w) && !(w instanceof commonjsGlobal.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  if (typeof M == "function")
    $ = M, M = 0, x = w.length;
  else if (typeof x == "function")
    $ = x, x = w.length - M;
  else if (typeof $ != "function")
    throw new TypeError('"cb" argument must be a function');
  return assertOffset(M, w.length), assertSize(x, M, w.length), actualFill(w, M, x, $);
}
function actualFill(w, M, x, $) {
  if (process$1.browser) {
    var T = w.buffer, S = new Uint8Array(T, M, x);
    if (crypto$2.getRandomValues(S), $) {
      process$1.nextTick(function() {
        $(null, w);
      });
      return;
    }
    return w;
  }
  if ($) {
    randombytes(x, function(F, z) {
      if (F)
        return $(F);
      z.copy(w, M), $(null, w);
    });
    return;
  }
  var D = randombytes(x);
  return D.copy(w, M), w;
}
function randomFillSync(w, M, x) {
  if (typeof M > "u" && (M = 0), !Buffer.isBuffer(w) && !(w instanceof commonjsGlobal.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  return assertOffset(M, w.length), x === void 0 && (x = w.length - M), assertSize(x, M, w.length), actualFill(w, M, x);
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify) return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = browserExports, cryptoBrowserify.createHash = cryptoBrowserify.Hash = browser$9, cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = browser$8;
  var w = algos, M = Object.keys(w), x = [
    "sha1",
    "sha224",
    "sha256",
    "sha384",
    "sha512",
    "md5",
    "rmd160"
  ].concat(M);
  cryptoBrowserify.getHashes = function() {
    return x;
  };
  var $ = browser$7;
  cryptoBrowserify.pbkdf2 = $.pbkdf2, cryptoBrowserify.pbkdf2Sync = $.pbkdf2Sync;
  var T = browser$6;
  cryptoBrowserify.Cipher = T.Cipher, cryptoBrowserify.createCipher = T.createCipher, cryptoBrowserify.Cipheriv = T.Cipheriv, cryptoBrowserify.createCipheriv = T.createCipheriv, cryptoBrowserify.Decipher = T.Decipher, cryptoBrowserify.createDecipher = T.createDecipher, cryptoBrowserify.Decipheriv = T.Decipheriv, cryptoBrowserify.createDecipheriv = T.createDecipheriv, cryptoBrowserify.getCiphers = T.getCiphers, cryptoBrowserify.listCiphers = T.listCiphers;
  var S = requireBrowser$2();
  cryptoBrowserify.DiffieHellmanGroup = S.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = S.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = S.getDiffieHellman, cryptoBrowserify.createDiffieHellman = S.createDiffieHellman, cryptoBrowserify.DiffieHellman = S.DiffieHellman;
  var D = requireBrowser$1();
  cryptoBrowserify.createSign = D.createSign, cryptoBrowserify.Sign = D.Sign, cryptoBrowserify.createVerify = D.createVerify, cryptoBrowserify.Verify = D.Verify, cryptoBrowserify.createECDH = requireBrowser();
  var F = browser$1;
  cryptoBrowserify.publicEncrypt = F.publicEncrypt, cryptoBrowserify.privateEncrypt = F.privateEncrypt, cryptoBrowserify.publicDecrypt = F.publicDecrypt, cryptoBrowserify.privateDecrypt = F.privateDecrypt;
  var z = browser;
  return cryptoBrowserify.randomFill = z.randomFill, cryptoBrowserify.randomFillSync = z.randomFillSync, cryptoBrowserify.createCredentials = function() {
    throw new Error(`sorry, createCredentials is not implemented yet
we accept pull requests
https://github.com/browserify/crypto-browserify`);
  }, cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, cryptoBrowserify;
}
const version$1 = "16.5.0", require$$4 = {
  version: version$1
}, fs = empty_1, path = pathBrowserify, os = browser$c, crypto$1 = requireCryptoBrowserify(), packageJson = require$$4, version = packageJson.version, LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
function parse(w) {
  const M = {};
  let x = w.toString();
  x = x.replace(/\r\n?/mg, `
`);
  let $;
  for (; ($ = LINE.exec(x)) != null; ) {
    const T = $[1];
    let S = $[2] || "";
    S = S.trim();
    const D = S[0];
    S = S.replace(/^(['"`])([\s\S]*)\1$/mg, "$2"), D === '"' && (S = S.replace(/\\n/g, `
`), S = S.replace(/\\r/g, "\r")), M[T] = S;
  }
  return M;
}
function _parseVault(w) {
  const M = _vaultPath(w), x = DotenvModule.configDotenv({ path: M });
  if (!x.parsed) {
    const D = new Error(`MISSING_DATA: Cannot parse ${M} for an unknown reason`);
    throw D.code = "MISSING_DATA", D;
  }
  const $ = _dotenvKey(w).split(","), T = $.length;
  let S;
  for (let D = 0; D < T; D++)
    try {
      const F = $[D].trim(), z = _instructions(x, F);
      S = DotenvModule.decrypt(z.ciphertext, z.key);
      break;
    } catch (F) {
      if (D + 1 >= T)
        throw F;
    }
  return DotenvModule.parse(S);
}
function _warn(w) {
  console.log(`[dotenv@${version}][WARN] ${w}`);
}
function _debug(w) {
  console.log(`[dotenv@${version}][DEBUG] ${w}`);
}
function _dotenvKey(w) {
  return w && w.DOTENV_KEY && w.DOTENV_KEY.length > 0 ? w.DOTENV_KEY : process$1.env.DOTENV_KEY && process$1.env.DOTENV_KEY.length > 0 ? process$1.env.DOTENV_KEY : "";
}
function _instructions(w, M) {
  let x;
  try {
    x = new URL(M);
  } catch (F) {
    if (F.code === "ERR_INVALID_URL") {
      const z = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
      throw z.code = "INVALID_DOTENV_KEY", z;
    }
    throw F;
  }
  const $ = x.password;
  if (!$) {
    const F = new Error("INVALID_DOTENV_KEY: Missing key part");
    throw F.code = "INVALID_DOTENV_KEY", F;
  }
  const T = x.searchParams.get("environment");
  if (!T) {
    const F = new Error("INVALID_DOTENV_KEY: Missing environment part");
    throw F.code = "INVALID_DOTENV_KEY", F;
  }
  const S = `DOTENV_VAULT_${T.toUpperCase()}`, D = w.parsed[S];
  if (!D) {
    const F = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${S} in your .env.vault file.`);
    throw F.code = "NOT_FOUND_DOTENV_ENVIRONMENT", F;
  }
  return { ciphertext: D, key: $ };
}
function _vaultPath(w) {
  let M = null;
  if (w && w.path && w.path.length > 0)
    if (Array.isArray(w.path))
      for (const x of w.path)
        fs.existsSync(x) && (M = x.endsWith(".vault") ? x : `${x}.vault`);
    else
      M = w.path.endsWith(".vault") ? w.path : `${w.path}.vault`;
  else
    M = path.resolve(process$1.cwd(), ".env.vault");
  return fs.existsSync(M) ? M : null;
}
function _resolveHome(w) {
  return w[0] === "~" ? path.join(os.homedir(), w.slice(1)) : w;
}
function _configVault(w) {
  !!(w && w.debug) && _debug("Loading env from encrypted .env.vault");
  const x = DotenvModule._parseVault(w);
  let $ = process$1.env;
  return w && w.processEnv != null && ($ = w.processEnv), DotenvModule.populate($, x, w), { parsed: x };
}
function configDotenv(w) {
  const M = path.resolve(process$1.cwd(), ".env");
  let x = "utf8";
  const $ = !!(w && w.debug);
  w && w.encoding ? x = w.encoding : $ && _debug("No encoding is specified. UTF-8 is used by default");
  let T = [M];
  if (w && w.path)
    if (!Array.isArray(w.path))
      T = [_resolveHome(w.path)];
    else {
      T = [];
      for (const z of w.path)
        T.push(_resolveHome(z));
    }
  let S;
  const D = {};
  for (const z of T)
    try {
      const Z = DotenvModule.parse(fs.readFileSync(z, { encoding: x }));
      DotenvModule.populate(D, Z, w);
    } catch (Z) {
      $ && _debug(`Failed to load ${z} ${Z.message}`), S = Z;
    }
  let F = process$1.env;
  return w && w.processEnv != null && (F = w.processEnv), DotenvModule.populate(F, D, w), S ? { parsed: D, error: S } : { parsed: D };
}
function config(w) {
  if (_dotenvKey(w).length === 0)
    return DotenvModule.configDotenv(w);
  const M = _vaultPath(w);
  return M ? DotenvModule._configVault(w) : (_warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${M}. Did you forget to build it?`), DotenvModule.configDotenv(w));
}
function decrypt(w, M) {
  const x = Buffer$D.from(M.slice(-64), "hex");
  let $ = Buffer$D.from(w, "base64");
  const T = $.subarray(0, 12), S = $.subarray(-16);
  $ = $.subarray(12, -16);
  try {
    const D = crypto$1.createDecipheriv("aes-256-gcm", x, T);
    return D.setAuthTag(S), `${D.update($)}${D.final()}`;
  } catch (D) {
    const F = D instanceof RangeError, z = D.message === "Invalid key length", Z = D.message === "Unsupported state or unable to authenticate data";
    if (F || z) {
      const H = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
      throw H.code = "INVALID_DOTENV_KEY", H;
    } else if (Z) {
      const H = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
      throw H.code = "DECRYPTION_FAILED", H;
    } else
      throw D;
  }
}
function populate(w, M, x = {}) {
  const $ = !!(x && x.debug), T = !!(x && x.override);
  if (typeof M != "object") {
    const S = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
    throw S.code = "OBJECT_REQUIRED", S;
  }
  for (const S of Object.keys(M))
    Object.prototype.hasOwnProperty.call(w, S) ? (T === !0 && (w[S] = M[S]), $ && _debug(T === !0 ? `"${S}" is already defined and WAS overwritten` : `"${S}" is already defined and was NOT overwritten`)) : w[S] = M[S];
}
const DotenvModule = {
  configDotenv,
  _configVault,
  _parseVault,
  config,
  decrypt,
  parse,
  populate
};
main.exports.configDotenv = DotenvModule.configDotenv;
main.exports._configVault = DotenvModule._configVault;
main.exports._parseVault = DotenvModule._parseVault;
var config_1 = main.exports.config = DotenvModule.config;
main.exports.decrypt = DotenvModule.decrypt;
main.exports.parse = DotenvModule.parse;
main.exports.populate = DotenvModule.populate;
main.exports = DotenvModule;
config_1();
const clientParams = {
  region: "us-east-1",
  credentials: fromCognitoIdentityPool({
    identityPoolId: "us-east-1:7455adfb-d9ff-445e-a564-fc79f94cb05b"
    // Replace with your actual identity pool ID
  })
  // profile: AWS_PROFILE_NAME,
  // filepath: "~/.aws/credentials",
  // configFilepath: "~/.aws/config",
}, ENGLISH_FILENAME = "en.json", FILE_PATHS = {
  IMPORT: "./import",
  TMP: "./tmp"
}, client = {
  translate: new TranslateClient(clientParams)
}, LANGUAGE_CODE_MAP = {
  en: "en",
  ch: "zh",
  es: "es",
  fr: "fr",
  ru: "ru",
  vi: "vi",
  ar: "ar",
  pt: "pt",
  ht: "ht",
  sw: "sw",
  hi: "hi"
}, ANSI_BACKGROUND_OFFSET = 10, wrapAnsi16 = (w = 0) => (M) => `\x1B[${M + w}m`, wrapAnsi256 = (w = 0) => (M) => `\x1B[${38 + w};5;${M}m`, wrapAnsi16m = (w = 0) => (M, x, $) => `\x1B[${38 + w};2;${M};${x};${$}m`, styles$1 = {
  modifier: {
    reset: [0, 0],
    // 21 isn't widely supported and 22 does the same thing
    bold: [1, 22],
    dim: [2, 22],
    italic: [3, 23],
    underline: [4, 24],
    overline: [53, 55],
    inverse: [7, 27],
    hidden: [8, 28],
    strikethrough: [9, 29]
  },
  color: {
    black: [30, 39],
    red: [31, 39],
    green: [32, 39],
    yellow: [33, 39],
    blue: [34, 39],
    magenta: [35, 39],
    cyan: [36, 39],
    white: [37, 39],
    // Bright color
    blackBright: [90, 39],
    gray: [90, 39],
    // Alias of `blackBright`
    grey: [90, 39],
    // Alias of `blackBright`
    redBright: [91, 39],
    greenBright: [92, 39],
    yellowBright: [93, 39],
    blueBright: [94, 39],
    magentaBright: [95, 39],
    cyanBright: [96, 39],
    whiteBright: [97, 39]
  },
  bgColor: {
    bgBlack: [40, 49],
    bgRed: [41, 49],
    bgGreen: [42, 49],
    bgYellow: [43, 49],
    bgBlue: [44, 49],
    bgMagenta: [45, 49],
    bgCyan: [46, 49],
    bgWhite: [47, 49],
    // Bright color
    bgBlackBright: [100, 49],
    bgGray: [100, 49],
    // Alias of `bgBlackBright`
    bgGrey: [100, 49],
    // Alias of `bgBlackBright`
    bgRedBright: [101, 49],
    bgGreenBright: [102, 49],
    bgYellowBright: [103, 49],
    bgBlueBright: [104, 49],
    bgMagentaBright: [105, 49],
    bgCyanBright: [106, 49],
    bgWhiteBright: [107, 49]
  }
};
Object.keys(styles$1.modifier);
const foregroundColorNames = Object.keys(styles$1.color), backgroundColorNames = Object.keys(styles$1.bgColor);
[...foregroundColorNames, ...backgroundColorNames];
function assembleStyles() {
  const w = /* @__PURE__ */ new Map();
  for (const [M, x] of Object.entries(styles$1)) {
    for (const [$, T] of Object.entries(x))
      styles$1[$] = {
        open: `\x1B[${T[0]}m`,
        close: `\x1B[${T[1]}m`
      }, x[$] = styles$1[$], w.set(T[0], T[1]);
    Object.defineProperty(styles$1, M, {
      value: x,
      enumerable: !1
    });
  }
  return Object.defineProperty(styles$1, "codes", {
    value: w,
    enumerable: !1
  }), styles$1.color.close = "\x1B[39m", styles$1.bgColor.close = "\x1B[49m", styles$1.color.ansi = wrapAnsi16(), styles$1.color.ansi256 = wrapAnsi256(), styles$1.color.ansi16m = wrapAnsi16m(), styles$1.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET), styles$1.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET), styles$1.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET), Object.defineProperties(styles$1, {
    rgbToAnsi256: {
      value(M, x, $) {
        return M === x && x === $ ? M < 8 ? 16 : M > 248 ? 231 : Math.round((M - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(M / 255 * 5) + 6 * Math.round(x / 255 * 5) + Math.round($ / 255 * 5);
      },
      enumerable: !1
    },
    hexToRgb: {
      value(M) {
        const x = /[a-f\d]{6}|[a-f\d]{3}/i.exec(M.toString(16));
        if (!x)
          return [0, 0, 0];
        let [$] = x;
        $.length === 3 && ($ = [...$].map((S) => S + S).join(""));
        const T = Number.parseInt($, 16);
        return [
          /* eslint-disable no-bitwise */
          T >> 16 & 255,
          T >> 8 & 255,
          T & 255
          /* eslint-enable no-bitwise */
        ];
      },
      enumerable: !1
    },
    hexToAnsi256: {
      value: (M) => styles$1.rgbToAnsi256(...styles$1.hexToRgb(M)),
      enumerable: !1
    },
    ansi256ToAnsi: {
      value(M) {
        if (M < 8)
          return 30 + M;
        if (M < 16)
          return 90 + (M - 8);
        let x, $, T;
        if (M >= 232)
          x = ((M - 232) * 10 + 8) / 255, $ = x, T = x;
        else {
          M -= 16;
          const F = M % 36;
          x = Math.floor(M / 36) / 5, $ = Math.floor(F / 6) / 5, T = F % 6 / 5;
        }
        const S = Math.max(x, $, T) * 2;
        if (S === 0)
          return 30;
        let D = 30 + (Math.round(T) << 2 | Math.round($) << 1 | Math.round(x));
        return S === 2 && (D += 60), D;
      },
      enumerable: !1
    },
    rgbToAnsi: {
      value: (M, x, $) => styles$1.ansi256ToAnsi(styles$1.rgbToAnsi256(M, x, $)),
      enumerable: !1
    },
    hexToAnsi: {
      value: (M) => styles$1.ansi256ToAnsi(styles$1.hexToAnsi256(M)),
      enumerable: !1
    }
  }), styles$1;
}
const ansiStyles = assembleStyles(), level = (() => {
  if (!("navigator" in globalThis))
    return 0;
  if (globalThis.navigator.userAgentData) {
    const w = navigator.userAgentData.brands.find(({ brand: M }) => M === "Chromium");
    if (w && w.version > 93)
      return 3;
  }
  return /\b(Chrome|Chromium)\//.test(globalThis.navigator.userAgent) ? 1 : 0;
})(), colorSupport = level !== 0 && {
  level
}, supportsColor = {
  stdout: colorSupport,
  stderr: colorSupport
};
function stringReplaceAll(w, M, x) {
  let $ = w.indexOf(M);
  if ($ === -1)
    return w;
  const T = M.length;
  let S = 0, D = "";
  do
    D += w.slice(S, $) + M + x, S = $ + T, $ = w.indexOf(M, S);
  while ($ !== -1);
  return D += w.slice(S), D;
}
function stringEncaseCRLFWithFirstIndex(w, M, x, $) {
  let T = 0, S = "";
  do {
    const D = w[$ - 1] === "\r";
    S += w.slice(T, D ? $ - 1 : $) + M + (D ? `\r
` : `
`) + x, T = $ + 1, $ = w.indexOf(`
`, T);
  } while ($ !== -1);
  return S += w.slice(T), S;
}
const { stdout: stdoutColor, stderr: stderrColor } = supportsColor, GENERATOR = Symbol("GENERATOR"), STYLER = Symbol("STYLER"), IS_EMPTY = Symbol("IS_EMPTY"), levelMapping = [
  "ansi",
  "ansi",
  "ansi256",
  "ansi16m"
], styles = /* @__PURE__ */ Object.create(null), applyOptions = (w, M = {}) => {
  if (M.level && !(Number.isInteger(M.level) && M.level >= 0 && M.level <= 3))
    throw new Error("The `level` option should be an integer from 0 to 3");
  const x = stdoutColor ? stdoutColor.level : 0;
  w.level = M.level === void 0 ? x : M.level;
}, chalkFactory = (w) => {
  const M = (...x) => x.join(" ");
  return applyOptions(M, w), Object.setPrototypeOf(M, createChalk.prototype), M;
};
function createChalk(w) {
  return chalkFactory(w);
}
Object.setPrototypeOf(createChalk.prototype, Function.prototype);
for (const [w, M] of Object.entries(ansiStyles))
  styles[w] = {
    get() {
      const x = createBuilder(this, createStyler(M.open, M.close, this[STYLER]), this[IS_EMPTY]);
      return Object.defineProperty(this, w, { value: x }), x;
    }
  };
styles.visible = {
  get() {
    const w = createBuilder(this, this[STYLER], !0);
    return Object.defineProperty(this, "visible", { value: w }), w;
  }
};
const getModelAnsi = (w, M, x, ...$) => w === "rgb" ? M === "ansi16m" ? ansiStyles[x].ansi16m(...$) : M === "ansi256" ? ansiStyles[x].ansi256(ansiStyles.rgbToAnsi256(...$)) : ansiStyles[x].ansi(ansiStyles.rgbToAnsi(...$)) : w === "hex" ? getModelAnsi("rgb", M, x, ...ansiStyles.hexToRgb(...$)) : ansiStyles[x][w](...$), usedModels = ["rgb", "hex", "ansi256"];
for (const w of usedModels) {
  styles[w] = {
    get() {
      const { level: x } = this;
      return function(...$) {
        const T = createStyler(getModelAnsi(w, levelMapping[x], "color", ...$), ansiStyles.color.close, this[STYLER]);
        return createBuilder(this, T, this[IS_EMPTY]);
      };
    }
  };
  const M = "bg" + w[0].toUpperCase() + w.slice(1);
  styles[M] = {
    get() {
      const { level: x } = this;
      return function(...$) {
        const T = createStyler(getModelAnsi(w, levelMapping[x], "bgColor", ...$), ansiStyles.bgColor.close, this[STYLER]);
        return createBuilder(this, T, this[IS_EMPTY]);
      };
    }
  };
}
const proto = Object.defineProperties(() => {
}, {
  ...styles,
  level: {
    enumerable: !0,
    get() {
      return this[GENERATOR].level;
    },
    set(w) {
      this[GENERATOR].level = w;
    }
  }
}), createStyler = (w, M, x) => {
  let $, T;
  return x === void 0 ? ($ = w, T = M) : ($ = x.openAll + w, T = M + x.closeAll), {
    open: w,
    close: M,
    openAll: $,
    closeAll: T,
    parent: x
  };
}, createBuilder = (w, M, x) => {
  const $ = (...T) => applyStyle($, T.length === 1 ? "" + T[0] : T.join(" "));
  return Object.setPrototypeOf($, proto), $[GENERATOR] = w, $[STYLER] = M, $[IS_EMPTY] = x, $;
}, applyStyle = (w, M) => {
  if (w.level <= 0 || !M)
    return w[IS_EMPTY] ? "" : M;
  let x = w[STYLER];
  if (x === void 0)
    return M;
  const { openAll: $, closeAll: T } = x;
  if (M.includes("\x1B"))
    for (; x !== void 0; )
      M = stringReplaceAll(M, x.close, x.open), x = x.parent;
  const S = M.indexOf(`
`);
  return S !== -1 && (M = stringEncaseCRLFWithFirstIndex(M, T, $, S)), $ + M + T;
};
Object.defineProperties(createChalk.prototype, styles);
const chalk = createChalk();
createChalk({ level: stderrColor ? stderrColor.level : 0 });
const GIT = process$1.env.VITE_GIT, fileFrom = ({ branch: w, file: M, filePath: x, tmpDir: $ }) => {
  const T = `${$}/${M}`, S = `${x}/${M}`;
  try {
    console.log(chalk.yellowBright("Ensure your selected branch is current with origin")), console.log(chalk.greenBright(`Running git show origin ${w}:${S} > ${T}`)), empty_1.mkdirSync($, { recursive: !0 }), empty_1.execSync(`git show ${GIT}:${S} > ${T}`);
  } catch {
    console.log(chalk.yellowBright("File not found or new Language file being called. Writing placeholder")), empty_1.writeFileSync(T, JSON.stringify({}));
  }
}, locale = ({ languageFile: w }) => {
  fileFrom({ branch: `${GIT}`, file: w, tmpDir: FILE_PATHS.TMP, filePath: FILE_PATHS.IMPORT });
}, git = {
  show: {
    fileFrom,
    locale
  }
}, remove = (w) => {
  try {
    empty_1.rmSync(w, { recursive: !0, force: !0 });
  } catch ({ message: M }) {
    console.error(M), console.log(`Unable to remove ${w}`);
  }
}, folder = {
  remove
}, supportedLanguages = async () => {
  const w = await client.translate.send(new ListLanguagesCommand());
  console.dir(w);
}, to = ({ languageCode: w }) => async ({ text: M }) => {
  if (!LANGUAGE_CODE_MAP[w])
    return console.log(chalk.yellowBright(`${w} is not supported by AWS translate or a mapping does not exist in consts.`)), "";
  const x = {
    Text: M,
    SourceLanguageCode: LANGUAGE_CODE_MAP.en,
    TargetLanguageCode: LANGUAGE_CODE_MAP[w],
    Settings: {
      // Formality: Formality.FORMAL,
      Profanity: Profanity.MASK
      // Brevity: Brevity.ON
    }
  };
  return (await client.translate.send(new TranslateTextCommand(x))).TranslatedText || "";
}, translate = {
  supportedLanguages,
  to
};
var murmurhash$1 = { exports: {} };
(function(w) {
  (function() {
    const M = (S) => new TextEncoder().encode(S);
    function x(S, D) {
      typeof S == "string" && (S = M(S));
      let F = S.length, z = D ^ F, Z = 0, H;
      for (; F >= 4; )
        H = S[Z] & 255 | (S[++Z] & 255) << 8 | (S[++Z] & 255) << 16 | (S[++Z] & 255) << 24, H = (H & 65535) * 1540483477 + (((H >>> 16) * 1540483477 & 65535) << 16), H ^= H >>> 24, H = (H & 65535) * 1540483477 + (((H >>> 16) * 1540483477 & 65535) << 16), z = (z & 65535) * 1540483477 + (((z >>> 16) * 1540483477 & 65535) << 16) ^ H, F -= 4, ++Z;
      switch (F) {
        case 3:
          z ^= (S[Z + 2] & 255) << 16;
        case 2:
          z ^= (S[Z + 1] & 255) << 8;
        case 1:
          z ^= S[Z] & 255, z = (z & 65535) * 1540483477 + (((z >>> 16) * 1540483477 & 65535) << 16);
      }
      return z ^= z >>> 13, z = (z & 65535) * 1540483477 + (((z >>> 16) * 1540483477 & 65535) << 16), z ^= z >>> 15, z >>> 0;
    }
    function $(S, D) {
      typeof S == "string" && (S = M(S));
      let F, z, Z, H, V, X, Q, fe;
      for (F = S.length & 3, z = S.length - F, Z = D, V = 3432918353, X = 461845907, fe = 0; fe < z; )
        Q = S[fe] & 255 | (S[++fe] & 255) << 8 | (S[++fe] & 255) << 16 | (S[++fe] & 255) << 24, ++fe, Q = (Q & 65535) * V + (((Q >>> 16) * V & 65535) << 16) & 4294967295, Q = Q << 15 | Q >>> 17, Q = (Q & 65535) * X + (((Q >>> 16) * X & 65535) << 16) & 4294967295, Z ^= Q, Z = Z << 13 | Z >>> 19, H = (Z & 65535) * 5 + (((Z >>> 16) * 5 & 65535) << 16) & 4294967295, Z = (H & 65535) + 27492 + (((H >>> 16) + 58964 & 65535) << 16);
      switch (Q = 0, F) {
        case 3:
          Q ^= (S[fe + 2] & 255) << 16;
        case 2:
          Q ^= (S[fe + 1] & 255) << 8;
        case 1:
          Q ^= S[fe] & 255, Q = (Q & 65535) * V + (((Q >>> 16) * V & 65535) << 16) & 4294967295, Q = Q << 15 | Q >>> 17, Q = (Q & 65535) * X + (((Q >>> 16) * X & 65535) << 16) & 4294967295, Z ^= Q;
      }
      return Z ^= S.length, Z ^= Z >>> 16, Z = (Z & 65535) * 2246822507 + (((Z >>> 16) * 2246822507 & 65535) << 16) & 4294967295, Z ^= Z >>> 13, Z = (Z & 65535) * 3266489909 + (((Z >>> 16) * 3266489909 & 65535) << 16) & 4294967295, Z ^= Z >>> 16, Z >>> 0;
    }
    const T = $;
    T.v2 = x, T.v3 = $, w.exports = T;
  })();
})(murmurhash$1);
var murmurhashExports = murmurhash$1.exports;
const murmurhash = /* @__PURE__ */ getDefaultExportFromCjs$1(murmurhashExports), compare = ({ source: w, target: M, predicate: x }) => Object.entries(w).reduce(($, [T]) => {
  const S = murmurhash.v3(w[T] || ""), D = murmurhash.v3(M[T] || "");
  return x(S, D) && $.push({ keyName: T }), $;
}, []), hash = {
  compare
};
function inflate(w) {
  var M = {};
  for (var x in w) {
    var $ = x.split("|");
    $.reduce(function(T, S, D) {
      return T[S] || (T[S] = isNaN(Number($[D + 1])) ? $.length - 1 == D ? w[x] : {} : []);
    }, M);
  }
  return M;
}
const reduceToKeys = (w, M) => w.reduce((x, { keyName: $ }) => {
  var T, S;
  return M.current[$] && ((T = x.source)[$] ?? (T[$] = M.previous[$]), (S = x.target)[$] ?? (S[$] = M.current[$])), x;
}, {
  source: {},
  target: {}
}), loadLanguage = ({ languageFile: w }) => (git.show.locale({ languageFile: w }), {
  current: locale$1.json.loadFlat({ fileName: w, directory: FILE_PATHS.IMPORT }),
  previous: locale$1.json.loadFlat({ fileName: w, directory: FILE_PATHS.TMP })
}), diff = async () => {
  folder.remove(FILE_PATHS.TMP);
  const w = loadLanguage({ languageFile: ENGLISH_FILENAME }), M = hash.compare({
    source: w.previous,
    target: w.current,
    predicate: (D, F) => D !== F
  }), x = M.map(({ keyName: D }) => D), T = locale$1.json.list(FILE_PATHS.IMPORT).reduce((D, F) => {
    D[F] ?? (D[F] = []);
    const z = loadLanguage({ languageFile: F });
    Object.keys(w.current).forEach(async (V) => {
      z.current[V] || D[F].push({
        keyName: V,
        type: "NEW",
        old: "N/A",
        current: "",
        new: w.current[V],
        proposed: "",
        translation: ""
      });
    });
    const { source: Z, target: H } = reduceToKeys(M, z);
    return hash.compare({
      source: Z,
      target: H,
      predicate: (V, X) => V === X
    }).forEach(async ({ keyName: V }) => {
      D[F].push({
        keyName: V,
        type: "CHANGED",
        old: w.previous[V],
        current: z.current[V],
        new: w.current[V],
        proposed: "",
        translation: ""
      });
    }), D;
  }, {});
  Object.keys(T).map(async (D) => {
    const [F] = D.split("."), z = translate.to({ languageCode: F }), Z = `${F}.json`, H = loadLanguage({ languageFile: Z });
    let V = {};
    for (let fe of Object.keys(w.current)) {
      const ce = w.current[fe];
      x.includes(fe) ? V[fe] = await z({ text: ce }) : V[fe] = H.current[fe];
    }
    const X = inflate(V), Q = JSON.stringify(X, null, 2);
    empty_1.writeFile(`i18n/${F}.js`, "export default" + Q, "utf8", (fe) => {
      fe && console.error("Error writing file:", fe), console.log("File written successfully:", `${F}.json`);
    });
  });
};
diff();
console.log("diff", diff);
export {
  withBaseException as $,
  AwsSdkSigV4Signer as A,
  resolveUserAgentConfig as B,
  Client as C,
  DEFAULT_RETRY_MODE as D,
  EndpointCache as E,
  FetchHttpHandler as F,
  resolveRetryConfig as G,
  resolveRegionConfig as H,
  resolveEndpointConfig as I,
  resolveHostHeaderConfig as J,
  getUserAgentPlugin as K,
  getRetryPlugin as L,
  getContentLengthPlugin as M,
  NoOpLogger as N,
  getHostHeaderPlugin as O,
  getLoggerPlugin as P,
  getRecursionDetectionPlugin as Q,
  getHttpAuthSchemeEndpointRuleSetPlugin as R,
  Sha256$2 as S,
  DefaultIdentityProviderConfig as T,
  getHttpSigningPlugin as U,
  ServiceException as V,
  parseJsonBody as W,
  HttpRequest as X,
  parseJsonErrorBody as Y,
  loadRestJsonErrorCode as Z,
  _json as _,
  resolveEndpoint as a,
  decorateServiceException as a0,
  Command as a1,
  getSerdePlugin as a2,
  getEndpointPlugin as a3,
  diff as a4,
  awsEndpointFunctions as b,
  customEndpointFunctions as c,
  toBase64 as d,
  fromBase64 as e,
  fromUtf8$2 as f,
  getSmithyContext as g,
  resolveDefaultsModeConfig as h,
  invalidProvider as i,
  DEFAULT_MAX_ATTEMPTS as j,
  createDefaultUserAgentProvider as k,
  calculateBodyLength as l,
  DEFAULT_USE_FIPS_ENDPOINT as m,
  normalizeProvider$1 as n,
  DEFAULT_USE_DUALSTACK_ENDPOINT as o,
  parseUrl as p,
  loadConfigsForDefaultMode as q,
  resolveAwsSdkSigV4Config as r,
  streamCollector as s,
  toUtf8 as t,
  getAwsRegionExtensionConfiguration as u,
  getDefaultExtensionConfiguration as v,
  getHttpHandlerExtensionConfiguration as w,
  resolveAwsRegionExtensionConfiguration as x,
  resolveDefaultRuntimeConfig as y,
  resolveHttpHandlerRuntimeConfig as z
};
